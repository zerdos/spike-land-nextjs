generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
}

model User {
  id                       String                 @id @default(cuid())
  name                     String?
  email                    String?                @unique
  emailVerified            DateTime?
  image                    String?
  createdAt                DateTime               @default(now())
  updatedAt                DateTime               @updatedAt
  stripeCustomerId         String?                @unique
  role                     UserRole               @default(USER)
  referralCode             String?                @unique
  referredById             String?
  referralCount            Int                    @default(0)
  passwordHash             String?
  accounts                 Account[]
  albums                   Album[]
  apps                     App[]
  auditLogs                AuditLog[]
  enhancedImages           EnhancedImage[]
  enhancementJobs          ImageEnhancementJob[]
  refereeReferrals         Referral[]             @relation("RefereeReferrals")
  referrerReferrals        Referral[]             @relation("ReferrerReferrals")
  sessions                 Session[]
  stripePayments           StripePayment[]
  subscription             Subscription?
  tokenTransactions        TokenTransaction[]
  tokenBalance             UserTokenBalance?
  referredBy               User?                  @relation("Referrals", fields: [referredById], references: [id])
  referrals                User[]                 @relation("Referrals")
  voucherRedemptions       VoucherRedemption[]
  feedback                 Feedback[]
  createdGalleryItems      FeaturedGalleryItem[]  @relation("GalleryItemCreator")
  emailLogs                EmailLog[]
  trackedUrls              TrackedUrl[]
  apiKeys                  ApiKey[]
  mcpGenerationJobs        McpGenerationJob[]
  boxes                    Box[]
  pipelines                EnhancementPipeline[]
  audioMixerProjects       AudioMixerProject[]
  marketingAccounts        MarketingAccount[]
  // Campaign Analytics relations
  visitorSessions          VisitorSession[]
  campaignAttributions     CampaignAttribution[]
  // Merch relations
  merchCart                MerchCart?
  merchOrders              MerchOrder[]
  // Social media tracking relations
  socialAccounts           SocialAccount[]
  socialPosts              SocialPost[]
  // Workspace relations
  workspaceMembers         WorkspaceMember[]
  workspaceInvitations     WorkspaceMember[]      @relation("WorkspaceInvitations")
  // Brand Brain relations
  createdBrandProfiles     BrandProfile[]         @relation("BrandProfileCreator")
  updatedBrandProfiles     BrandProfile[]         @relation("BrandProfileUpdater")
  contentRewrites          ContentRewrite[]
  // Calendar scheduled posts
  scheduledPosts           ScheduledPost[]
  // Relay draft reviews
  reviewedDrafts           RelayDraft[]
  // Relay draft edit history
  draftEdits               DraftEditHistory[]
  // Relay draft audit logs
  draftAuditLogs           DraftAuditLog[]
  // Comprehensive audit logs
  workspaceAuditLogs       WorkspaceAuditLog[]    @relation("WorkspaceAuditLogs")
  aiDecisionLogs           AIDecisionLog[]        @relation("AIDecisionLogs")
  // Crisis detection relations
  acknowledgedCrises       CrisisDetectionEvent[] @relation("CrisisAcknowledger")
  resolvedCrises           CrisisDetectionEvent[] @relation("CrisisResolver")
  // Account health monitoring
  resolvedHealthEvents     AccountHealthEvent[]   @relation("HealthEventResolver")
  // Policy Checker relations
  policyChecks             PolicyCheck[]
  policyViolationOverrides PolicyViolation[]

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model MarketingAccount {
  id           String            @id @default(cuid())
  userId       String
  platform     MarketingPlatform
  accountId    String // Platform-specific account ID (FB Ad Account ID, Google Ads Customer ID)
  accountName  String?
  accessToken  String // Encrypted access token
  refreshToken String? // Encrypted refresh token (for Google Ads)
  expiresAt    DateTime?
  isActive     Boolean           @default(true)
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  user         User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, platform, accountId])
  @@index([userId])
  googleAdsCampaigns GoogleAdsCampaign[]

  @@index([platform])
  @@map("marketing_accounts")
}

model GoogleAdsCampaign {
  id                 String   @id @default(cuid())
  marketingAccountId String
  campaignId         String   @unique // Google Ads Campaign ID
  name               String
  status             String // e.g., "ENABLED", "PAUSED", "REMOVED"
  spend              Int      @default(0) // in cents
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  marketingAccount MarketingAccount @relation(fields: [marketingAccountId], references: [id], onDelete: Cascade)

  @@index([marketingAccountId])
  @@map("google_ads_campaigns")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model App {
  id                 String              @id @default(cuid())
  name               String // Auto-generated: descriptive-three-words format
  slug               String?             @unique // URL-friendly name (same as codespaceId) - optional for migration
  description        String? // AI-generated description
  userId             String
  forkedFrom         String?
  status             AppBuildStatus      @default(PROMPTING) // Detailed build status
  domain             String?             @unique
  codespaceId        String?             @unique // ID of linked testing.spike.land codespace
  codespaceUrl       String? // Full URL to testing.spike.land/live/{codespaceId}/
  isCurated          Boolean             @default(false) // For public gallery display
  isPublic           Boolean             @default(false) // Visibility setting
  lastAgentActivity  DateTime? // For polling optimization
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  parentApp          App?                @relation("AppForks", fields: [forkedFrom], references: [id])
  forks              App[]               @relation("AppForks")
  user               User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  monetizationModels MonetizationModel[]
  requirements       Requirement[]
  messages           AppMessage[] // Chat messages for this app
  statusHistory      AppStatusHistory[] // Status change history
  images             AppImage[] // Uploaded images for this app

  @@index([userId])
  @@index([forkedFrom])
  @@index([status])
  @@index([codespaceId])
  @@index([isCurated, isPublic])
  @@index([lastAgentActivity])
  @@index([slug])
  @@map("apps")
}

model Requirement {
  id          String              @id @default(cuid())
  appId       String
  description String
  priority    RequirementPriority @default(MEDIUM)
  status      RequirementStatus   @default(PENDING)
  version     Int                 @default(1)
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  app         App                 @relation(fields: [appId], references: [id], onDelete: Cascade)

  @@index([appId])
  @@index([status])
  @@index([priority])
  @@map("requirements")
}

model MonetizationModel {
  id                   String                @id @default(cuid())
  appId                String
  type                 MonetizationType      @default(FREE)
  price                Decimal?              @db.Decimal(10, 2)
  subscriptionInterval SubscriptionInterval?
  features             String[]
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  app                  App                   @relation(fields: [appId], references: [id], onDelete: Cascade)

  @@index([appId])
  @@index([type])
  @@map("monetization_models")
}

// =============================================================================
// App Chat & Status Models
// =============================================================================

// Chat message in an app's conversation thread
model AppMessage {
  id          String          @id @default(cuid())
  appId       String
  role        AppMessageRole // USER, AGENT, or SYSTEM
  content     String // Markdown-supported message content
  isRead      Boolean         @default(false) // For agent polling
  metadata    Json? // Additional message data (e.g., tool calls, errors)
  createdAt   DateTime        @default(now())
  app         App             @relation(fields: [appId], references: [id], onDelete: Cascade)
  attachments AppAttachment[] // Images attached to this message

  @@index([appId, createdAt])
  @@index([appId, isRead])
  @@index([role, isRead]) // For efficient agent polling queries
  @@map("app_messages")
}

// Status change history for audit trail
model AppStatusHistory {
  id        String         @id @default(cuid())
  appId     String
  status    AppBuildStatus
  message   String? // Optional context about the status change
  metadata  Json? // Additional data (e.g., error details for FAILED)
  createdAt DateTime       @default(now())
  app       App            @relation(fields: [appId], references: [id], onDelete: Cascade)

  @@index([appId, createdAt])
  @@map("app_status_history")
}

// Uploaded image for an app (with AI analysis)
model AppImage {
  id            String          @id @default(cuid())
  appId         String
  originalUrl   String // Public URL
  r2Key         String // R2 storage key
  width         Int
  height        Int
  sizeBytes     Int
  format        String          @default("webp")
  // AI Analysis results
  tags          String[] // AI-generated tags
  aiDescription String? // AI-generated description (max 1000 chars)
  analysisJson  Json? // Full analysis result from vision model
  createdAt     DateTime        @default(now())
  app           App             @relation(fields: [appId], references: [id], onDelete: Cascade)
  attachments   AppAttachment[] // Links to messages this image is attached to

  @@index([appId])
  @@index([appId, createdAt])
  @@map("app_images")
}

// Junction table for message-image attachments
model AppAttachment {
  id        String     @id @default(cuid())
  messageId String
  imageId   String
  createdAt DateTime   @default(now())
  message   AppMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  image     AppImage   @relation(fields: [imageId], references: [id], onDelete: Cascade)

  @@unique([messageId, imageId])
  @@index([messageId])
  @@index([imageId])
  @@map("app_attachments")
}

model UserTokenBalance {
  id               String           @id @default(cuid())
  userId           String           @unique
  balance          Int              @default(0)
  lastRegeneration DateTime         @default(now())
  tier             SubscriptionTier @default(FREE)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  user             User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tier])
  @@map("user_token_balances")
}

model TokenTransaction {
  id           String               @id @default(cuid())
  userId       String
  amount       Int
  type         TokenTransactionType
  source       String?
  sourceId     String?
  balanceAfter Int
  metadata     Json?
  createdAt    DateTime             @default(now())
  user         User                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([sourceId])
  @@map("token_transactions")
}

model TokensPackage {
  id             String          @id @default(cuid())
  name           String
  tokens         Int
  priceUSD       Decimal         @db.Decimal(10, 2)
  stripePriceId  String          @unique
  active         Boolean         @default(true)
  sortOrder      Int             @default(0)
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  stripePayments StripePayment[]

  @@index([active, sortOrder])
  @@map("tokens_packages")
}

model StripePayment {
  id                    String              @id @default(cuid())
  userId                String
  packageId             String
  tokensGranted         Int
  amountUSD             Decimal             @db.Decimal(10, 2)
  stripePaymentIntentId String              @unique
  status                StripePaymentStatus
  metadata              Json?
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt
  package               TokensPackage       @relation(fields: [packageId], references: [id])
  user                  User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([stripePaymentIntentId])
  @@map("stripe_payments")
}

model EnhancedImage {
  id                   String                @id @default(cuid())
  userId               String
  name                 String
  description          String?
  originalUrl          String
  originalR2Key        String
  originalWidth        Int
  originalHeight       Int
  originalSizeBytes    Int
  originalFormat       String
  isPublic             Boolean               @default(false)
  viewCount            Int                   @default(0)
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  shareToken           String?               @unique
  albumImages          AlbumImage[]
  user                 User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  enhancementJobs      ImageEnhancementJob[]
  blendTargetJobs      ImageEnhancementJob[] @relation("BlendSource")
  featuredGalleryItems FeaturedGalleryItem[]
  merchCartItems       MerchCartItem[]

  @@index([userId, createdAt])
  @@index([isPublic, createdAt])
  @@index([shareToken])
  @@map("enhanced_images")
}

model ImageEnhancementJob {
  id                    String          @id @default(cuid())
  imageId               String
  userId                String
  tier                  EnhancementTier
  tokensCost            Int
  status                JobStatus
  currentStage          PipelineStage? // Current pipeline stage for progress tracking
  enhancedUrl           String?
  enhancedR2Key         String?
  enhancedWidth         Int?
  enhancedHeight        Int?
  enhancedSizeBytes     Int?
  errorMessage          String?
  retryCount            Int             @default(0)
  maxRetries            Int             @default(3)
  geminiPrompt          String?
  geminiModel           String?
  geminiTemp            Float?
  processingStartedAt   DateTime?
  processingCompletedAt DateTime?
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt
  workflowRunId         String?
  // Analysis fields for dynamic prompt pipeline
  analysisResult        Json? // Stores full AnalysisDetailedResult JSON
  analysisSource        String? // Model used for analysis (e.g., "gemini-3-pro-image-preview")
  // Cropping fields for auto-crop feature
  wasCropped            Boolean         @default(false)
  cropDimensions        Json? // Stores { left, top, width, height } pixel values used

  // Pipeline reference for audit trail
  pipelineId String?
  pipeline   EnhancementPipeline? @relation(fields: [pipelineId], references: [id])

  // Blend enhancement - optional source image for image-to-image blending
  sourceImageId String?
  sourceImage   EnhancedImage? @relation("BlendSource", fields: [sourceImageId], references: [id], onDelete: SetNull)
  isBlend       Boolean        @default(false) // True when job uses blend enhancement (file upload or stored image)

  // Anonymous access - jobs created by non-logged-in users
  isAnonymous Boolean @default(false) // True when job was created by anonymous user

  image                EnhancedImage         @relation(fields: [imageId], references: [id], onDelete: Cascade)
  user                 User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  featuredGalleryItems FeaturedGalleryItem[]

  @@index([userId, status, createdAt])
  @@index([imageId])
  @@index([status, updatedAt])
  @@index([workflowRunId])
  @@index([pipelineId])
  @@index([status, currentStage]) // Optimize SSE stream queries filtering by status and stage
  @@map("image_enhancement_jobs")
}

model Subscription {
  id                   String             @id @default(cuid())
  userId               String             @unique
  stripeSubscriptionId String             @unique
  stripePriceId        String
  status               SubscriptionStatus
  tier                 SubscriptionTier   @default(BASIC)
  currentPeriodStart   DateTime
  currentPeriodEnd     DateTime
  cancelAtPeriodEnd    Boolean            @default(false)
  downgradeTo          SubscriptionTier?
  tokensPerMonth       Int
  rolloverTokens       Int                @default(0)
  maxRollover          Int                @default(0)
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([stripeSubscriptionId])
  @@index([status])
  @@index([tier])
  @@map("subscriptions")
}

model SubscriptionPlan {
  id             String   @id @default(cuid())
  name           String
  tokensPerMonth Int
  priceGBP       Decimal  @db.Decimal(10, 2)
  stripePriceId  String   @unique
  maxRollover    Int      @default(0)
  priority       Boolean  @default(false)
  apiAccess      Boolean  @default(false)
  active         Boolean  @default(true)
  sortOrder      Int      @default(0)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([active, sortOrder])
  @@map("subscription_plans")
}

model Album {
  id           String          @id @default(cuid())
  userId       String
  name         String
  description  String?
  coverImageId String?
  privacy      AlbumPrivacy    @default(PRIVATE)
  defaultTier  EnhancementTier @default(TIER_1K)
  shareToken   String?         @unique
  sortOrder    Int             @default(0)
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  // Pipeline reference (optional - falls back to system default)
  pipelineId String?
  pipeline   EnhancementPipeline? @relation(fields: [pipelineId], references: [id])

  albumImages AlbumImage[]
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, name, privacy]) // Prevent duplicate default albums per user
  @@index([userId, createdAt])
  @@index([privacy])
  @@index([shareToken])
  @@index([pipelineId])
  @@map("albums")
}

model AlbumImage {
  id        String        @id @default(cuid())
  albumId   String
  imageId   String
  sortOrder Int           @default(0)
  addedAt   DateTime      @default(now())
  album     Album         @relation(fields: [albumId], references: [id], onDelete: Cascade)
  image     EnhancedImage @relation(fields: [imageId], references: [id], onDelete: Cascade)

  @@unique([albumId, imageId])
  @@index([albumId, sortOrder])
  @@index([imageId])
  @@index([albumId, addedAt])
  @@map("album_images")
}

model Voucher {
  id          String              @id @default(cuid())
  code        String              @unique
  type        VoucherType
  value       Int
  maxUses     Int?
  currentUses Int                 @default(0)
  expiresAt   DateTime?
  status      VoucherStatus       @default(ACTIVE)
  metadata    Json?
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  redemptions VoucherRedemption[]

  @@index([code])
  @@index([status, expiresAt])
  @@map("vouchers")
}

model VoucherRedemption {
  id            String   @id @default(cuid())
  voucherId     String
  userId        String
  tokensGranted Int
  redeemedAt    DateTime @default(now())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  voucher       Voucher  @relation(fields: [voucherId], references: [id], onDelete: Cascade)

  @@unique([voucherId, userId])
  @@index([userId, redeemedAt])
  @@index([voucherId])
  @@map("voucher_redemptions")
}

model Referral {
  id            String         @id @default(cuid())
  referrerId    String
  refereeId     String
  status        ReferralStatus @default(PENDING)
  tokensGranted Int            @default(0)
  ipAddress     String?
  createdAt     DateTime       @default(now())
  completedAt   DateTime?
  referee       User           @relation("RefereeReferrals", fields: [refereeId], references: [id], onDelete: Cascade)
  referrer      User           @relation("ReferrerReferrals", fields: [referrerId], references: [id], onDelete: Cascade)

  @@unique([referrerId, refereeId])
  @@index([referrerId, status])
  @@index([refereeId])
  @@index([status, createdAt])
  @@map("referrals")
}

model AuditLog {
  id           String      @id @default(cuid())
  userId       String
  action       AuditAction
  targetId     String?
  targetType   String? // e.g., "user", "workspace", "draft", "content"
  resourceId   String? // Additional resource identifier
  resourceType String? // Type of the resource
  metadata     Json?
  ipAddress    String?
  userAgent    String?
  sessionId    String? // Session tracking for compliance
  createdAt    DateTime    @default(now())
  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([action])
  @@index([targetId])
  @@index([targetType])
  @@index([createdAt])
  @@index([resourceId, resourceType])
  @@map("audit_logs")
}

// Workspace-level audit logging for multi-tenant compliance
model WorkspaceAuditLog {
  id           String      @id @default(cuid())
  workspaceId  String
  userId       String
  action       AuditAction
  targetId     String? // ID of the affected resource
  targetType   String? // Type of target (draft, inbox, settings, etc.)
  resourceId   String? // Additional resource identifier
  resourceType String? // Type of the resource
  oldValue     Json? // Previous state for changes
  newValue     Json? // New state for changes
  metadata     Json? // Additional context (AI reasoning, etc.)
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime    @default(now())
  workspace    Workspace   @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  user         User        @relation("WorkspaceAuditLogs", fields: [userId], references: [id], onDelete: Cascade)

  @@index([workspaceId])
  @@index([userId])
  @@index([action])
  @@index([targetId, targetType])
  @@index([createdAt])
  @@index([workspaceId, createdAt])
  @@map("workspace_audit_logs")
}

// AI Decision logging for transparency and debugging
model AIDecisionLog {
  id             String     @id @default(cuid())
  workspaceId    String?
  userId         String?
  requestType    String // e.g., "draft_generation", "content_analysis", "recommendation"
  inputPrompt    String?    @db.Text
  inputContext   Json? // Additional input context
  outputResult   String?    @db.Text
  outputMetadata Json? // Model info, confidence scores, etc.
  modelId        String? // Which AI model was used
  modelVersion   String?
  tokensUsed     Int? // For cost tracking
  latencyMs      Int? // Response time
  status         String // success, error, timeout
  errorMessage   String?
  createdAt      DateTime   @default(now())
  workspace      Workspace? @relation(fields: [workspaceId], references: [id], onDelete: SetNull)
  user           User?      @relation("AIDecisionLogs", fields: [userId], references: [id], onDelete: SetNull)

  @@index([workspaceId])
  @@index([userId])
  @@index([requestType])
  @@index([status])
  @@index([createdAt])
  @@map("ai_decision_logs")
}

// Retention policy configuration for audit logs
model AuditRetentionPolicy {
  id               String     @id @default(cuid())
  workspaceId      String? // null for system-wide policy
  name             String
  description      String?
  retentionDays    Int        @default(365) // How long to keep logs
  archiveAfterDays Int? // Move to archive storage after X days
  deleteAfterDays  Int? // Hard delete after X days (if different from retention)
  actionTypes      String[] // Which action types this applies to, empty = all
  isActive         Boolean    @default(true)
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt
  workspace        Workspace? @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, name])
  @@index([workspaceId])
  @@index([isActive])
  @@map("audit_retention_policies")
}

// Archived audit logs for compliance storage
model ArchivedAuditLog {
  id                String   @id @default(cuid())
  originalId        String // Original audit log ID
  workspaceId       String?
  userId            String
  action            String // Stored as string for flexibility after enum changes
  targetId          String?
  targetType        String?
  resourceId        String?
  resourceType      String?
  metadata          Json?
  ipAddress         String?
  userAgent         String?
  originalCreatedAt DateTime // Original creation timestamp
  archivedAt        DateTime @default(now())
  retentionPolicyId String?
  archiveReason     String? // "scheduled", "manual", "compliance"

  @@index([workspaceId])
  @@index([userId])
  @@index([action])
  @@index([originalCreatedAt])
  @@index([archivedAt])
  @@map("archived_audit_logs")
}

// Error logging for tryCatch blocks across frontend and backend
model ErrorLog {
  id           String           @id @default(cuid())
  timestamp    DateTime         @default(now())
  message      String
  stack        String?
  sourceFile   String?
  sourceLine   Int?
  sourceColumn Int?
  callerName   String?
  userId       String?
  route        String?
  environment  ErrorEnvironment
  errorType    String?
  errorCode    String?
  metadata     Json?

  @@index([timestamp])
  @@index([sourceFile])
  @@index([errorType])
  @@index([environment])
  @@map("error_logs")
}

model Feedback {
  id        String         @id @default(cuid())
  userId    String?
  email     String?
  type      FeedbackType
  message   String
  page      String
  userAgent String?
  status    FeedbackStatus @default(NEW)
  adminNote String?
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([status])
  @@index([type])
  @@index([createdAt])
  @@map("feedback")
}

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

enum MarketingPlatform {
  FACEBOOK
  GOOGLE_ADS
}

// Legacy status - kept for migration compatibility
enum AppStatus {
  DRAFT
  ACTIVE
  ARCHIVED
  DELETED
}

// New detailed build status for agent-driven app development
enum AppBuildStatus {
  PROMPTING // User providing initial prompt
  WAITING // Waiting for agent to pick up
  DRAFTING // Agent drafting initial version
  BUILDING // Agent implementing features
  FINE_TUNING // Agent making refinements
  TEST // Agent testing with Playwright
  LIVE // Published and active
  ARCHIVED // User archived
  FAILED // Build failed
}

// Message role in app chat
enum AppMessageRole {
  USER // Message from user
  AGENT // Message from AI agent
  SYSTEM // System notification (status changes, etc.)
}

enum RequirementPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum RequirementStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  REJECTED
}

enum MonetizationType {
  FREE
  ONE_TIME
  SUBSCRIPTION
  FREEMIUM
  USAGE_BASED
}

enum SubscriptionInterval {
  MONTHLY
  QUARTERLY
  YEARLY
}

enum VoucherType {
  FIXED_TOKENS
  PERCENTAGE_BONUS
  SUBSCRIPTION_TRIAL
}

enum VoucherStatus {
  ACTIVE
  INACTIVE
  EXPIRED
  DEPLETED
}

enum TokenTransactionType {
  EARN_REGENERATION
  EARN_PURCHASE
  EARN_BONUS
  EARN_ADMIN_ADJUSTMENT
  SPEND_ENHANCEMENT
  SPEND_MCP_GENERATION
  SPEND_BOX_CREATION
  SPEND_APP_MESSAGE // Cost for sending a message in app chat
  REFUND
}

enum McpJobType {
  GENERATE
  MODIFY
}

enum StripePaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  REFUNDED
}

enum EnhancementTier {
  FREE
  TIER_1K
  TIER_2K
  TIER_4K
}

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
}

enum PipelineStage {
  ANALYZING // Image analysis with vision model
  CROPPING // Auto-crop based on analysis
  PROMPTING // Build dynamic enhancement prompt
  GENERATING // Gemini API image generation
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  UNPAID
  TRIALING
}

enum SubscriptionTier {
  FREE
  BASIC
  STANDARD
  PREMIUM
}

enum AlbumPrivacy {
  PRIVATE
  UNLISTED
  PUBLIC
}

enum ReferralStatus {
  PENDING
  COMPLETED
  INVALID
}

enum AuditAction {
  // Admin actions
  ROLE_CHANGE
  TOKEN_ADJUSTMENT
  VOUCHER_CREATE
  VOUCHER_UPDATE
  VOUCHER_DELETE
  USER_DELETE
  ADMIN_LOGIN

  // Session actions
  USER_LOGIN
  USER_LOGOUT
  SESSION_REFRESH

  // Workspace actions
  WORKSPACE_CREATE
  WORKSPACE_UPDATE
  WORKSPACE_DELETE
  WORKSPACE_MEMBER_ADD
  WORKSPACE_MEMBER_REMOVE
  WORKSPACE_SETTINGS_CHANGE

  // Content actions
  CONTENT_CREATE
  CONTENT_UPDATE
  CONTENT_DELETE
  CONTENT_PUBLISH
  CONTENT_UNPUBLISH
  CONTENT_SCHEDULE

  // AI actions
  AI_GENERATION_REQUEST
  AI_GENERATION_COMPLETE
  AI_APPROVAL
  AI_REJECTION
  AI_FEEDBACK

  // Integration actions
  INTEGRATION_CONNECT
  INTEGRATION_DISCONNECT
  INTEGRATION_SYNC

  // Export/Import
  DATA_EXPORT
  DATA_IMPORT

  // Relay actions
  RELAY_DRAFT_CREATE
  RELAY_DRAFT_APPROVE
  RELAY_DRAFT_REJECT
  RELAY_DRAFT_EDIT
  RELAY_DRAFT_SEND
}

enum FeedbackType {
  BUG
  IDEA
  OTHER
}

enum FeedbackStatus {
  NEW
  REVIEWED
  RESOLVED
  DISMISSED
}

enum ErrorEnvironment {
  FRONTEND
  BACKEND
}

enum GalleryCategory {
  PORTRAIT
  LANDSCAPE
  PRODUCT
  ARCHITECTURE
}

enum EmailStatus {
  PENDING
  SENT
  DELIVERED
  OPENED
  CLICKED
  BOUNCED
  FAILED
}

enum BoxStatus {
  CREATING
  STARTING
  RUNNING
  PAUSED
  STOPPING
  STOPPED
  TERMINATED
  ERROR
}

enum BoxActionType {
  CREATE
  START
  STOP
  RESTART
  DELETE
  CLONE
}

model FeaturedGalleryItem {
  id            String          @id @default(cuid())
  title         String
  description   String?
  category      GalleryCategory @default(PORTRAIT)
  originalUrl   String
  enhancedUrl   String
  width         Int             @default(16)
  height        Int             @default(9)
  sourceImageId String?
  sourceJobId   String?
  sortOrder     Int             @default(0)
  isActive      Boolean         @default(true)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  createdBy     String

  sourceImage EnhancedImage?       @relation(fields: [sourceImageId], references: [id], onDelete: SetNull)
  sourceJob   ImageEnhancementJob? @relation(fields: [sourceJobId], references: [id], onDelete: SetNull)
  creator     User                 @relation("GalleryItemCreator", fields: [createdBy], references: [id])

  @@index([isActive, sortOrder])
  @@index([isActive, category, sortOrder])
  @@map("featured_gallery_items")
}

// Browser Agent Service Models

model BoxTier {
  id            String   @id @default(cuid())
  name          String // e.g. "Standard", "Pro", "Ultra"
  description   String?
  cpu           Int // vCPU count
  ram           Int // RAM in MB
  storage       Int // Storage in GB
  pricePerHour  Int // Token cost per hour
  pricePerMonth Int // Token cost per month (if subscription)
  isActive      Boolean  @default(true)
  sortOrder     Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  boxes         Box[]

  @@map("box_tiers")
}

model Box {
  id              String    @id @default(cuid())
  name            String
  description     String?
  userId          String
  tierId          String?
  status          BoxStatus @default(STOPPED)
  connectionUrl   String? // URL to access the VNC/NoVNC interface
  storageVolumeId String? // ID of the persistent storage volume (R2/S3)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  deletedAt       DateTime?

  user     User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  tier     BoxTier?     @relation(fields: [tierId], references: [id])
  actions  BoxAction[]
  tasks    AgentTask[]
  messages BoxMessage[]

  @@index([userId, createdAt])
  @@index([status])
  @@map("boxes")
}

model BoxAction {
  id        String        @id @default(cuid())
  boxId     String
  action    BoxActionType
  status    JobStatus     @default(PENDING)
  metadata  Json?
  error     String?
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  box Box @relation(fields: [boxId], references: [id], onDelete: Cascade)

  @@index([boxId, createdAt])
  @@map("box_actions")
}

model AgentTask {
  id        String    @id @default(cuid())
  boxId     String
  type      String // e.g. "NAVIGATE", "CLICK", "TYPE"
  payload   Json? // e.g. { url: "https://google.com" }
  status    JobStatus @default(PENDING)
  result    Json?
  error     String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  box Box @relation(fields: [boxId], references: [id], onDelete: Cascade)

  @@index([boxId, status])
  @@map("agent_tasks")
}

model EmailLog {
  id        String      @id @default(cuid())
  userId    String
  to        String
  subject   String
  template  String
  status    EmailStatus @default(SENT)
  resendId  String?     @unique
  sentAt    DateTime    @default(now())
  openedAt  DateTime?
  clickedAt DateTime?
  bouncedAt DateTime?
  metadata  Json?
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([sentAt])
  @@index([template])
  @@map("email_logs")
}

model TrackedUrl {
  id          String   @id @default(cuid())
  path        String   @unique // Store path only (e.g., "/custom-page"), not full URL
  label       String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String
  createdBy   User     @relation(fields: [createdById], references: [id], onDelete: Cascade)

  @@index([isActive])
  @@map("tracked_urls")
}

// MCP Asset Generator Models

model ApiKey {
  id                String             @id @default(cuid())
  userId            String
  name              String
  keyHash           String             @unique
  keyPrefix         String
  lastUsedAt        DateTime?
  isActive          Boolean            @default(true)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  mcpGenerationJobs McpGenerationJob[]

  @@index([userId, isActive])
  @@index([keyHash])
  @@map("api_keys")
}

model McpGenerationJob {
  id                    String          @id @default(cuid())
  userId                String
  apiKeyId              String?
  type                  McpJobType
  tier                  EnhancementTier
  tokensCost            Int
  status                JobStatus
  prompt                String
  inputImageUrl         String?
  inputImageR2Key       String?
  outputImageUrl        String?
  outputImageR2Key      String?
  outputWidth           Int?
  outputHeight          Int?
  outputSizeBytes       Int?
  errorMessage          String?
  geminiModel           String?
  processingStartedAt   DateTime?
  processingCompletedAt DateTime?
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt

  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  apiKey ApiKey? @relation(fields: [apiKeyId], references: [id], onDelete: SetNull)

  @@index([userId, status, createdAt])
  @@index([apiKeyId])
  @@index([status, updatedAt])
  @@map("mcp_generation_jobs")
}

model BoxMessage {
  id        String         @id @default(cuid())
  boxId     String
  role      BoxMessageRole
  content   String
  createdAt DateTime       @default(now())
  box       Box            @relation(fields: [boxId], references: [id], onDelete: Cascade)

  @@index([boxId, createdAt])
  @@map("box_messages")
}

enum BoxMessageRole {
  USER
  AGENT
  SYSTEM
}

enum PipelineVisibility {
  PRIVATE // Only owner can use
  PUBLIC // Anyone can use/fork
  LINK // Accessible via shareToken
}

// Pipeline Configuration System
// Stores reusable AI enhancement pipeline configurations

model EnhancementPipeline {
  id          String  @id @default(cuid())
  name        String
  description String?

  // Ownership (null = system default)
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Sharing
  visibility PipelineVisibility @default(PRIVATE)
  shareToken String?            @unique // For link-based sharing

  // Pipeline Configuration (includes tier)
  tier EnhancementTier @default(TIER_1K)

  // Stage Configs (JSON)
  analysisConfig   Json? // Analysis stage settings
  autoCropConfig   Json? // Auto-crop behavior
  promptConfig     Json? // Dynamic prompt generation
  generationConfig Json? // Gemini generation settings

  // Usage tracking
  usageCount Int @default(0)

  // Relations
  albums Album[]
  jobs   ImageEnhancementJob[]

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([visibility])
  @@map("enhancement_pipelines")
}

// =============================================================================
// Campaign Analytics Models
// =============================================================================

// Visitor session tracking with UTM parameters for campaign attribution
model VisitorSession {
  id           String    @id @default(cuid())
  visitorId    String // Anonymous fingerprint/cookie ID
  userId       String? // Linked user ID after signup/login
  sessionStart DateTime  @default(now())
  sessionEnd   DateTime?

  // Device & Browser info
  deviceType String? // mobile, tablet, desktop
  browser    String?
  os         String?

  // Geo info (anonymized)
  ipCountry String? // ISO 2-letter country code
  ipCity    String?

  // Traffic source
  referrer      String? // Full referrer URL
  landingPage   String // First page of session
  exitPage      String? // Last page of session
  pageViewCount Int     @default(0)

  // UTM parameters for campaign attribution
  utmSource   String?
  utmMedium   String?
  utmCampaign String?
  utmTerm     String?
  utmContent  String?

  // Platform click IDs for direct attribution
  gclid  String? // Google Click ID
  fbclid String? // Facebook Click ID

  // Relations
  user      User?            @relation(fields: [userId], references: [id], onDelete: SetNull)
  pageViews PageView[]
  events    AnalyticsEvent[]

  @@index([visitorId])
  @@index([userId])
  @@index([utmCampaign])
  @@index([utmSource])
  @@index([sessionStart])
  @@index([gclid])
  @@index([fbclid])
  @@map("visitor_sessions")
}

// Individual page view tracking
model PageView {
  id          String   @id @default(cuid())
  sessionId   String
  path        String
  title       String?
  timestamp   DateTime @default(now())
  timeOnPage  Int? // Seconds spent on page
  scrollDepth Int? // Percentage scrolled (0-100)

  session VisitorSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId, timestamp])
  @@index([path])
  @@map("page_views")
}

// Custom event tracking for user behavior
model AnalyticsEvent {
  id        String   @id @default(cuid())
  sessionId String
  name      String // e.g., "signup_started", "enhancement_completed"
  category  String? // e.g., "conversion", "engagement"
  value     Float? // Numeric value (e.g., token amount, revenue)
  metadata  Json? // Additional event data
  timestamp DateTime @default(now())

  session VisitorSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId, timestamp])
  @@index([name])
  @@index([category])
  @@map("analytics_events")
}

// Campaign attribution linking users to campaigns
model CampaignAttribution {
  id        String @id @default(cuid())
  userId    String
  sessionId String

  // Attribution model
  attributionType AttributionType

  // Campaign identifiers
  platform           String? // "FACEBOOK", "GOOGLE_ADS", "ORGANIC", "DIRECT", etc.
  externalCampaignId String? // Campaign ID from FB/Google for ROI matching
  utmCampaign        String?
  utmSource          String?
  utmMedium          String?

  // Conversion data
  conversionType  ConversionType
  conversionValue Float? // Token/revenue value
  convertedAt     DateTime       @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([utmCampaign])
  @@index([externalCampaignId])
  @@index([convertedAt])
  @@index([conversionType])
  @@index([attributionType])
  @@map("campaign_attributions")
}

// Cached campaign metrics for dashboard performance
model CampaignMetricsCache {
  id         String   @id @default(cuid())
  cacheKey   String   @unique // e.g., "overview:2024-01-01:2024-01-31:first_touch"
  metrics    Json // Cached metrics data
  computedAt DateTime @default(now())
  expiresAt  DateTime

  @@index([cacheKey])
  @@index([expiresAt])
  @@map("campaign_metrics_cache")
}

// Campaign link for connecting UTM campaigns to external platform campaign IDs
model CampaignLink {
  id                   String   @id @default(cuid())
  utmCampaign          String
  platform             String // "FACEBOOK" | "GOOGLE_ADS"
  externalCampaignId   String
  externalCampaignName String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  @@unique([utmCampaign, platform])
  @@index([platform])
  @@index([externalCampaignId])
  @@map("campaign_links")
}

// =============================================================================
// Audio Mixer Models
// =============================================================================

model AudioMixerProject {
  id          String       @id @default(cuid())
  userId      String
  name        String
  description String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  tracks      AudioTrack[]

  @@index([userId, createdAt])
  @@map("audio_mixer_projects")
}

model AudioTrack {
  id            String            @id @default(cuid())
  projectId     String
  name          String
  fileUrl       String? // R2 public URL
  fileR2Key     String? // R2 key for server operations
  fileFormat    String // wav, mp3, webm, etc.
  duration      Float // seconds
  fileSizeBytes Int
  volume        Float             @default(1.0)
  muted         Boolean           @default(false)
  solo          Boolean           @default(false)
  sortOrder     Int               @default(0)
  storageType   AudioStorageType  @default(R2)
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  project       AudioMixerProject @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId, sortOrder])
  @@map("audio_tracks")
}

enum AudioStorageType {
  R2
  OPFS
}

// Enums for Campaign Analytics
enum AttributionType {
  FIRST_TOUCH
  LAST_TOUCH
}

enum ConversionType {
  SIGNUP
  ENHANCEMENT
  PURCHASE
}

// =============================================================================
// Merch / Print-on-Demand Models
// =============================================================================

enum PodProvider {
  PRODIGI
  PRINTFUL
}

enum MerchOrderStatus {
  PENDING // Created, awaiting payment
  PAYMENT_PENDING // Payment authorized, awaiting capture
  PAID // Payment captured
  SUBMITTED // Sent to POD provider
  IN_PRODUCTION // Being manufactured
  SHIPPED // In transit
  DELIVERED // Delivered
  CANCELLED // Cancelled
  REFUNDED // Fully refunded
}

enum ShipmentStatus {
  PENDING
  PROCESSING
  SHIPPED
  IN_TRANSIT
  OUT_FOR_DELIVERY
  DELIVERED
  FAILED
}

// Product Catalog
model MerchCategory {
  id          String         @id @default(cuid())
  name        String         @unique
  slug        String         @unique
  description String?
  icon        String?
  sortOrder   Int            @default(0)
  isActive    Boolean        @default(true)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  products    MerchProduct[]

  @@index([isActive, sortOrder])
  @@map("merch_categories")
}

model MerchProduct {
  id              String      @id @default(cuid())
  name            String
  description     String?
  categoryId      String
  provider        PodProvider
  providerSku     String // External SKU from POD provider
  basePrice       Decimal     @db.Decimal(10, 2) // Cost from provider
  retailPrice     Decimal     @db.Decimal(10, 2) // Selling price
  currency        String      @default("GBP")
  isActive        Boolean     @default(true)
  minDpi          Int         @default(150)
  minWidth        Int         @default(1800)
  minHeight       Int         @default(1800)
  printAreaWidth  Int? // Print area in pixels
  printAreaHeight Int?
  mockupTemplate  String? // URL to mockup overlay image
  sortOrder       Int         @default(0)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  category   MerchCategory    @relation(fields: [categoryId], references: [id])
  variants   MerchVariant[]
  cartItems  MerchCartItem[]
  orderItems MerchOrderItem[]

  @@index([categoryId, isActive])
  @@index([provider, providerSku])
  @@index([isActive, sortOrder])
  @@map("merch_products")
}

model MerchVariant {
  id          String   @id @default(cuid())
  productId   String
  name        String // "30x40cm", "Large", "Black", etc.
  providerSku String // Provider-specific SKU for this variant
  priceDelta  Decimal  @default(0) @db.Decimal(10, 2) // Price adjustment from base
  isActive    Boolean  @default(true)
  attributes  Json? // { size: "30x40", color: "black" }
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  product    MerchProduct     @relation(fields: [productId], references: [id], onDelete: Cascade)
  cartItems  MerchCartItem[]
  orderItems MerchOrderItem[]

  @@index([productId, isActive])
  @@map("merch_variants")
}

// Shopping Cart
model MerchCart {
  id        String   @id @default(cuid())
  userId    String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user  User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  items MerchCartItem[]

  @@map("merch_carts")
}

model MerchCartItem {
  id                 String   @id @default(cuid())
  cartId             String
  productId          String
  variantId          String?
  // Image source: ONE of these must be set
  imageId            String? // EnhancedImage reference (if using existing)
  uploadedImageR2Key String? // R2 key (if direct upload)
  uploadedImageUrl   String? // Public URL for direct uploads
  quantity           Int      @default(1)
  customText         String? // Optional personalization text
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  cart    MerchCart      @relation(fields: [cartId], references: [id], onDelete: Cascade)
  product MerchProduct   @relation(fields: [productId], references: [id])
  variant MerchVariant?  @relation(fields: [variantId], references: [id])
  image   EnhancedImage? @relation(fields: [imageId], references: [id])

  @@unique([cartId, productId, variantId, imageId, uploadedImageR2Key])
  @@index([cartId])
  @@index([productId])
  @@map("merch_cart_items")
}

// Orders
model MerchOrder {
  id                    String           @id @default(cuid())
  userId                String
  orderNumber           String           @unique // Human-readable order number
  status                MerchOrderStatus @default(PENDING)
  subtotal              Decimal          @db.Decimal(10, 2)
  shippingCost          Decimal          @db.Decimal(10, 2)
  taxAmount             Decimal          @default(0) @db.Decimal(10, 2)
  totalAmount           Decimal          @db.Decimal(10, 2)
  currency              String           @default("GBP")
  stripePaymentIntentId String?          @unique
  stripePaymentStatus   String? // authorized, captured, cancelled
  shippingAddress       Json // { name, line1, line2, city, postalCode, country }
  billingAddress        Json?
  customerEmail         String
  customerPhone         String?
  notes                 String?
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @updatedAt
  paidAt                DateTime?

  user      User              @relation(fields: [userId], references: [id])
  items     MerchOrderItem[]
  shipments MerchShipment[]
  events    MerchOrderEvent[]

  @@index([userId, createdAt])
  @@index([status])
  @@index([orderNumber])
  @@index([stripePaymentIntentId])
  @@map("merch_orders")
}

model MerchOrderItem {
  id          String   @id @default(cuid())
  orderId     String
  productId   String
  variantId   String?
  productName String // Snapshot at order time
  variantName String?
  imageUrl    String // Snapshot of image URL for display
  imageR2Key  String // R2 key for reprints and POD submission
  quantity    Int
  unitPrice   Decimal  @db.Decimal(10, 2)
  totalPrice  Decimal  @db.Decimal(10, 2)
  customText  String?
  podOrderId  String? // Provider order ID
  podStatus   String? // Provider-specific status
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  order      MerchOrder     @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product    MerchProduct   @relation(fields: [productId], references: [id])
  variant    MerchVariant?  @relation(fields: [variantId], references: [id])
  shipment   MerchShipment? @relation(fields: [shipmentId], references: [id])
  shipmentId String?

  @@index([orderId])
  @@index([podOrderId])
  @@map("merch_order_items")
}

model MerchShipment {
  id             String         @id @default(cuid())
  orderId        String
  provider       PodProvider
  providerShipId String? // Shipment ID from provider
  carrier        String? // FedEx, UPS, Royal Mail, etc.
  trackingNumber String?
  trackingUrl    String?
  status         ShipmentStatus @default(PENDING)
  shippedAt      DateTime?
  deliveredAt    DateTime?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  order MerchOrder       @relation(fields: [orderId], references: [id], onDelete: Cascade)
  items MerchOrderItem[]

  @@index([orderId])
  @@index([trackingNumber])
  @@map("merch_shipments")
}

model MerchOrderEvent {
  id        String   @id @default(cuid())
  orderId   String
  type      String // ORDER_CREATED, PAYMENT_AUTHORIZED, PAYMENT_CAPTURED, SUBMITTED_TO_POD, etc.
  data      Json? // Event-specific data
  createdAt DateTime @default(now())

  order MerchOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId, createdAt])
  @@map("merch_order_events")
}

// Webhook event deduplication
model MerchWebhookEvent {
  id          String    @id @default(cuid())
  provider    String // STRIPE, PRODIGI, PRINTFUL
  eventId     String    @unique // External event ID for deduplication
  eventType   String
  processed   Boolean   @default(false)
  payload     Json
  processedAt DateTime?
  createdAt   DateTime  @default(now())

  @@index([provider, eventType])
  @@index([processed, createdAt])
  @@map("merch_webhook_events")
}

// =============================================================================
// External Agent Session Models (Jules, Codex, etc.)
// =============================================================================

// External Agent Session tracking (Jules, etc.)
model ExternalAgentSession {
  id             String              @id @default(cuid())
  externalId     String              @unique // e.g., "sessions/abc123" from Jules
  provider       AgentProvider       @default(JULES)
  name           String // Task name/title
  description    String? // Task description
  status         ExternalAgentStatus
  sourceRepo     String? // e.g., "sources/github/zerdos/spike-land-nextjs"
  startingBranch String? // e.g., "main"
  outputBranch   String? // Branch created by agent
  pullRequestUrl String? // PR URL if created
  planSummary    String? // Summary of agent's plan
  planApprovedAt DateTime?
  lastActivityAt DateTime?
  errorMessage   String?
  metadata       Json? // Additional provider-specific data
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt

  activities AgentSessionActivity[]

  @@index([provider, status])
  @@index([status, lastActivityAt])
  @@map("external_agent_sessions")
}

model AgentSessionActivity {
  id         String   @id @default(cuid())
  sessionId  String
  externalId String? // Activity ID from provider
  type       String // e.g., "user_message", "plan_generated", "code_committed"
  content    String? // Activity content/description
  metadata   Json?
  createdAt  DateTime @default(now())

  session ExternalAgentSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId, createdAt])
  @@map("agent_session_activities")
}

// =============================================================================
// Social Media Tracking Models
// =============================================================================

/// Scout Competitor - Tracks competitor social media accounts for benchmarking.
/// Stores basic information about competitors that a workspace is monitoring.
/// Related to ScoutCompetitorPost for historical post data and ScoutBenchmark for performance comparisons.
model ScoutCompetitor {
  id          String         @id @default(cuid())
  workspaceId String
  workspace   Workspace      @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  platform    SocialPlatform
  handle      String // Username or handle on the social platform
  name        String? // Display name of the competitor account
  isActive    Boolean        @default(true) // Whether to actively sync posts for this competitor
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  posts ScoutCompetitorPost[]

  @@unique([workspaceId, platform, handle])
  @@index([workspaceId])
  @@map("scout_competitors")
}

/// Scout Competitor Post - Historical posts from tracked competitor accounts.
/// Stores social media posts with engagement metrics for competitor analysis.
/// Posts are synced periodically and used for engagement benchmarking.
model ScoutCompetitorPost {
  id             String          @id @default(cuid())
  competitorId   String
  competitor     ScoutCompetitor @relation(fields: [competitorId], references: [id], onDelete: Cascade)
  platformPostId String // Unique ID from the social platform
  content        String          @db.Text // Post content/text
  postedAt       DateTime // When the post was published on the platform
  likes          Int             @default(0) // Number of likes/favorites
  comments       Int             @default(0) // Number of comments/replies
  shares         Int             @default(0) // Number of shares/retweets
  metadata       Json? // Additional platform-specific data
  createdAt      DateTime        @default(now())

  @@unique([competitorId, platformPostId])
  @@index([competitorId])
  @@index([postedAt])
  @@map("scout_competitor_posts")
}

/// Scout Benchmark - Performance comparison reports between workspace and competitors.
/// Stores aggregated metrics comparing a workspace's social performance against tracked competitors.
/// Generated periodically (e.g., weekly/monthly) for trend analysis.
model ScoutBenchmark {
  id                String    @id @default(cuid())
  workspaceId       String
  workspace         Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  period            String // Time period identifier, e.g., "2024-W32" for week 32 or "2024-08" for August
  ownMetrics        Json // Workspace's own engagement metrics (averageLikes, averageComments, etc.)
  competitorMetrics Json // Aggregated competitor engagement metrics
  generatedAt       DateTime  @default(now())

  @@unique([workspaceId, period])
  @@index([workspaceId])
  @@map("scout_benchmarks")
}

model SocialAccount {
  id                    String              @id @default(cuid())
  platform              SocialPlatform
  accountId             String // Platform-specific account ID
  accountName           String
  accessTokenEncrypted  String              @db.Text
  refreshTokenEncrypted String?             @db.Text
  tokenExpiresAt        DateTime?
  connectedAt           DateTime            @default(now())
  status                SocialAccountStatus @default(ACTIVE)
  metadata              Json?

  // User ownership (kept for audit trail - who connected the account)
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Workspace ownership (primary relationship for Orbit)
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  metrics               SocialMetrics[]
  postAccounts          SocialPostAccount[]
  anomalies             SocialMetricAnomaly[]
  scheduledPostAccounts ScheduledPostAccount[]
  inboxItems            InboxItem[]
  // Account health monitoring
  health                SocialAccountHealth?
  healthEvents          AccountHealthEvent[]

  @@unique([workspaceId, platform, accountId])
  @@index([userId])
  @@index([workspaceId])
  @@index([status])
  @@map("social_accounts")
}

model SocialPost {
  id          String           @id @default(cuid())
  content     String           @db.Text
  scheduledAt DateTime?
  publishedAt DateTime?
  status      SocialPostStatus @default(DRAFT)
  metadata    Json?

  // User ownership
  createdById String
  createdBy   User   @relation(fields: [createdById], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations (many-to-many with accounts via join table)
  postAccounts SocialPostAccount[]

  @@index([createdById])
  @@index([createdById, createdAt])
  @@index([status])
  @@map("social_posts")
}

model SocialPostAccount {
  id        String        @id @default(cuid())
  postId    String
  post      SocialPost    @relation(fields: [postId], references: [id], onDelete: Cascade)
  accountId String
  account   SocialAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  // Platform-specific post ID after publishing
  platformPostId String?
  publishedAt    DateTime?
  status         SocialPostStatus @default(DRAFT)
  errorMessage   String?

  @@unique([postId, accountId])
  @@index([postId])
  @@index([accountId])
  @@map("social_post_accounts")
}

model SocialMetrics {
  id             String        @id @default(cuid())
  accountId      String
  account        SocialAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  date           DateTime      @db.Date
  followers      Int           @default(0)
  following      Int           @default(0)
  postsCount     Int           @default(0)
  engagementRate Decimal?      @db.Decimal(5, 4)
  impressions    Int           @default(0)
  reach          Int           @default(0)
  likes          Int           @default(0)
  comments       Int           @default(0)
  shares         Int           @default(0)
  rawData        Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([accountId, date])
  @@index([accountId])
  @@index([date])
  @@map("social_metrics")
}

/// Detected anomalies in social media metrics
/// Used by Pulse AI Agent for alerting
/// Resolves #647
model SocialMetricAnomaly {
  id            String        @id @default(cuid())
  accountId     String
  account       SocialAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  metricType    String // followers, engagement_rate, impressions, etc.
  detectedAt    DateTime      @default(now())
  currentValue  Float
  expectedValue Float
  zScore        Float
  severity      String // warning, critical
  direction     String // spike, drop
  percentChange Float

  createdAt DateTime @default(now())

  @@index([accountId])
  @@index([detectedAt])
  @@index([severity])
  @@map("social_metric_anomalies")
}

enum AgentProvider {
  JULES
  CODEX
  OTHER
}

enum ExternalAgentStatus {
  QUEUED
  PLANNING
  AWAITING_PLAN_APPROVAL
  AWAITING_USER_FEEDBACK
  IN_PROGRESS
  PAUSED
  FAILED
  COMPLETED
}

// =============================================================================
// Social Media Tracking Enums
// =============================================================================

enum SocialPlatform {
  TWITTER
  LINKEDIN
  FACEBOOK
  INSTAGRAM
  TIKTOK
  YOUTUBE
  DISCORD
}

enum SocialAccountStatus {
  ACTIVE // Working normally
  EXPIRED // Token expired, needs refresh
  ERROR // Last operation failed
  RATE_LIMITED // Currently rate limited by platform
  RESTRICTED // Platform restrictions applied
  SUSPENDED // Account suspended by platform
  DISCONNECTED // Manually disconnected by user
}

enum SocialPostStatus {
  DRAFT
  SCHEDULED
  PUBLISHED
  FAILED
}

// Brand Brain Content Rewriter Enums
enum RewriteStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum ContentPlatform {
  TWITTER // 280 chars
  LINKEDIN // 3000 chars
  INSTAGRAM // 2200 chars
  FACEBOOK // 63206 chars
  GENERAL // 50000 chars
}

// =============================================================================
// Workspace Models (Multi-tenant for Orbit)
// =============================================================================

enum WorkspaceRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

// Brand Brain Enums
enum GuardrailType {
  PROHIBITED_TOPIC
  REQUIRED_DISCLOSURE
  CONTENT_WARNING
}

enum GuardrailSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum VocabularyType {
  PREFERRED
  BANNED
  REPLACEMENT
}

model Workspace {
  id          String    @id @default(cuid())
  name        String
  slug        String    @unique
  description String?
  avatarUrl   String?
  settings    Json?
  isPersonal  Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  members                WorkspaceMember[]
  brandProfile           BrandProfile?
  contentRewrites        ContentRewrite[]
  socialAccounts         SocialAccount[]
  scheduledPosts         ScheduledPost[]
  inboxItems             InboxItem[]
  // Comprehensive audit logs
  workspaceAuditLogs     WorkspaceAuditLog[]
  aiDecisionLogs         AIDecisionLog[]
  auditRetentionPolicies AuditRetentionPolicy[]
  // Crisis detection relations
  crisisEvents           CrisisDetectionEvent[]
  crisisTemplates        CrisisResponseTemplate[]
  crisisAlertRules       CrisisAlertRule[]
  // Account health monitoring
  accountHealthEvents    AccountHealthEvent[]
  // Policy Checker relations
  policyRules            PolicyRule[]
  policyChecks           PolicyCheck[]
  policyViolations       PolicyViolation[]

  // Scout Competitor Tracking
  scoutCompetitors ScoutCompetitor[]
  scoutBenchmarks  ScoutBenchmark[]
  // Scout content suggestions
  contentSuggestions    ContentSuggestion[]

  // Allocator models
  allocatorCampaigns    AllocatorCampaign[]

  @@index([slug])
  @@index([isPersonal])
  @@map("workspaces")
}

model WorkspaceMember {
  id          String        @id @default(cuid())
  workspaceId String
  userId      String
  role        WorkspaceRole @default(MEMBER)
  invitedAt   DateTime      @default(now())
  joinedAt    DateTime?
  invitedById String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  invitedBy User?     @relation("WorkspaceInvitations", fields: [invitedById], references: [id], onDelete: SetNull)

  // Inbox items assigned to this team member
  assignedInboxItems InboxItem[]

  @@unique([workspaceId, userId])
  @@index([workspaceId])
  @@index([userId])
  @@index([role])
  @@map("workspace_members")
}

// =============================================================================
// Brand Brain Models (AI Content Guardian)
// =============================================================================

model BrandProfile {
  id              String   @id @default(cuid())
  workspaceId     String   @unique
  name            String
  mission         String?  @db.Text
  values          Json?
  toneDescriptors Json?
  logoUrl         String?
  logoR2Key       String?
  colorPalette    Json?
  version         Int      @default(1)
  isActive        Boolean  @default(true)
  createdById     String
  updatedById     String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  workspace       Workspace         @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  createdBy       User              @relation("BrandProfileCreator", fields: [createdById], references: [id], onDelete: Restrict)
  updatedBy       User?             @relation("BrandProfileUpdater", fields: [updatedById], references: [id], onDelete: SetNull)
  guardrails      BrandGuardrail[]
  vocabulary      BrandVocabulary[]
  contentRewrites ContentRewrite[]

  @@index([workspaceId])
  @@index([isActive])
  @@index([createdById])
  @@map("brand_profiles")
}

model BrandGuardrail {
  id             String            @id @default(cuid())
  brandProfileId String
  type           GuardrailType
  name           String
  description    String?           @db.Text
  severity       GuardrailSeverity @default(MEDIUM)
  ruleConfig     Json?
  isActive       Boolean           @default(true)
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  brandProfile BrandProfile @relation(fields: [brandProfileId], references: [id], onDelete: Cascade)

  @@index([brandProfileId])
  @@index([brandProfileId, type])
  @@index([brandProfileId, isActive])
  @@index([type, severity])
  @@map("brand_guardrails")
}

model BrandVocabulary {
  id             String         @id @default(cuid())
  brandProfileId String
  type           VocabularyType
  term           String
  replacement    String?
  context        String?
  isActive       Boolean        @default(true)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  brandProfile BrandProfile @relation(fields: [brandProfileId], references: [id], onDelete: Cascade)

  @@index([brandProfileId])
  @@index([brandProfileId, type])
  @@index([brandProfileId, isActive])
  @@index([term])
  @@map("brand_vocabulary")
}

// =============================================================================
// Content Rewrite Model (Brand Brain AI Rewriter)
// =============================================================================

model ContentRewrite {
  id               String          @id @default(cuid())
  workspaceId      String
  brandProfileId   String
  originalContent  String          @db.Text
  rewrittenContent String?         @db.Text
  platform         ContentPlatform @default(GENERAL)
  status           RewriteStatus   @default(PENDING)
  characterLimit   Int?
  changes          Json? // Diff hunks for selective apply
  toneAnalysis     Json? // Detected vs target tone analysis
  errorMessage     String?
  processedAt      DateTime?
  createdById      String
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  workspace    Workspace    @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  brandProfile BrandProfile @relation(fields: [brandProfileId], references: [id], onDelete: Cascade)
  createdBy    User         @relation(fields: [createdById], references: [id], onDelete: Cascade)

  @@index([workspaceId])
  @@index([brandProfileId])
  @@index([createdById])
  @@index([status])
  @@index([createdAt])
  @@map("content_rewrites")
}

// =============================================================================
// Calendar / Scheduled Posts Models
// Resolves #571 - Create Calendar data model
// =============================================================================

enum ScheduledPostStatus {
  DRAFT // Post is being composed
  PENDING // Waiting for scheduled time
  SCHEDULED // Confirmed and queued for publishing
  PUBLISHING // Currently being published
  PUBLISHED // Successfully published
  FAILED // Publishing failed
  CANCELLED // User cancelled the scheduled post
}

/// Scheduled posts for the Calendar feature
/// Supports multi-platform cross-posting and recurrence
model ScheduledPost {
  id               String              @id @default(cuid())
  content          String              @db.Text
  scheduledAt      DateTime
  timezone         String              @default("UTC")
  recurrenceRule   String? // RRULE format (RFC 5545) for repeating posts
  recurrenceEndAt  DateTime? // When recurrence ends (if recurring)
  status           ScheduledPostStatus @default(DRAFT)
  metadata         Json? // Media URLs, link previews, etc.
  publishedAt      DateTime?
  errorMessage     String?
  retryCount       Int                 @default(0)
  maxRetries       Int                 @default(3)
  lastAttemptAt    DateTime?
  nextOccurrenceAt DateTime? // For recurring posts, when the next occurrence is

  // Workspace ownership
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  // User who created the post
  createdById String
  createdBy   User   @relation(fields: [createdById], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations (many-to-many with accounts via join table)
  postAccounts ScheduledPostAccount[]

  @@index([workspaceId])
  @@index([workspaceId, scheduledAt])
  @@index([workspaceId, status])
  @@index([createdById])
  @@index([status])
  @@index([scheduledAt])
  @@index([nextOccurrenceAt])
  @@map("scheduled_posts")
}

/// Join table for cross-posting scheduled posts to multiple social accounts
model ScheduledPostAccount {
  id        String        @id @default(cuid())
  postId    String
  post      ScheduledPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  accountId String
  account   SocialAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  // Platform-specific post ID after publishing
  platformPostId String?
  publishedAt    DateTime?
  status         ScheduledPostStatus @default(DRAFT)
  errorMessage   String?

  @@unique([postId, accountId])
  @@index([postId])
  @@index([accountId])
  @@index([status])
  @@map("scheduled_post_accounts")
}

// ============================================
// Relay (Inbox) Models - Issue #555
// ============================================

enum InboxItemType {
  MENTION // Someone mentioned the brand
  COMMENT // Comment on a post
  DIRECT_MESSAGE // Direct/private message
  REPLY // Reply to a post or comment
  REVIEW // Product/service review
}

enum InboxItemStatus {
  UNREAD // Not yet viewed
  READ // Viewed but not acted on
  PENDING_REPLY // Has a draft ready for review
  REPLIED // Response has been sent
  ARCHIVED // Archived for later
  IGNORED // Marked to ignore
}

/// Represents incoming social interactions that need attention
model InboxItem {
  id                  String          @id @default(cuid())
  type                InboxItemType
  status              InboxItemStatus @default(UNREAD)
  platform            SocialPlatform
  platformItemId      String // Platform-specific ID for the item
  content             String          @db.Text // Original message/comment content
  senderName          String // Name of the person who sent the message
  senderHandle        String? // @handle or username
  senderAvatarUrl     String? // Profile picture URL
  originalPostId      String? // ID of the post this is in response to (if applicable)
  originalPostContent String?         @db.Text // Content of the original post
  metadata            Json? // Additional platform-specific data
  receivedAt          DateTime // When the message was received on the platform
  readAt              DateTime? // When the item was marked as read
  repliedAt           DateTime? // When a response was sent
  resolvedAt          DateTime? // When the item was resolved/closed

  // Workspace ownership
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  // Social account that received this item
  accountId String
  account   SocialAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  // Team member assignment for routing
  assignedToId String?
  assignedTo   WorkspaceMember? @relation(fields: [assignedToId], references: [id], onDelete: SetNull)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  drafts RelayDraft[]

  @@unique([workspaceId, platform, platformItemId])
  @@index([workspaceId])
  @@index([workspaceId, status])
  @@index([workspaceId, platform])
  @@index([accountId])
  @@index([assignedToId])
  @@index([receivedAt])
  @@map("inbox_items")
}

enum RelayDraftStatus {
  PENDING // Draft awaiting review
  APPROVED // Approved for sending
  REJECTED // Rejected by reviewer
  SENT // Successfully sent
  FAILED // Failed to send
}

/// AI-generated response drafts for inbox items
model RelayDraft {
  id              String           @id @default(cuid())
  content         String           @db.Text // Draft response content
  confidenceScore Float // AI confidence in the draft (0-1)
  status          RelayDraftStatus @default(PENDING)
  isPreferred     Boolean          @default(false) // If this is the recommended draft
  reason          String? // Why this draft was generated
  metadata        Json? // Platform-specific formatting, hashtags, etc.
  sentAt          DateTime? // When the draft was actually sent
  errorMessage    String? // Error if sending failed

  // Parent inbox item
  inboxItemId String
  inboxItem   InboxItem @relation(fields: [inboxItemId], references: [id], onDelete: Cascade)

  // User who approved/rejected (if any)
  reviewedById String?
  reviewedBy   User?     @relation(fields: [reviewedById], references: [id], onDelete: SetNull)
  reviewedAt   DateTime?

  // Edit history for ML feedback loop
  editHistory DraftEditHistory[]
  // Audit log for all actions
  auditLogs   DraftAuditLog[]

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([inboxItemId])
  @@index([inboxItemId, status])
  @@index([status])
  @@map("relay_drafts")
}

// Track edits made to drafts for ML feedback loop
model DraftEditHistory {
  id              String        @id @default(cuid())
  draftId         String
  originalContent String        @db.Text // Content before edit
  editedContent   String        @db.Text // Content after edit
  editType        DraftEditType // Type of edit made
  changesSummary  String? // AI-generated summary of changes
  editDistance    Int? // Levenshtein distance between original and edited

  // User who made the edit
  editedById String
  editedBy   User   @relation(fields: [editedById], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt DateTime @default(now())

  draft RelayDraft @relation(fields: [draftId], references: [id], onDelete: Cascade)

  @@index([draftId])
  @@index([editedById])
  @@index([editType])
  @@map("draft_edit_history")
}

enum DraftEditType {
  MINOR_TWEAK // Small changes (punctuation, capitalization)
  TONE_ADJUSTMENT // Changed tone/style
  CONTENT_REVISION // Significant content changes
  COMPLETE_REWRITE // Fully rewrote the draft
  PLATFORM_FORMATTING // Added/changed hashtags, mentions, etc.
}

// Audit log for all draft actions
model DraftAuditLog {
  id        String           @id @default(cuid())
  draftId   String
  action    DraftAuditAction
  details   Json? // Additional context for the action
  ipAddress String?
  userAgent String?

  // User who performed the action
  performedById String
  performedBy   User   @relation(fields: [performedById], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt DateTime @default(now())

  draft RelayDraft @relation(fields: [draftId], references: [id], onDelete: Cascade)

  @@index([draftId])
  @@index([performedById])
  @@index([action])
  @@index([createdAt])
  @@map("draft_audit_logs")
}

enum DraftAuditAction {
  CREATED // Draft was generated
  VIEWED // Draft was viewed by user
  EDITED // Draft content was modified
  APPROVED // Draft was approved for sending
  REJECTED // Draft was rejected
  SENT // Draft was sent to platform
  SEND_FAILED // Sending failed
  REGENERATED // User requested regeneration
}

// =============================================================================
// Crisis Detection System Models
// Resolves #588: Create Crisis Detection System
// =============================================================================

model CrisisDetectionEvent {
  id          String    @id @default(cuid())
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  severity CrisisSeverity
  status   CrisisEventStatus @default(DETECTED)

  triggerType String // SENTIMENT_SPIKE, ENGAGEMENT_DROP, VIRAL_COMPLAINT, MANUAL
  triggerData Json // Detection context and metrics

  affectedAccountIds String[] // Social account IDs affected by this crisis

  // Response tracking
  acknowledgedAt   DateTime?
  acknowledgedById String?
  acknowledgedBy   User?     @relation("CrisisAcknowledger", fields: [acknowledgedById], references: [id], onDelete: SetNull)

  resolvedAt   DateTime?
  resolvedById String?
  resolvedBy   User?     @relation("CrisisResolver", fields: [resolvedById], references: [id], onDelete: SetNull)

  responseNotes String? @db.Text

  // Timestamps
  detectedAt DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([workspaceId])
  @@index([status])
  @@index([severity])
  @@index([detectedAt])
  @@index([workspaceId, status])
  @@map("crisis_detection_events")
}

model CrisisResponseTemplate {
  id          String     @id @default(cuid())
  workspaceId String? // null = system template available to all
  workspace   Workspace? @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  name      String
  category  String // APOLOGY, ACKNOWLEDGMENT, REDIRECT, ESCALATION, EMPATHY
  platform  SocialPlatform? // null = all platforms
  content   String          @db.Text
  variables String[] // Placeholder variables like {customer_name}, {issue}

  isActive   Boolean @default(true)
  usageCount Int     @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([workspaceId])
  @@index([category])
  @@index([isActive])
  @@map("crisis_response_templates")
}

model CrisisAlertRule {
  id          String    @id @default(cuid())
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  name        String
  description String?
  ruleType    CrisisRuleType
  conditions  Json // Rule configuration (thresholds, metrics, patterns)
  severity    CrisisSeverity

  notifyChannels       String[] // email, slack, in_app, push
  escalateAfterMinutes Int? // Auto-escalate if not acknowledged within this time

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([workspaceId])
  @@index([isActive])
  @@index([ruleType])
  @@map("crisis_alert_rules")
}

enum CrisisSeverity {
  LOW // Minor issue, monitor only
  MEDIUM // Moderate concern, review needed
  HIGH // Significant issue, action required
  CRITICAL // Major crisis, immediate response needed
}

enum CrisisEventStatus {
  DETECTED // Crisis detected by system
  ACKNOWLEDGED // Team has seen and is reviewing
  RESOLVED // Crisis has been handled
  FALSE_ALARM // Not a real crisis
}

enum CrisisRuleType {
  SENTIMENT_THRESHOLD // Negative sentiment exceeds threshold
  ENGAGEMENT_DROP // Engagement rate drops significantly
  MENTION_SPIKE // Unusual spike in mentions/comments
  FOLLOWER_DROP // Significant follower loss
  VIRAL_COMPLAINT // Single post getting unusual negative engagement
  MANUAL // Manually triggered crisis
}

// =============================================================================
// Account Health Monitoring System Models
// Resolves #586: Implement Account Health Monitor
// =============================================================================

/// Tracks the health status of each connected social account
/// Provides real-time monitoring of sync status, rate limits, and token health
model SocialAccountHealth {
  id        String        @id @default(cuid())
  accountId String        @unique
  account   SocialAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  // Health metrics
  healthScore Int                 @default(100) // 0-100 score
  status      AccountHealthStatus @default(HEALTHY)

  // Sync tracking
  lastSuccessfulSync DateTime?
  lastSyncAttempt    DateTime?
  lastError          String?
  lastErrorAt        DateTime?
  consecutiveErrors  Int       @default(0)
  totalErrorsLast24h Int       @default(0)

  // Rate limit tracking
  rateLimitRemaining Int?
  rateLimitTotal     Int?
  rateLimitResetAt   DateTime?
  isRateLimited      Boolean   @default(false)

  // Token health
  tokenExpiresAt       DateTime?
  tokenRefreshRequired Boolean   @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([accountId])
  @@index([status])
  @@index([healthScore])
  @@map("social_account_health")
}

/// Recovery guidance templates for common account issues
/// Provides step-by-step instructions for resolving problems
model RecoveryGuidance {
  id              String           @id @default(cuid())
  platform        SocialPlatform? // null = all platforms
  issueType       AccountIssueType
  severity        IssueSeverity
  title           String
  description     String           @db.Text
  steps           Json // Array of { order, title, description, actionUrl?, isAutomated? }
  estimatedTime   String? // e.g., "5-10 minutes"
  requiresAction  Boolean          @default(true)
  autoRecoverable Boolean          @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([platform, issueType])
  @@index([issueType])
  @@index([severity])
  @@map("recovery_guidance")
}

/// Account health events log for tracking status changes and issues
model AccountHealthEvent {
  id          String        @id @default(cuid())
  accountId   String
  account     SocialAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  workspaceId String
  workspace   Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  eventType      AccountHealthEventType
  severity       IssueSeverity
  previousStatus AccountHealthStatus?
  newStatus      AccountHealthStatus
  previousScore  Int?
  newScore       Int
  message        String
  details        Json? // Additional context

  resolvedAt      DateTime?
  resolvedById    String?
  resolvedBy      User?     @relation("HealthEventResolver", fields: [resolvedById], references: [id], onDelete: SetNull)
  resolutionNotes String?

  createdAt DateTime @default(now())

  @@index([accountId, createdAt])
  @@index([workspaceId, createdAt])
  @@index([eventType])
  @@index([severity])
  @@map("account_health_events")
}

enum AccountHealthStatus {
  HEALTHY // Score 80-100, all systems operational
  DEGRADED // Score 50-79, minor issues detected
  UNHEALTHY // Score 20-49, significant problems
  CRITICAL // Score 0-19, immediate attention required
}

enum AccountIssueType {
  TOKEN_EXPIRED // OAuth token has expired
  TOKEN_EXPIRING_SOON // Token will expire within 24h
  RATE_LIMITED // Hit platform rate limits
  API_ERROR // API call failed
  PERMISSION_DENIED // Missing required permissions
  ACCOUNT_RESTRICTED // Platform restrictions on account
  ACCOUNT_SUSPENDED // Account suspended by platform
  SYNC_FAILED // Metrics sync failed
  CONNECTION_LOST // Cannot connect to platform
  QUOTA_EXCEEDED // API quota exhausted
}

enum AccountHealthEventType {
  STATUS_CHANGED // Health status changed
  SCORE_DECREASED // Health score dropped
  SCORE_RECOVERED // Health score improved
  RATE_LIMIT_HIT // Rate limit triggered
  RATE_LIMIT_CLEARED // Rate limit reset
  ERROR_OCCURRED // API error detected
  ERROR_RESOLVED // Error condition cleared
  TOKEN_REFRESHED // Token successfully refreshed
  TOKEN_EXPIRED // Token expiration detected
  ACCOUNT_RECOVERED // Full recovery from issues
  MANUAL_INTERVENTION // User took manual action
}

enum IssueSeverity {
  INFO // Informational only
  WARNING // Minor issue, monitor
  ERROR // Problem requiring attention
  CRITICAL // Urgent issue requiring immediate action
}

// Policy Checker System Models
// Resolves #584: Build Policy Checker
// =============================================================================

/// Policy rules for content validation across platforms
/// Stores platform-specific and global policy configurations
model PolicyRule {
  id          String     @id @default(cuid())
  workspaceId String? // null = global/system rule
  workspace   Workspace? @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  // Rule identification
  name        String
  description String          @db.Text
  platform    SocialPlatform? // null = applies to all platforms
  category    PolicyCategory
  ruleType    PolicyRuleType

  // Rule configuration
  conditions Json // Rule conditions and patterns
  severity   PolicySeverity @default(WARNING)
  isBlocking Boolean        @default(false) // If true, prevents publishing
  isActive   Boolean        @default(true)

  // Metadata
  sourceUrl      String? // Link to official policy documentation
  lastVerifiedAt DateTime? // When this rule was last verified against platform docs
  version        Int       @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  violations PolicyViolation[]

  @@unique([workspaceId, platform, name])
  @@index([workspaceId])
  @@index([platform])
  @@index([category])
  @@index([isActive])
  @@map("policy_rules")
}

/// Records of policy check executions
/// Tracks what content was checked and the overall result
model PolicyCheck {
  id          String    @id @default(cuid())
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  // Content being checked
  contentType     PolicyContentType
  contentId       String? // Reference to ScheduledPost, InboxItem, etc.
  contentText     String            @db.Text
  contentMetadata Json? // Additional content info (images, links, etc.)

  // Check configuration
  platform   SocialPlatform? // Target platform for this check
  checkScope PolicyCheckScope @default(FULL)

  // Results
  status        PolicyCheckStatus  @default(PENDING)
  passedRules   Int                @default(0)
  failedRules   Int                @default(0)
  warningRules  Int                @default(0)
  overallResult PolicyCheckResult?
  summary       String?            @db.Text

  // Timing
  startedAt   DateTime  @default(now())
  completedAt DateTime?
  durationMs  Int?

  // Actor
  checkedById String?
  checkedBy   User?   @relation(fields: [checkedById], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  // Relations
  violations PolicyViolation[]

  @@index([workspaceId, createdAt])
  @@index([contentType, contentId])
  @@index([status])
  @@index([overallResult])
  @@map("policy_checks")
}

/// Individual policy violations detected during checks
/// Links violations to specific rules and provides remediation guidance
model PolicyViolation {
  id          String      @id @default(cuid())
  checkId     String
  check       PolicyCheck @relation(fields: [checkId], references: [id], onDelete: Cascade)
  ruleId      String
  rule        PolicyRule  @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  workspaceId String
  workspace   Workspace   @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  // Violation details
  severity       PolicySeverity
  message        String         @db.Text
  matchedContent String?        @db.Text // The specific content that triggered the violation
  matchLocation  Json? // Where in the content the violation was found
  confidence     Float? // 0-1 confidence score for NLP-detected violations

  // Remediation
  suggestedFix   String?   @db.Text
  isOverridden   Boolean   @default(false)
  overriddenById String?
  overriddenBy   User?     @relation(fields: [overriddenById], references: [id], onDelete: SetNull)
  overrideReason String?
  overriddenAt   DateTime?

  createdAt DateTime @default(now())

  @@index([checkId])
  @@index([ruleId])
  @@index([workspaceId, createdAt])
  @@index([severity])
  @@map("policy_violations")
}

enum PolicyCategory {
  CONTENT_GUIDELINES // General content policies
  AD_COMPLIANCE // Advertising-specific rules
  CHARACTER_LIMITS // Platform character restrictions
  PROHIBITED_CONTENT // Banned content types
  CLAIMS_RESTRICTIONS // Health, financial, legal claims
  BRAND_SAFETY // Brand protection rules
  ACCESSIBILITY // Accessibility requirements
  HASHTAG_RULES // Hashtag usage policies
  LINK_POLICIES // URL and link restrictions
  MEDIA_REQUIREMENTS // Image/video specifications
}

enum PolicyRuleType {
  KEYWORD_MATCH // Simple keyword/phrase detection
  REGEX_PATTERN // Regular expression matching
  CHARACTER_COUNT // Length validation
  MEDIA_CHECK // Image/video requirements
  LINK_VALIDATION // URL checking
  NLP_CLASSIFICATION // ML-based content classification
  CUSTOM_LOGIC // Custom validation logic
}

enum PolicySeverity {
  INFO // Informational only
  WARNING // Should review, but can proceed
  ERROR // Must fix before publishing
  CRITICAL // Immediate action required, blocks publishing
}

enum PolicyContentType {
  POST // Social media post
  AD // Paid advertisement
  COMMENT // Reply/comment
  MESSAGE // Direct message
  BIO // Profile bio/description
  STORY // Ephemeral content
}

enum PolicyCheckScope {
  FULL // Check all applicable rules
  QUICK // Check critical rules only
  CUSTOM // Check specific rule categories
}

enum PolicyCheckStatus {
  PENDING // Check queued
  IN_PROGRESS // Currently checking
  COMPLETED // Check finished
  FAILED // Check failed (system error)
}

enum PolicyCheckResult {
  PASSED // All checks passed
  PASSED_WITH_WARNINGS // Passed but has warnings
  FAILED // Has errors/critical violations
  BLOCKED // Has blocking violations
}

// =============================================================================
// SCOUT CONTENT SUGGESTIONS
// =============================================================================

/// AI-generated content suggestions based on trends and competitor analysis
model ContentSuggestion {
  id                  String                    @id
  workspaceId         String
  workspace           Workspace                 @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  // Content details
  title               String
  description         String                    @db.Text
  draftContent        String                    @db.Text
  contentType         SuggestionContentType
  suggestedPlatforms  String[]                  // Array of platform names

  // Trend data as JSON (source, keywords, metrics)
  trendData           Json[]

  // Scoring
  relevanceScore      Float
  timelinessScore     Float
  brandAlignmentScore Float
  overallScore        Float

  // Status tracking
  status              SuggestionStatus          @default(PENDING)
  generatedAt         DateTime                  @default(now())
  expiresAt           DateTime?
  usedAt              DateTime?
  dismissedAt         DateTime?
  dismissalReason     String?
  feedback            String?                   @db.Text

  @@index([workspaceId, status])
  @@index([workspaceId, overallScore])
  @@index([expiresAt])
  @@map("content_suggestions")
}

enum SuggestionContentType {
  POST
  THREAD
  STORY
  REEL
  ARTICLE
}

enum SuggestionStatus {
  PENDING
  ACCEPTED
  DISMISSED
  USED
}

// =============================================================================
// Allocator Models
// =============================================================================

enum AllocatorPlatform {
  FACEBOOK_ADS
  GOOGLE_ADS
  LINKEDIN_ADS
}

model AllocatorCampaign {
  id                 String            @id @default(cuid())
  workspaceId        String
  workspace          Workspace         @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  platform           AllocatorPlatform
  platformCampaignId String
  name               String
  status             String // Platform-specific status (e.g., "ACTIVE", "PAUSED")
  budget             Decimal?          @db.Decimal(10, 2)
  spend              Decimal           @default(0) @db.Decimal(10, 2)
  metrics            Json? // Store other relevant metrics
  lastSyncAt         DateTime
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  adSets             AllocatorAdSet[]

  @@unique([workspaceId, platform, platformCampaignId])
  @@index([workspaceId])
  @@index([platform])
  @@map("allocator_campaigns")
}

model AllocatorAdSet {
  id              String   @id @default(cuid())
  campaignId      String
  campaign        AllocatorCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  platformAdSetId String
  name            String
  status          String
  budget          Decimal? @db.Decimal(10, 2)
  spend           Decimal  @default(0) @db.Decimal(10, 2)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([campaignId, platformAdSetId])
  @@index([campaignId])
  @@map("allocator_ad_sets")
}

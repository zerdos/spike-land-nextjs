# Database Configuration
# PostgreSQL connection string format:
# postgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=SCHEMA
#
# Examples:
# - Local: postgresql://postgres:password@localhost:5432/spike_land?schema=public
# - Supabase: postgresql://postgres:[YOUR-PASSWORD]@db.[PROJECT-REF].supabase.co:5432/postgres
# - Railway: postgresql://postgres:[PASSWORD]@[HOST]:[PORT]/railway
# - Neon: postgresql://[USER]:[PASSWORD]@[HOST]/[DATABASE]?sslmode=require
DATABASE_URL=postgresql://postgres:password@localhost:5432/spike_land?schema=public

# Database Connection Pooling (Production)
# Use connection pooling for serverless/edge environments
# DIRECT_URL is for migrations, DATABASE_URL is for queries
# DIRECT_URL=postgresql://postgres:password@localhost:5432/spike_land?schema=public

# NextAuth.js Configuration
# Generate a random secret for AUTH_SECRET:
# - Run: openssl rand -base64 32
# - Or visit: https://generate-secret.vercel.app/32
AUTH_SECRET=your-secret-key-here

# User ID Salt (Recommended for Production)
# Used to generate stable user IDs from email addresses.
# This ensures the same user gets the same ID across OAuth providers.
#
# IMPORTANT:
# - This value should NEVER be rotated once set in production
# - Changing this will cause all user IDs to change, breaking user data associations
# - If not set, AUTH_SECRET is used as fallback
# - Generate with: openssl rand -base64 32
#
# USER BEHAVIOR NOTE:
# - User IDs are tied to email addresses (user_<hash-of-email>)
# - If a user changes their email at the OAuth provider, they get a NEW user ID
# - This means they lose access to previous data (images, albums, tokens)
# - This is by design to maintain 1:1 email-to-identity relationship
#
# USER_ID_SALT=your-user-id-salt-here

# NextAuth URL (development)
# Production: Set this to your production domain (e.g., https://yourdomain.com)
NEXTAUTH_URL=http://localhost:3000

# GitHub OAuth Provider
# To obtain GitHub OAuth credentials:
# 1. Go to: https://github.com/settings/developers
# 2. Click "New OAuth App" or "New GitHub App"
# 3. Set Authorization callback URL to: http://localhost:3000/api/auth/callback/github
# 4. Copy Client ID and generate a Client Secret
GITHUB_ID=your-github-oauth-client-id
GITHUB_SECRET=your-github-oauth-client-secret

# Google OAuth Provider
# To obtain Google OAuth credentials:
# 1. Go to: https://console.cloud.google.com/
# 2. Create a new project or select existing one
# 3. Navigate to "APIs & Services" > "Credentials"
# 4. Click "Create Credentials" > "OAuth client ID"
# 5. Choose "Web application" as application type
# 6. Add authorized redirect URI: http://localhost:3000/api/auth/callback/google
# 7. Copy Client ID and Client Secret
GOOGLE_ID=your-google-oauth-client-id
GOOGLE_SECRET=your-google-oauth-client-secret

# Facebook OAuth Provider (Consumer Login)
# To obtain Facebook OAuth credentials:
# 1. Go to: https://developers.facebook.com/apps/
# 2. Create a new app with "Consumer" type (NOT "Business")
# 3. Select use case: "Authenticate and request data from users with Facebook Login"
# 4. Go to Use Cases > Customize > Settings
# 5. Add Valid OAuth Redirect URI: http://localhost:3000/api/auth/callback/facebook
# 6. For production, also add: https://yourdomain.com/api/auth/callback/facebook
# 7. Go to App Settings > Basic to get App ID and App Secret
# 8. Add your domain to "App Domains" in Basic Settings
#
# NOTE: Uses AUTH_ prefix to distinguish from FACEBOOK_MARKETING_APP_* (Marketing API)
AUTH_FACEBOOK_ID=your-facebook-oauth-app-id
AUTH_FACEBOOK_SECRET=your-facebook-oauth-app-secret

# E2E Test Authentication Bypass
# Secret value used to bypass authentication in E2E tests
# - Generate a random secret: openssl rand -base64 32
# - The secret is sent as 'x-e2e-auth-bypass' header by Playwright tests
#
# Configuration Required:
# 1. LOCAL DEVELOPMENT:
#    - Set this in .env.local when running: npm run test:e2e:local
#
# 2. GITHUB ACTIONS CI/CD:
#    - Add to GitHub Secrets: https://github.com/YOUR-ORG/YOUR-REPO/settings/secrets/actions
#    - Name: E2E_BYPASS_SECRET
#    - Value: Same random secret (openssl rand -base64 32)
#
# 3. VERCEL RUNTIME (REQUIRED):
#    - Add to Vercel Environment Variables: https://vercel.com/YOUR-TEAM/YOUR-PROJECT/settings/environment-variables
#    - Name: E2E_BYPASS_SECRET
#    - Value: Same random secret as GitHub
#    - Environments: ✅ Preview, ✅ Development, ❌ Production (DO NOT enable for production)
#
# Why Both GitHub and Vercel?
# - GitHub Secrets: Used during CI/CD build pipeline and E2E test execution
# - Vercel Environment Variables: Used by middleware at runtime on Vercel's edge network
#
# Security Features:
# - Production Protection: Bypass is BLOCKED in production even if secret is configured
#   (requires both NODE_ENV=production AND VERCEL_ENV=production to block)
# - Constant-time Comparison: Uses timingSafeEqual to prevent timing attacks
# - Audit Logging: All bypass attempts are logged with timestamp and environment info
#
# E2E_BYPASS_SECRET=your-e2e-bypass-secret-here

# Google AI (Gemini + Imagen)
# Get your API key from: https://aistudio.google.com/app/apikey
# Used for image analysis (Gemini) and enhancement (Imagen)
GEMINI_API_KEY=your-gemini-api-key-here
# IMAGEN_API_KEY may be the same as GEMINI_API_KEY
# IMAGEN_API_KEY=your-imagen-api-key-here

# Cloudflare R2 Storage
# To obtain Cloudflare R2 credentials:
# 1. Go to: https://dash.cloudflare.com/
# 2. Select your account
# 3. Navigate to R2 > Overview
# 4. Create a bucket (e.g., spike-land-images)
# 5. Go to "Manage R2 API Tokens" > Create API Token
# 6. Copy Account ID, Access Key ID, and Secret Access Key
CLOUDFLARE_ACCOUNT_ID=your-cloudflare-account-id
CLOUDFLARE_R2_ACCESS_KEY_ID=your-r2-access-key-id
CLOUDFLARE_R2_SECRET_ACCESS_KEY=your-r2-secret-access-key
CLOUDFLARE_R2_BUCKET_NAME=spike-land-images

# Cloudflare Images API
# Used for image transformation and CDN delivery
# Get credentials from: https://dash.cloudflare.com/ > Images
CLOUDFLARE_IMAGES_API_KEY=your-images-api-key
CLOUDFLARE_IMAGES_ACCOUNT_HASH=your-account-hash

# Stripe Payment Integration
# Get credentials from: https://dashboard.stripe.com/apikeys
# Start with test keys (sk_test_... and pk_test_...)
# STRIPE_SECRET_KEY=sk_test_your-stripe-secret-key
# NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_your-stripe-publishable-key
# STRIPE_WEBHOOK_SECRET=whsec_your-webhook-secret

# Rate Limiting (Optional - Upstash Redis)
# Get credentials from: https://console.upstash.com/
# UPSTASH_REDIS_REST_URL=https://your-redis-url.upstash.io
# UPSTASH_REDIS_REST_TOKEN=your-redis-token

# Error Tracking
# This project uses structured logging (src/lib/error-logger.ts) combined with
# Vercel Analytics for monitoring. No external error tracking service is required.
# See docs/CEO_DECISIONS.md for the decision to not use Sentry.

# Resend Email Service
# Get API key from: https://resend.com/api-keys
# Used for transactional emails (welcome, purchase confirmations, etc.)
RESEND_API_KEY=re_your_resend_api_key_here
EMAIL_FROM=noreply@spike.land

# Facebook Marketing API
# To obtain Facebook Marketing API credentials:
# 1. Go to: https://developers.facebook.com/apps/
# 2. Create a new app with "Business" type
# 3. Add "Marketing API" product
# 4. Configure OAuth redirect URIs
# 5. Get App ID and App Secret from Basic Settings
# Required permissions: ads_read, ads_management, business_management
FACEBOOK_MARKETING_APP_ID=your-facebook-app-id
FACEBOOK_MARKETING_APP_SECRET=your-facebook-app-secret

# Google Ads API
# To obtain Google Ads API credentials:
# 1. Uses same OAuth client as GOOGLE_ID/GOOGLE_SECRET (above)
# 2. Enable Google Ads API at: https://console.cloud.google.com/apis/library/googleads.googleapis.com
# 3. Apply for developer token at: https://ads.google.com/aw/apicenter
# 4. Get customer ID from your Google Ads account
GOOGLE_ADS_DEVELOPER_TOKEN=your-google-ads-developer-token
GOOGLE_ADS_CUSTOMER_ID=your-google-ads-customer-id

# Token Encryption (REQUIRED for production)
# Encrypts OAuth tokens stored in the database using AES-256-GCM
# Generate a 32-byte key with: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
# IMPORTANT: Do NOT rotate this key after tokens are stored - they will become unreadable
TOKEN_ENCRYPTION_KEY=your-64-character-hex-key-here

# Marketing OAuth Callback URLs (Optional)
# If not set, callbacks are computed from NEXTAUTH_URL or VERCEL_URL
# Set these if you need explicit control over callback URLs
# IMPORTANT: These must match EXACTLY what's configured in the OAuth provider
#
# For Google Ads, add these to Google Cloud Console > APIs & Credentials > OAuth 2.0 Client:
#   - http://localhost:3000/api/marketing/google/callback (development)
#   - https://yourdomain.com/api/marketing/google/callback (production)
#
# For Facebook, add to Facebook Developer Console > App Settings > Basic > OAuth Redirect URIs:
#   - http://localhost:3000/api/marketing/facebook/callback (development)
#   - https://yourdomain.com/api/marketing/facebook/callback (production)
#
# GOOGLE_ADS_CALLBACK_URL=https://yourdomain.com/api/marketing/google/callback
# FACEBOOK_CALLBACK_URL=https://yourdomain.com/api/marketing/facebook/callback

# Implementation Plan: Real Photos + Gallery Enhancements (#704)

**Issue**: [#704](https://github.com/zerdos/spike-land-nextjs/issues/704)
**Created**: 2026-01-29
**Complexity**: Medium-Complex (multiple features, database changes, AI integration)

---

## Summary

Enhance the Pixel app to load real user-generated images in public galleries (landing page and `/pixel`), add a public gallery browser, implement auto-tagging using existing AI vision analysis, save enhancement types, and enable photo inventory functionality.

---

## Requirements Breakdown

### 1. Load Real Images to Public Pages ✅ (Partially Complete)

- **Current State**: Landing page (`/pixel`) and `/apps/pixel` already load real images from super admin's public albums via `getSuperAdminPublicPhotos()`
- **Gap**: Need to expand beyond single "landing page album" to all public albums
- **Needed**: Configuration or UI to manage which albums are featured

### 2. Public Gallery Browser (NEW)

- Create `/gallery` page for public browsing
- Display all public photos from all users (filtered by privacy settings)
- Support filtering by category, tags, enhancement tier
- Pagination for scalability
- Mobile-responsive masonry/grid layout

### 3. Auto-Tagging for Photos (NEW)

- Extract tags from existing `ImageEnhancementJob.analysisResult` JSON
- Store tags in new `tags` field on `EnhancedImage` model
- Generate tags when enhancement completes
- Allow manual tag editing by image owner
- Use tags for search and filtering

### 4. Save Enhancement Types (PARTIAL)

- **Current**: `ImageEnhancementJob.tier` saves TIER_1K/TIER_2K/TIER_4K
- **Gap**: Need to track enhancement methodology (e.g., "standard", "blend", "pipeline")
- **Needed**: Add `enhancementType` enum field to job model

### 5. Photo Inventory Feature (NEW)

- User's personal photo library view at `/apps/pixel/library`
- Search, filter, sort by date/name/tags
- Bulk operations (delete, add to album, tag)
- Storage usage tracking
- Export metadata capability

---

## Database Schema Changes

### Migration 1: Add Tags to EnhancedImage

```prisma
model EnhancedImage {
  // ... existing fields
  tags              String[]              @default([]) // Auto-generated and manual tags
  // ... rest of model
}
```

**Reasoning**: Tags belong to the image, not individual jobs, because multiple jobs may analyze the same image differently. Tags represent the "what's in this image" which is consistent across enhancements.

### Migration 2: Add Enhancement Type Tracking

```prisma
enum EnhancementType {
  STANDARD          // Regular prompt-based enhancement
  BLEND             // Image-to-image blending
  PIPELINE          // Custom pipeline processing
  AUTO_CROP         // Auto-crop focused enhancement
}

model ImageEnhancementJob {
  // ... existing fields
  enhancementType   EnhancementType   @default(STANDARD)
  // ... rest of model
}
```

**Reasoning**: This tracks the _methodology_ used, not just the quality tier. Helps users understand how their image was processed.

### Migration 3: Add Public Gallery Indexes

```prisma
model EnhancedImage {
  // Add index for public gallery queries
  @@index([isPublic, createdAt])
  @@index([tags]) // For tag-based filtering
}
```

**Reasoning**: Public gallery will query `isPublic = true` with pagination/sorting. Tag filtering needs index for performance.

---

## Implementation Plan

### Phase 1: Database & Backend Foundation

#### Step 1.1: Database Migration

**Files to modify**:

- `prisma/schema.prisma`
  - Add `tags String[] @default([])` to `EnhancedImage` model
  - Add `EnhancementType` enum with STANDARD, BLEND, PIPELINE, AUTO_CROP
  - Add `enhancementType EnhancementType @default(STANDARD)` to `ImageEnhancementJob`
  - Add indexes for `[isPublic, createdAt]` and `[tags]` on `EnhancedImage`

**Actions**:

```bash
npx prisma migrate dev --name add_image_tags_and_enhancement_types
npx prisma generate
```

**Testing**:

- Run migration in development
- Verify schema with `npx prisma db push --preview-feature`
- Check that existing data migrates cleanly (tags default to empty array)

#### Step 1.2: Auto-Tagging Service

**Files to create**:

- `src/lib/images/auto-tagger.ts` - Extract tags from Gemini analysis
- `src/lib/images/auto-tagger.test.ts` - Unit tests for tag extraction

**Implementation**:

```typescript
// src/lib/images/auto-tagger.ts
interface AnalysisResult {
  // Based on existing Gemini analysis structure
  objects?: string[];
  colors?: string[];
  style?: string;
  mood?: string;
}

export function extractTagsFromAnalysis(analysisJson: unknown): string[] {
  // Parse analysisResult JSON from ImageEnhancementJob
  // Extract meaningful tags from objects, colors, style, mood
  // Normalize and deduplicate
  // Limit to top 10-15 most relevant tags
  return tags;
}

export async function applyAutoTags(imageId: string): Promise<void> {
  // Fetch latest completed job with analysis
  // Extract tags
  // Update EnhancedImage.tags field
}
```

**Testing Considerations**:

- Handle null/invalid JSON gracefully
- Test with various analysis result formats
- Verify tag deduplication and normalization
- Test with empty/missing analysis data

#### Step 1.3: Update Enhancement Workflow

**Files to modify**:

- `src/workflows/enhance-image.direct.ts`
  - Call `applyAutoTags()` after successful enhancement
  - Determine and set `enhancementType` based on job parameters

**Changes**:

```typescript
// After enhancement completes successfully:
if (job.analysisResult) {
  await applyAutoTags(job.imageId);
}

// Set enhancement type based on job configuration:
const enhancementType = determineEnhancementType({
  isBlend: job.isBlend,
  pipelineId: job.pipelineId,
  wasCropped: job.wasCropped,
});
```

**Testing**:

- Verify tags populate on new enhancements
- Test that existing images without tags continue working
- Ensure no performance regression in enhancement pipeline

### Phase 2: Public Gallery API & UI

#### Step 2.1: Public Gallery API Endpoint

**Files to create**:

- `src/app/api/gallery/public/route.ts` - Public gallery endpoint
- `src/app/api/gallery/public/route.test.ts` - API tests

**Implementation**:

```typescript
// GET /api/gallery/public?page=1&limit=20&tags=landscape,sunset&tier=TIER_2K
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get("page") || "1");
  const limit = Math.min(parseInt(searchParams.get("limit") || "20"), 100);
  const tags = searchParams.get("tags")?.split(",") || [];
  const tier = searchParams.get("tier") as EnhancementTier | undefined;

  const images = await prisma.enhancedImage.findMany({
    where: {
      isPublic: true,
      ...(tags.length > 0 && { tags: { hasSome: tags } }),
      ...(tier && {
        enhancementJobs: {
          some: {
            tier,
            status: JobStatus.COMPLETED,
          },
        },
      }),
    },
    include: {
      enhancementJobs: {
        where: { status: JobStatus.COMPLETED },
        orderBy: { createdAt: "desc" },
        take: 1,
      },
      user: {
        select: { name: true }, // Optional attribution
      },
    },
    orderBy: { createdAt: "desc" },
    skip: (page - 1) * limit,
    take: limit,
  });

  return NextResponse.json({
    items: images.map(formatGalleryItem),
    pagination: { page, limit, total: await countPublicImages() },
  });
}
```

**Cache Strategy**:

- Add `Cache-Control: public, s-maxage=300, stale-while-revalidate=600`
- Match existing public albums API caching

**Testing**:

- Test pagination
- Test tag filtering (single and multiple tags)
- Test tier filtering
- Test empty results
- Verify response format matches spec
- Test cache headers

#### Step 2.2: Public Gallery Page

**Files to create**:

- `src/app/gallery/page.tsx` - Server component (SEO-friendly)
- `src/app/gallery/GalleryClient.tsx` - Client component with interactivity
- `src/components/gallery/GalleryGrid.tsx` - Masonry/grid layout
- `src/components/gallery/GalleryFilters.tsx` - Filter UI (tags, tiers)
- `src/components/gallery/ImageModal.tsx` - Full-screen image view

**Features**:

- Infinite scroll or pagination
- Filter by tags (multi-select dropdown)
- Filter by enhancement tier (chips)
- Masonry grid layout (responsive)
- Click to expand image (modal with details)
- Share button for individual images
- "Add to Album" for authenticated users (future)

**Styling**:

- Use shadcn/ui components for consistency
- Tailwind CSS for responsive grid
- Skeleton loaders for progressive loading
- Empty state when no images match filters

**Testing**:

- E2E test: Filter by tags
- E2E test: Pagination/infinite scroll
- E2E test: Image modal open/close
- E2E test: Mobile responsive layout
- Unit test: Filter state management

#### Step 2.3: Update Landing Page

**Files to modify**:

- `src/components/landing/BeforeAfterGallery.tsx`
  - Add link to "View Full Gallery →" at bottom
- `src/app/pixel/page.tsx`
  - Add featured gallery section with link to `/gallery`

**Changes**:

- Small UI additions, primarily adding CTAs to new public gallery
- Consider showing random subset from public gallery

### Phase 3: Photo Inventory Feature

#### Step 3.1: Library View Backend

**Files to create**:

- `src/app/api/pixel/library/route.ts` - User's photo library API
- `src/app/api/pixel/library/route.test.ts` - API tests
- `src/lib/images/bulk-operations.ts` - Bulk tag/delete operations

**Implementation**:

```typescript
// GET /api/pixel/library?search=sunset&tags=landscape&sort=date_desc
export async function GET(request: Request) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const search = searchParams.get("search") || "";
  const tags = searchParams.get("tags")?.split(",") || [];
  const sort = searchParams.get("sort") || "date_desc";

  const images = await prisma.enhancedImage.findMany({
    where: {
      userId: session.user.id,
      ...(search && {
        OR: [
          { name: { contains: search, mode: "insensitive" } },
          { description: { contains: search, mode: "insensitive" } },
        ],
      }),
      ...(tags.length > 0 && { tags: { hasSome: tags } }),
    },
    include: {
      enhancementJobs: true,
      albumImages: {
        include: { album: { select: { name: true } } },
      },
    },
    orderBy: getSortOrder(sort),
  });

  return NextResponse.json({ items: images });
}
```

**Features**:

- Search by name/description
- Filter by tags
- Sort by date (newest/oldest), name (A-Z/Z-A), file size
- Display storage used per image
- Show which albums contain each image

#### Step 3.2: Library View UI

**Files to create**:

- `src/app/apps/pixel/library/page.tsx` - Library page server component
- `src/app/apps/pixel/library/LibraryClient.tsx` - Client component
- `src/components/pixel/LibraryGrid.tsx` - Grid with selection checkboxes
- `src/components/pixel/BulkActions.tsx` - Bulk operation toolbar
- `src/components/pixel/StorageIndicator.tsx` - Storage usage visualization

**Features**:

- Checkbox selection (select all, select none)
- Bulk actions: Delete, Add to Album, Apply Tags
- Search bar at top
- Tag filter chips (shows user's existing tags)
- Sort dropdown
- Grid/list view toggle
- Storage usage bar showing total/used space

**Testing**:

- E2E test: Search functionality
- E2E test: Bulk selection and delete
- E2E test: Bulk tag application
- E2E test: Sort and filter combination
- Unit test: Selection state management

#### Step 3.3: Tag Management UI

**Files to create**:

- `src/components/pixel/TagEditor.tsx` - Edit tags on single image
- `src/components/pixel/TagManager.tsx` - Manage all tags globally
- `src/app/api/pixel/tags/route.ts` - Tag CRUD operations

**Features**:

- Edit tags on image detail page
- Autocomplete from existing tags
- Create new tags
- Delete unused tags
- Rename tags globally (updates all images)

### Phase 4: Enhancement Type Tracking

#### Step 4.1: Update Job Creation

**Files to modify**:

- `src/app/api/enhance/route.ts` - Set `enhancementType` when creating job
- `src/app/apps/pixel/mix/[jobId]/page.tsx` - Blend jobs should set BLEND type
- `src/app/apps/pixel/pipelines/page.tsx` - Pipeline jobs should set PIPELINE type

**Changes**:

```typescript
// Determine enhancement type based on request parameters:
const enhancementType: EnhancementType = isBlend
  ? "BLEND"
  : pipelineId
  ? "PIPELINE"
  : wasCropped
  ? "AUTO_CROP"
  : "STANDARD";

await prisma.imageEnhancementJob.create({
  data: {
    ...otherFields,
    enhancementType,
  },
});
```

#### Step 4.2: Display Enhancement Type

**Files to modify**:

- `src/components/enhance/EnhancedImagesList.tsx` - Show type badge
- `src/app/apps/pixel/[imageId]/page.tsx` - Show type in job details
- `src/components/pixel/JobHistory.tsx` - Show type in job history

**Changes**:

- Add badge component: `<Badge variant="outline">{enhancementType}</Badge>`
- Different colors per type (standard=gray, blend=blue, pipeline=purple, auto_crop=green)

---

## Files to Create (New)

1. `src/lib/images/auto-tagger.ts`
2. `src/lib/images/auto-tagger.test.ts`
3. `src/lib/images/bulk-operations.ts`
4. `src/lib/images/bulk-operations.test.ts`
5. `src/app/api/gallery/public/route.ts`
6. `src/app/api/gallery/public/route.test.ts`
7. `src/app/api/pixel/library/route.ts`
8. `src/app/api/pixel/library/route.test.ts`
9. `src/app/api/pixel/tags/route.ts`
10. `src/app/api/pixel/tags/route.test.ts`
11. `src/app/gallery/page.tsx`
12. `src/app/gallery/GalleryClient.tsx`
13. `src/app/apps/pixel/library/page.tsx`
14. `src/app/apps/pixel/library/LibraryClient.tsx`
15. `src/components/gallery/GalleryGrid.tsx`
16. `src/components/gallery/GalleryFilters.tsx`
17. `src/components/gallery/ImageModal.tsx`
18. `src/components/pixel/LibraryGrid.tsx`
19. `src/components/pixel/BulkActions.tsx`
20. `src/components/pixel/StorageIndicator.tsx`
21. `src/components/pixel/TagEditor.tsx`
22. `src/components/pixel/TagManager.tsx`
23. `e2e/features/public-gallery.feature`
24. `e2e/features/photo-library.feature`
25. `e2e/step-definitions/public-gallery.steps.ts`
26. `e2e/step-definitions/photo-library.steps.ts`

---

## Files to Modify (Existing)

1. `prisma/schema.prisma` - Add tags, enhancementType, indexes
2. `src/workflows/enhance-image.direct.ts` - Auto-tag on completion
3. `src/app/api/enhance/route.ts` - Set enhancement type
4. `src/components/landing/BeforeAfterGallery.tsx` - Link to public gallery
5. `src/app/pixel/page.tsx` - Featured gallery section
6. `src/components/enhance/EnhancedImagesList.tsx` - Show enhancement type badges
7. `src/app/apps/pixel/[imageId]/page.tsx` - Show type and edit tags
8. `src/app/apps/pixel/page.tsx` - Add navigation to library view
9. `src/app/apps/pixel/mix/[jobId]/page.tsx` - Set BLEND type
10. `src/app/apps/pixel/pipelines/page.tsx` - Set PIPELINE type
11. `src/lib/gallery/super-admin-photos.ts` - Optionally include tags in response

---

## Testing Strategy

### Unit Tests (100% Coverage Required)

- Auto-tagger: Tag extraction logic, edge cases
- Bulk operations: Delete, tag updates, validation
- API routes: All endpoints with success/error cases
- Component logic: Filter state, selection state

### E2E Tests (Cucumber)

**Feature: Public Gallery Browsing**

```gherkin
Scenario: View public gallery
  Given I visit "/gallery"
  Then I should see a grid of public images
  When I filter by tag "landscape"
  Then I should only see images tagged "landscape"
```

**Feature: Photo Library Management**

```gherkin
Scenario: Bulk delete photos
  Given I am logged in as a user with photos
  When I visit "/apps/pixel/library"
  And I select 3 images
  And I click "Delete Selected"
  Then I should see a confirmation dialog
  When I confirm deletion
  Then those 3 images should be deleted
```

### Integration Tests

- Test auto-tagging on actual enhancement completion
- Test tag-based filtering with real database
- Test pagination with large datasets (>100 images)

---

## Edge Cases & Considerations

### Auto-Tagging

- **Empty analysis**: Handle images with no analysis data (skip tagging)
- **Tag limits**: Cap at 15 tags per image to avoid UI clutter
- **Tag normalization**: Lowercase, trim whitespace, remove duplicates
- **Profanity filter**: Filter inappropriate tags from AI analysis

### Public Gallery

- **NSFW content**: Respect `isPublic` flag, consider adding NSFW flag in future
- **Attribution**: Show photographer name (optional, user setting)
- **Copyright**: Only show images where user granted public display rights
- **Performance**: Implement CDN caching for image URLs

### Photo Library

- **Storage limits**: Calculate total storage used, show warning at 80%
- **Deletion confirmation**: Require explicit confirmation for bulk deletes >10 images
- **Permanent deletion**: Soft delete first (30 days), then hard delete
- **Export**: Allow JSON/CSV export of metadata (GDPR compliance)

### Enhancement Type

- **Backward compatibility**: Existing jobs default to STANDARD type
- **Migration**: No data migration needed, defaults handle old records
- **UI consistency**: Use consistent badge styling across all views

---

## Performance Optimization

### Database Queries

- Add indexes: `[isPublic, createdAt]`, `[tags]`, `[userId, createdAt]`
- Use cursor-based pagination for large datasets (future)
- Limit includes to necessary relations only

### Caching

- Public gallery: 5 min cache, 10 min stale-while-revalidate
- User library: No cache (personalized data)
- Tag autocomplete: 1 hour cache

### Image Loading

- Use Next.js Image component for optimization
- Lazy load below-the-fold images
- Progressive JPEG/WebP format
- CDN URLs from R2 storage

---

## Security Considerations

### Privacy

- Respect `isPublic` flag strictly
- Only show public images in `/gallery`
- Require authentication for library and bulk operations
- No public API for private images

### Authorization

- Library endpoints: Check `session.user.id === image.userId`
- Bulk operations: Verify ownership of all selected images
- Tag editing: Only owner can edit image tags

### Input Validation

- Sanitize tag input (max length, allowed characters)
- Validate search queries (prevent injection)
- Limit bulk operation size (max 100 images at once)

---

## Documentation Updates

After implementation, update:

1. `docs/FEATURES.md` - Add public gallery and library sections
2. `docs/USER_GUIDE.md` - User guide for new features
3. `docs/API_REFERENCE.md` - Document new API endpoints
4. `docs/DATABASE_SCHEMA.md` - Regenerate with new fields
5. `README.md` - Update feature list

---

## Rollout Strategy

### Phase 1: Backend Foundation (Week 1)

- Database migration
- Auto-tagging service
- Update enhancement workflow
- Deploy to staging, test thoroughly

### Phase 2: Public Gallery (Week 2)

- API endpoint
- Public gallery page
- Update landing page
- Deploy to production with feature flag

### Phase 3: Photo Library (Week 3)

- Library API and UI
- Tag management
- Bulk operations
- Deploy to production

### Phase 4: Enhancement Type & Polish (Week 4)

- Enhancement type tracking
- UI badges and displays
- Performance optimization
- Documentation
- Full rollout (remove feature flags)

---

## Success Metrics

### Adoption

- Track `/gallery` page views
- Monitor public image count growth
- Measure user engagement (time on gallery page)

### Usage

- Auto-tags generated per day
- Library searches per user
- Bulk operations performed
- Tag filter usage

### Performance

- Public gallery API response time (<200ms p95)
- Library search response time (<300ms p95)
- Auto-tag generation time (<2s per image)

---

## Risks & Mitigation

### Risk: Auto-tags are low quality

**Mitigation**:

- Manual review of first 100 auto-tagged images
- Allow users to edit/remove tags
- Implement tag reporting/feedback system

### Risk: Public gallery becomes spam-filled

**Mitigation**:

- Manual approval queue for first-time public images (future)
- Report/flag system for inappropriate content
- Admin moderation tools

### Risk: Storage costs increase significantly

**Mitigation**:

- Implement storage quotas per user/tier
- Add cleanup job for old unused images
- Compress thumbnails aggressively

### Risk: Performance degrades with large tag datasets

**Mitigation**:

- Database indexes on tags array
- Limit tag filter combinations (max 5 tags)
- Use full-text search for complex queries (future)

---

## Future Enhancements (Out of Scope for #704)

1. **AI-powered search**: Semantic search using embeddings ("find sunset photos")
2. **Collections**: User-curated collections (like Pinterest boards)
3. **Social features**: Comments, likes, follows
4. **Advanced filters**: Color palette, aspect ratio, date range
5. **Tag suggestions**: ML-based tag recommendations as user types
6. **Export options**: Bulk download, slideshow, PDF gallery
7. **Analytics**: View counts, popular tags, trending images

---

## Conclusion

This plan implements all requirements from issue #704:

- ✅ Load real images to public pages (expand existing functionality)
- ✅ Public gallery browser (new `/gallery` page)
- ✅ Auto-tagging (extract from existing AI analysis)
- ✅ Save enhancement types (new `enhancementType` field)
- ✅ Photo inventory (new `/apps/pixel/library` feature)

**Estimated Effort**: 3-4 weeks for complete implementation with tests and documentation.

**Dependencies**: None - uses existing authentication, storage, and AI analysis infrastructure.

**Breaking Changes**: None - all changes are additive with sensible defaults.

# Implementation Plan: #920 - Ralph Script Issues

## Summary

Fix two critical issues in the Ralph worktree orchestration system:

1. **ENOENT errors** when syncing non-existent or corrupted worktrees with main
2. **Branch conflict errors** when acquiring warm worktrees due to stale branches from previous runs

## Root Cause Analysis

### Issue 1: ENOENT in syncWorktreeWithMain

**Location**: `scripts/ralph-local/worktree-manager.ts:221-341`

**Problem**: The `syncWorktreeWithMain` function attempts to execute git commands in worktree directories without first validating that:

- The worktree directory exists
- The worktree is a valid git directory
- The worktree is registered in git's worktree list

When `execSync` tries to spawn a shell (`/bin/sh`) with `cwd` pointing to a non-existent directory, Node.js fails with `ENOENT` (Error NO ENTry).

**Current Flow**:

```
orchestrator.ts:929 ‚Üí syncWorktreeWithMain(worktree)
  ‚Üí execSync("git pull", { cwd: worktree })
  ‚Üí ENOENT if worktree doesn't exist
```

**Impact**: The orchestrator attempts to sync all worktrees including:

- Deleted worktrees that still appear in git worktree list
- Corrupted worktrees with missing directories
- Warm pool worktrees that were force-removed

### Issue 2: Branch Conflict in acquireFromPool

**Location**: `scripts/ralph-local/worktree-pool.ts:576-693`

**Problem**: When acquiring a warm worktree for ticket #533:

1. Function attempts to delete existing `ralph/533` branch (lines 606-616)
2. Function renames `ralph/pool-1` to `ralph/533` (line 634)
3. If step 1 fails or is skipped (e.g., due to exception), step 2 fails with "branch already exists"

**Current Cleanup Logic Issues**:

- Cleanup of target branch is inside the try block but BEFORE the rename
- If any previous operation in the try block fails, cleanup never runs
- Subsequent retry attempts fail because cleanup didn't run
- The function doesn't check if the target branch exists before attempting rename

**Example Failure Sequence**:

```
Run 1: acquireFromPool("#533")
  ‚Üí Cleanup target path succeeds (lines 619-631)
  ‚Üí Delete ralph/533 branch - FAILS (git error, branch locked)
  ‚Üí Rename ralph/pool-1 ‚Üí ralph/533 - FAILS (branch exists)
  ‚Üí Cleanup code runs (lines 673-689), but ralph/533 still exists

Run 2: acquireFromPool("#533")
  ‚Üí Cleanup target path succeeds
  ‚Üí Delete ralph/533 branch - still locked/exists
  ‚Üí Rename ralph/pool-1 ‚Üí ralph/533 - FAILS AGAIN
```

## Files to Modify

### 1. `scripts/ralph-local/worktree-manager.ts`

**Changes in `syncWorktreeWithMain` function (lines 221-341)**:

- **Add validation at start**: Check directory existence and git validity BEFORE any git operations
  - Use `existsSync(worktreePath)`
  - Use `existsSync(join(worktreePath, ".git"))`
  - Return early with descriptive error if invalid

- **Add worktree registration check**: Verify worktree is in git's worktree list
  - Use `execSync("git worktree list --porcelain")` to get registered worktrees
  - Return early if worktree is not registered (stale/orphaned directory)

- **Improve error messages**: Include worktree path in all error messages for debugging

**Specific code changes**:

```typescript
export function syncWorktreeWithMain(
  worktreePath: string,
): { success: boolean; conflict: boolean; message: string; } {
  console.log(`   üîÑ Syncing worktree with main...`);

  // NEW: Validate directory exists
  if (!existsSync(worktreePath)) {
    console.log(`   ‚ö†Ô∏è Worktree directory doesn't exist, skipping: ${worktreePath}`);
    return { success: false, conflict: false, message: "Worktree directory does not exist" };
  }

  // NEW: Validate it's a valid git directory
  const gitPath = join(worktreePath, ".git");
  if (!existsSync(gitPath)) {
    console.log(`   ‚ö†Ô∏è Not a valid git worktree, skipping: ${worktreePath}`);
    return { success: false, conflict: false, message: "Not a valid git worktree" };
  }

  // EXISTING: Rest of the sync logic...
  try {
    // ... existing sync code
  } catch (error) {
    // ... existing error handling
  }
}
```

### 2. `scripts/ralph-local/worktree-pool.ts`

**Changes in `acquireFromPool` function (lines 576-693)**:

- **Move branch cleanup outside try block**: Execute branch deletion BEFORE any operations that could fail
  - Move lines 606-616 (delete ticket branch) to BEFORE the main try block
  - Use separate try-catch for branch deletion to ensure it doesn't block the rest

- **Add forced branch deletion**: Use `-D` flag consistently and add `--force` option if needed
  - Change from `git branch -D` to more aggressive cleanup

- **Add validation before rename**: Check that pool branch exists and ticket branch does NOT exist
  - Use `git branch --list 'ralph/533'` to check existence
  - Log detailed state before rename operation

- **Improve cleanup on failure**: Ensure both branch AND directory are cleaned up on any failure
  - Current cleanup (lines 673-689) is good, but needs to also check for orphaned branches
  - Add `git branch -D ${ticketBranchName}` in cleanup block

**Specific code changes**:

```typescript
export function acquireFromPool(ticketId: string, config: RalphLocalConfig): string | null {
  // ... validation code ...

  const poolIndex = parseInt(indexMatch[1], 10);
  const poolBranchName = `ralph/pool-${poolIndex}`;
  const ticketBranchName = `ralph/${ticketNum}`;
  const targetPath = join(config.worktreeBase, ticketNum);

  console.log(`   ‚ö° Acquiring warm worktree ${poolIndex} for ${ticketId}`);

  // MOVED OUTSIDE TRY: Clean up ticket branch FIRST (before any other operations)
  try {
    execSync(`git branch -D ${ticketBranchName}`, {
      cwd: config.workDir,
      encoding: "utf-8",
      timeout: 30000,
      stdio: "pipe",
    });
    console.log(`   üßπ Cleaned up existing branch ${ticketBranchName}`);
  } catch {
    // Branch doesn't exist - that's fine and expected
  }

  // EXISTING: Clean up target path if exists
  if (existsSync(targetPath)) {
    try {
      execSync(`git worktree remove "${targetPath}" --force`, {
        cwd: config.workDir,
        encoding: "utf-8",
        timeout: 30000,
        stdio: "pipe",
      });
    } catch {
      rmSync(targetPath, { recursive: true, force: true });
    }
  }

  try {
    // NOW: Rename branch (ticket branch guaranteed not to exist)
    execSync(`git branch -m ${poolBranchName} ${ticketBranchName}`, {
      cwd: warmPath,
      encoding: "utf-8",
      timeout: 30000,
      stdio: "pipe",
    });

    // ... rest of existing logic ...
  } catch (error) {
    const acquireErrMsg = error instanceof Error ? error.message : String(error);
    console.error(`   ‚ùå Failed to acquire warm worktree: ${acquireErrMsg.trim()}`);

    // IMPROVED: Enhanced cleanup - also remove any created branches
    try {
      // Clean up both directory paths
      if (existsSync(warmPath)) {
        rmSync(warmPath, { recursive: true, force: true });
      }
      if (existsSync(targetPath)) {
        rmSync(targetPath, { recursive: true, force: true });
      }

      // Clean up ticket branch (might have been created)
      try {
        execSync(`git branch -D ${ticketBranchName}`, {
          cwd: config.workDir,
          encoding: "utf-8",
          timeout: 30000,
          stdio: "pipe",
        });
      } catch {
        // Branch might not exist
      }

      // Prune worktree registry
      execSync("git worktree prune", {
        cwd: config.workDir,
        encoding: "utf-8",
        timeout: 30000,
        stdio: "pipe",
      });
    } catch {
      // Ignore cleanup errors
    }

    return null;
  }
}
```

### 3. `scripts/ralph-local/orchestrator.ts` (optional enhancement)

**Changes in worktree sync orchestration (around line 929)**:

- **Add worktree validation**: Before syncing, validate that worktrees are still valid
  - Use `git worktree list --porcelain` to get current valid worktrees
  - Only sync worktrees that are in the valid list
  - This prevents attempting to sync orphaned/deleted worktrees

**Specific code changes**:

```typescript
// Around line 920-934
const warmCount = warmWorktrees.length;
const activeCount = allWorktrees.size - warmCount;
console.log(
  `   Syncing ${allWorktrees.size} worktrees with main (${activeCount} active, ${warmCount} warm)`,
);

// NEW: Get list of valid registered worktrees
const registeredWorktrees = new Set<string>();
try {
  const worktreeListOutput = execSync("git worktree list --porcelain", {
    cwd: config.workDir,
    encoding: "utf-8",
    timeout: 30000,
  });

  const lines = worktreeListOutput.split("\n");
  for (const line of lines) {
    if (line.startsWith("worktree ")) {
      const path = line.replace("worktree ", "").trim();
      registeredWorktrees.add(path);
    }
  }
} catch (error) {
  console.error("Failed to get worktree list, skipping validation");
}

for (const worktree of Array.from(allWorktrees)) {
  // NEW: Skip if not in registered worktrees
  if (registeredWorktrees.size > 0 && !registeredWorktrees.has(worktree)) {
    console.log(`   ‚ö†Ô∏è Skipping unregistered worktree: ${worktree}`);
    continue;
  }

  const result = syncWorktreeWithMain(worktree);
  if (!result.success) {
    console.log(`   ‚ö†Ô∏è Sync failed for ${worktree}: ${result.message}`);
  }
}
```

## Testing Considerations

### Manual Testing Steps

1. **Test ENOENT fix**:
   - Create a worktree, then manually delete its directory (without git worktree remove)
   - Run orchestrator and verify it skips the missing worktree without ENOENT error
   - Check logs show "Worktree directory doesn't exist, skipping"

2. **Test branch conflict fix**:
   - Create a branch `ralph/999` manually
   - Run orchestrator and assign issue #999 to developer
   - Verify the existing branch is cleaned up before rename
   - Verify no "branch already exists" error

3. **Test recovery scenarios**:
   - Simulate a failed acquisition (kill process mid-acquisition)
   - Verify subsequent runs clean up properly
   - Verify no orphaned branches or directories

### Automated Testing

Add test cases to `scripts/ralph-local/__tests__/worktree-pool.test.ts`:

```typescript
describe("acquireFromPool edge cases", () => {
  it("should clean up existing ticket branch before rename", () => {
    // Create a stale ralph/123 branch
    // Call acquireFromPool("#123", config)
    // Verify no error, branch renamed successfully
  });

  it("should handle ENOENT when worktree directory missing", () => {
    // Delete a worktree directory
    // Call syncWorktreeWithMain
    // Verify returns {success: false} without throwing
  });
});
```

## Potential Risks

1. **Race conditions**: If multiple orchestrator instances run simultaneously, branch cleanup could interfere
   - Mitigation: Already documented that only one orchestrator should run (lock file exists)

2. **Data loss**: Aggressive cleanup could delete work-in-progress branches
   - Mitigation: Only cleans up `ralph/*` prefixed branches, which are managed by Ralph
   - Only cleans up when acquisition fails (nothing to lose)

3. **Performance**: Additional validation checks add overhead to sync operation
   - Mitigation: Checks are fast (filesystem and git commands with small output)
   - Only affects invalid worktrees (which would fail anyway)

## Implementation Complexity

**Simple** - This is primarily defensive coding and error handling improvements:

- Add validation checks before operations
- Reorder operations to prevent conflicts
- Improve cleanup on failures
- No new features, just making existing code more robust

## Success Criteria

After implementation:

- ‚úÖ No more `spawnSync /bin/sh ENOENT` errors in orchestrator logs
- ‚úÖ No more `fatal: a branch named 'ralph/XXX' already exists` errors
- ‚úÖ Worktrees with missing directories are skipped gracefully
- ‚úÖ Failed acquisitions are cleaned up completely (no orphaned branches/directories)
- ‚úÖ Orchestrator can recover from interrupted operations on restart

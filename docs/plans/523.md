# Implementation Plan: TikTok Integration

**Issue**: #523
**Story**: ORB-051: Add TikTok integration
**Epic**: #518 (Platform Integration)
**Phase**: 4 (Scale)
**Layer**: 1 (Dashboard)
**Priority**: Story

## Executive Summary

Implement full TikTok integration following the established pattern from existing social platform integrations (YouTube, Twitter, Facebook, LinkedIn, Instagram). This includes OAuth 2.0 authentication, video posting capabilities, analytics collection, trend monitoring, and rate limiting.

**Complexity**: Medium
**Estimated Effort**: 3-4 days
**Risk Level**: Medium (TikTok API has strict rate limits and complex OAuth flow)

## Current State Analysis

### ✅ Already Implemented (Foundation)

1. **Database Models** (100% Complete)
   - `SocialAccount` model with `TIKTOK` enum value
   - `SocialPlatform` enum includes `TIKTOK`
   - Encrypted token storage infrastructure
   - Account health monitoring system
   - Social metrics tracking models

2. **Integration Patterns** (Reference Implementations)
   - YouTube OAuth 2.0 flow (src/lib/social/clients/youtube.ts)
   - Twitter/Facebook posting patterns
   - Token refresh handling (src/lib/social/token-refresh.ts)
   - ISocialClient interface (src/lib/social/types.ts)

3. **Infrastructure** (100% Complete)
   - Workspace permissions system
   - Token encryption utilities
   - API route patterns for connect/callback
   - Social account health monitoring

### ❌ Missing Pieces (To Implement)

1. **TikTok Client Implementation** (Critical)
   - OAuth 2.0 flow (Login Kit)
   - Video posting API integration
   - Analytics API integration
   - Trend monitoring API
   - Rate limiting implementation

2. **API Routes** (Critical)
   - Connect route (initiate OAuth)
   - Callback route (handle OAuth response)
   - Metrics collection endpoint

3. **UI Integration** (Important)
   - Add TikTok to platform capabilities
   - Account connection UI
   - Platform-specific icons/branding

4. **Testing** (Important)
   - Unit tests for TikTok client
   - E2E tests for OAuth flow
   - API integration tests

## Technical Background

### TikTok API Architecture

TikTok provides **two separate APIs**:

1. **TikTok Login Kit** (Consumer API)
   - For creator accounts and general users
   - OAuth 2.0 with authorization code flow
   - Endpoints: `/oauth/authorize/`, `/oauth/access_token/`
   - Scopes: `user.info.basic`, `video.list`, `video.upload`

2. **TikTok Marketing API** (Business API)
   - For business accounts with advertising access
   - Requires TikTok Business Center account
   - More comprehensive analytics and management
   - Higher rate limits

**Recommendation**: Implement Login Kit first (broader user base), add Marketing API support later.

### OAuth 2.0 Flow

```
1. User clicks "Connect TikTok" → /api/social/tiktok/connect
2. Generate CSRF state + PKCE challenge (optional)
3. Redirect to https://www.tiktok.com/v2/auth/authorize/
4. User authorizes → TikTok redirects to /api/social/tiktok/callback
5. Exchange code for access token → /v2/oauth/token/
6. Get user info → /v2/user/info/
7. Store encrypted tokens in database
```

### Required Environment Variables

```bash
TIKTOK_CLIENT_KEY=<from TikTok Developer Portal>
TIKTOK_CLIENT_SECRET=<from TikTok Developer Portal>
TIKTOK_CALLBACK_URL=https://spike.land/api/social/tiktok/callback
```

### Rate Limits (Login Kit)

- **OAuth endpoints**: No documented limit
- **User info API**: 100 requests per day
- **Video list API**: 100 requests per day
- **Video upload API**: 24 uploads per day per user

**Strategy**: Implement aggressive caching + request batching + retry logic with exponential backoff.

## Implementation Plan

### Story 1: TikTok OAuth 2.0 Client Implementation

**Complexity**: Medium
**Effort**: 1.5 days
**Priority**: Critical (Blocker for all other features)

#### Files to Create

```
src/lib/social/clients/tiktok.ts (NEW) - Main TikTok client implementing ISocialClient
src/lib/social/clients/tiktok.test.ts (NEW) - Unit tests
```

#### Implementation Details

**src/lib/social/clients/tiktok.ts**

```typescript
/**
 * TikTok Login Kit Client
 *
 * Implements ISocialClient interface for TikTok OAuth 2.0 and API operations
 * API Reference: https://developers.tiktok.com/doc/login-kit-web
 */

import type {
  ISocialClient,
  OAuthTokenResponse,
  PostOptions,
  PostResult,
  SocialAccountInfo,
  SocialClientOptions,
  SocialMetricsData,
  SocialPost,
} from "../types";

// TikTok API endpoints
const TIKTOK_OAUTH_BASE = "https://www.tiktok.com/v2/auth";
const TIKTOK_API_BASE = "https://open.tiktokapis.com/v2";

// Required scopes for full integration
const TIKTOK_SCOPES = [
  "user.info.basic", // Get user profile
  "user.info.stats", // Get follower/following counts
  "video.list", // List user's videos
  "video.publish", // Upload videos
  "video.upload", // Upload capability
].join(",");

export interface TikTokUser {
  open_id: string;
  union_id: string;
  display_name: string;
  avatar_url: string;
  profile_deep_link: string;
  follower_count: number;
  following_count: number;
  video_count: number;
}

export interface TikTokVideo {
  id: string;
  title: string;
  cover_image_url: string;
  share_url: string;
  create_time: number;
  duration: number;
  view_count: number;
  like_count: number;
  comment_count: number;
  share_count: number;
}

export class TikTokClient implements ISocialClient {
  readonly platform = "TIKTOK" as const;

  private accessToken?: string;
  private openId?: string;

  constructor(options?: SocialClientOptions) {
    this.accessToken = options?.accessToken;
    this.openId = options?.accountId;
  }

  /**
   * Generate TikTok OAuth 2.0 authorization URL
   */
  getAuthUrl(redirectUri: string, state: string, codeChallenge?: string): string {
    const clientKey = process.env.TIKTOK_CLIENT_KEY;

    if (!clientKey) {
      throw new Error("TIKTOK_CLIENT_KEY environment variable is not configured");
    }

    const params = new URLSearchParams({
      client_key: clientKey,
      redirect_uri: redirectUri,
      response_type: "code",
      scope: TIKTOK_SCOPES,
      state,
    });

    // Add PKCE if provided (recommended for security)
    if (codeChallenge) {
      params.append("code_challenge", codeChallenge);
      params.append("code_challenge_method", "S256");
    }

    return `${TIKTOK_OAUTH_BASE}/authorize/?${params.toString()}`;
  }

  /**
   * Exchange authorization code for access and refresh tokens
   */
  async exchangeCodeForTokens(
    code: string,
    redirectUri: string,
    codeVerifier?: string,
  ): Promise<OAuthTokenResponse> {
    const clientKey = process.env.TIKTOK_CLIENT_KEY;
    const clientSecret = process.env.TIKTOK_CLIENT_SECRET;

    if (!clientKey || !clientSecret) {
      throw new Error("TikTok OAuth credentials not configured");
    }

    const body = {
      client_key: clientKey,
      client_secret: clientSecret,
      code,
      grant_type: "authorization_code",
      redirect_uri: redirectUri,
      ...(codeVerifier && { code_verifier: codeVerifier }),
    };

    const response = await fetch(`${TIKTOK_API_BASE}/oauth/token/`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(
        `TikTok token exchange failed: ${errorData.error_description || response.statusText}`,
      );
    }

    const data = await response.json();

    this.accessToken = data.access_token;
    this.openId = data.open_id;

    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token,
      expiresAt: data.expires_in
        ? new Date(Date.now() + data.expires_in * 1000)
        : undefined,
      tokenType: data.token_type || "Bearer",
      scope: data.scope,
    };
  }

  /**
   * Refresh an expired access token
   */
  async refreshAccessToken(refreshToken: string): Promise<OAuthTokenResponse> {
    const clientKey = process.env.TIKTOK_CLIENT_KEY;
    const clientSecret = process.env.TIKTOK_CLIENT_SECRET;

    if (!clientKey || !clientSecret) {
      throw new Error("TikTok OAuth credentials not configured");
    }

    const body = {
      client_key: clientKey,
      client_secret: clientSecret,
      grant_type: "refresh_token",
      refresh_token: refreshToken,
    };

    const response = await fetch(`${TIKTOK_API_BASE}/oauth/token/`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(
        `TikTok token refresh failed: ${errorData.error_description || response.statusText}`,
      );
    }

    const data = await response.json();

    this.accessToken = data.access_token;

    return {
      accessToken: data.access_token,
      refreshToken: data.refresh_token || refreshToken,
      expiresAt: data.expires_in
        ? new Date(Date.now() + data.expires_in * 1000)
        : undefined,
      tokenType: data.token_type || "Bearer",
      scope: data.scope,
    };
  }

  /**
   * Get the authenticated user's TikTok account information
   */
  async getAccountInfo(): Promise<SocialAccountInfo> {
    const token = this.getAccessTokenOrThrow();

    const response = await fetch(
      `${TIKTOK_API_BASE}/user/info/?fields=open_id,union_id,avatar_url,display_name,follower_count,following_count,video_count,profile_deep_link`,
      {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      },
    );

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(
        `Failed to get TikTok user info: ${errorData.error?.message || response.statusText}`,
      );
    }

    const data = await response.json();
    const user = data.data.user as TikTokUser;

    this.openId = user.open_id;

    return {
      platformId: user.open_id,
      username: user.display_name,
      displayName: user.display_name,
      profileUrl: user.profile_deep_link,
      avatarUrl: user.avatar_url,
      followersCount: user.follower_count,
      followingCount: user.following_count,
    };
  }

  /**
   * Create a post (upload video to TikTok)
   *
   * Note: TikTok video upload is a multi-step process:
   * 1. Initialize upload
   * 2. Upload video chunks
   * 3. Publish video with metadata
   */
  async createPost(content: string, options?: PostOptions): Promise<PostResult> {
    const token = this.getAccessTokenOrThrow();

    // TikTok requires video upload, not just text
    if (!options?.mediaUrls || options.mediaUrls.length === 0) {
      throw new Error("TikTok requires at least one video to post");
    }

    // Validate video format (MP4)
    const videoUrl = options.mediaUrls[0];
    if (!videoUrl.toLowerCase().endsWith(".mp4")) {
      throw new Error("TikTok only supports MP4 video format");
    }

    // Step 1: Initialize video upload
    const initResponse = await fetch(`${TIKTOK_API_BASE}/post/publish/video/init/`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        post_info: {
          title: content.substring(0, 150), // TikTok max caption: 150 chars
          privacy_level: "PUBLIC_TO_EVERYONE",
          disable_duet: false,
          disable_comment: false,
          disable_stitch: false,
          video_cover_timestamp_ms: 1000,
        },
        source_info: {
          source: "FILE_UPLOAD",
          video_size: options.metadata?.videoSize || 0,
          chunk_size: 10 * 1024 * 1024, // 10MB chunks
          total_chunk_count: 1,
        },
      }),
    });

    if (!initResponse.ok) {
      const errorData = await initResponse.json().catch(() => ({}));
      throw new Error(
        `TikTok video upload init failed: ${errorData.error?.message || initResponse.statusText}`,
      );
    }

    const initData = await initResponse.json();
    const publishId = initData.data.publish_id;
    const uploadUrl = initData.data.upload_url;

    // Step 2: Upload video (simplified - assumes single chunk)
    // In production, implement chunked upload for large files
    const videoBlob = await fetch(videoUrl).then(r => r.blob());

    const uploadResponse = await fetch(uploadUrl, {
      method: "PUT",
      headers: {
        "Content-Type": "video/mp4",
      },
      body: videoBlob,
    });

    if (!uploadResponse.ok) {
      throw new Error(`TikTok video upload failed: ${uploadResponse.statusText}`);
    }

    // Step 3: Publish video
    const publishResponse = await fetch(`${TIKTOK_API_BASE}/post/publish/status/fetch/`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        publish_id: publishId,
      }),
    });

    if (!publishResponse.ok) {
      const errorData = await publishResponse.json().catch(() => ({}));
      throw new Error(
        `TikTok video publish failed: ${errorData.error?.message || publishResponse.statusText}`,
      );
    }

    const publishData = await publishResponse.json();

    return {
      platformPostId: publishData.data.video_id || publishId,
      url: publishData.data.share_url || `https://www.tiktok.com/@${this.openId}`,
      publishedAt: new Date(),
    };
  }

  /**
   * Get the user's recent TikTok videos
   */
  async getPosts(limit = 10): Promise<SocialPost[]> {
    const token = this.getAccessTokenOrThrow();

    const params = new URLSearchParams({
      fields:
        "id,title,cover_image_url,share_url,create_time,duration,view_count,like_count,comment_count,share_count",
      max_count: Math.min(limit, 20).toString(), // TikTok max: 20 per request
    });

    const response = await fetch(`${TIKTOK_API_BASE}/video/list/?${params.toString()}`, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(
        `Failed to get TikTok videos: ${errorData.error?.message || response.statusText}`,
      );
    }

    const data = await response.json();
    const videos = (data.data.videos || []) as TikTokVideo[];

    return videos.map((video) => ({
      id: video.id,
      platformPostId: video.id,
      platform: "TIKTOK" as const,
      content: video.title,
      mediaUrls: [video.cover_image_url],
      publishedAt: new Date(video.create_time * 1000),
      url: video.share_url,
      metrics: {
        likes: video.like_count,
        comments: video.comment_count,
        shares: video.share_count,
        impressions: video.view_count,
      },
      rawData: video as unknown as Record<string, unknown>,
    }));
  }

  /**
   * Get account-level metrics
   */
  async getMetrics(): Promise<SocialMetricsData> {
    // Re-fetch user info for latest metrics
    const accountInfo = await this.getAccountInfo();

    return {
      followers: accountInfo.followersCount || 0,
      following: accountInfo.followingCount || 0,
      postsCount: 0, // Not available in basic user info
      // TikTok doesn't provide engagement rate in Login Kit
    };
  }

  private getAccessTokenOrThrow(): string {
    if (!this.accessToken) {
      throw new Error("Access token is required. Call exchangeCodeForTokens first.");
    }
    return this.accessToken;
  }
}
```

**Key Implementation Notes**:

1. **Video Upload Complexity**: TikTok requires a 3-step upload process (init, upload chunks, publish)
2. **Rate Limiting**: Must implement aggressive caching - only 100 API calls/day for user info
3. **PKCE Support**: Optional but recommended for OAuth security
4. **Video Validation**: Enforce MP4 format, max 60s duration (3min for extended)

#### Testing Requirements

```
src/lib/social/clients/tiktok.test.ts
- Mock TikTok API responses
- Test OAuth flow (getAuthUrl, exchangeCodeForTokens, refreshAccessToken)
- Test user info retrieval
- Test video upload flow (mock blob upload)
- Test rate limit error handling
- Test token expiration scenarios
```

**Acceptance Criteria**:

- ✅ OAuth 2.0 flow with PKCE support
- ✅ Token refresh handling
- ✅ User account info retrieval
- ✅ Video upload (3-step process)
- ✅ Video listing with metrics
- ✅ Account-level metrics
- ✅ 100% unit test coverage

---

### Story 2: API Routes for OAuth Flow

**Complexity**: Simple
**Effort**: 0.5 day
**Priority**: Critical

#### Files to Create

```
src/app/api/social/tiktok/connect/route.ts (NEW)
src/app/api/social/tiktok/callback/route.ts (NEW)
```

#### Implementation Details

Follow the exact pattern from `youtube/connect/route.ts` and `youtube/callback/route.ts`:

**src/app/api/social/tiktok/connect/route.ts**

```typescript
/**
 * TikTok OAuth 2.0 Connect Route
 *
 * Initiates TikTok OAuth flow with PKCE
 * GET /api/social/tiktok/connect?workspaceId=xxx&workspaceSlug=xxx
 */

import { auth } from "@/auth";
import { requireWorkspacePermission } from "@/lib/permissions/workspace-middleware";
import { generatePKCE } from "@/lib/social";
import { TikTokClient } from "@/lib/social/clients/tiktok";
import { tryCatch } from "@/lib/try-catch";
import crypto from "crypto";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";

export async function GET(request: NextRequest): Promise<NextResponse> {
  // 1. Authenticate user
  const { data: session, error: authError } = await tryCatch(auth());

  if (authError || !session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  // 2. Validate query params
  const searchParams = request.nextUrl.searchParams;
  const workspaceId = searchParams.get("workspaceId");
  const workspaceSlug = searchParams.get("workspaceSlug");

  if (!workspaceId || !workspaceSlug) {
    return NextResponse.json(
      { error: "workspaceId and workspaceSlug are required" },
      { status: 400 },
    );
  }

  // 3. Check permissions
  const { error: permError } = await tryCatch(
    requireWorkspacePermission(session, workspaceId, "social:connect"),
  );

  if (permError) {
    const status = permError.message.includes("Unauthorized") ? 401 : 403;
    return NextResponse.json({ error: permError.message }, { status });
  }

  // 4. Generate PKCE challenge
  const { codeVerifier, codeChallenge } = await generatePKCE();

  // 5. Generate CSRF state
  const nonce = crypto.randomBytes(16).toString("hex");
  const state = Buffer.from(
    JSON.stringify({
      userId: session.user.id,
      workspaceId,
      workspaceSlug,
      timestamp: Date.now(),
      nonce,
    }),
  ).toString("base64url");

  // 6. Build redirect URI
  const redirectUri = process.env.TIKTOK_CALLBACK_URL || (() => {
    const baseUrl = process.env.NEXTAUTH_URL || process.env.VERCEL_URL || "http://localhost:3000";
    return `${
      baseUrl.startsWith("http") ? baseUrl : `https://${baseUrl}`
    }/api/social/tiktok/callback`;
  })();

  // 7. Get TikTok auth URL
  let authUrl: string;
  try {
    const client = new TikTokClient();
    authUrl = client.getAuthUrl(redirectUri, state, codeChallenge);
  } catch (error) {
    console.error("TikTok OAuth setup failed:", error);
    return NextResponse.json(
      {
        error: error instanceof Error
          ? error.message
          : "Failed to initialize TikTok OAuth",
      },
      { status: 500 },
    );
  }

  // 8. Store nonce and PKCE verifier in secure cookies
  const response = NextResponse.redirect(authUrl);

  response.cookies.set("tiktok_oauth_nonce", nonce, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "lax",
    maxAge: 600, // 10 minutes
    path: "/api/social/tiktok",
  });

  response.cookies.set("tiktok_code_verifier", codeVerifier, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "lax",
    maxAge: 600,
    path: "/api/social/tiktok",
  });

  return response;
}
```

**src/app/api/social/tiktok/callback/route.ts**

```typescript
/**
 * TikTok OAuth 2.0 Callback Route
 *
 * Handles OAuth callback, exchanges code for tokens, stores account
 * GET /api/social/tiktok/callback?code=xxx&state=xxx
 */

import { auth } from "@/auth";
import { safeEncryptToken } from "@/lib/crypto/token-encryption";
import prisma from "@/lib/prisma";
import { TikTokClient } from "@/lib/social/clients/tiktok";
import { tryCatch } from "@/lib/try-catch";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";

function buildRedirectUrl(
  baseUrl: string,
  workspaceSlug: string | undefined,
  queryParams: Record<string, string>,
): URL {
  const params = new URLSearchParams(queryParams);
  const path = workspaceSlug
    ? `/orbit/${workspaceSlug}/settings/accounts`
    : "/admin/social-media/accounts";
  return new URL(`${path}?${params.toString()}`, baseUrl);
}

export async function GET(request: NextRequest): Promise<NextResponse> {
  // 1. Authenticate
  const { data: session, error: authError } = await tryCatch(auth());

  if (authError || !session?.user?.id) {
    return NextResponse.redirect(
      new URL("/login?error=Unauthorized", request.url),
    );
  }

  // 2. Extract OAuth params
  const searchParams = request.nextUrl.searchParams;
  const code = searchParams.get("code");
  const state = searchParams.get("state");
  const error = searchParams.get("error");
  const errorDescription = searchParams.get("error_description");

  const clearOAuthCookies = (response: NextResponse): NextResponse => {
    response.cookies.delete("tiktok_oauth_nonce");
    response.cookies.delete("tiktok_code_verifier");
    return response;
  };

  // 3. Handle OAuth errors
  if (error) {
    console.error("TikTok OAuth error:", error, errorDescription);
    return clearOAuthCookies(
      NextResponse.redirect(
        new URL(
          `/admin/social-media/accounts?error=${encodeURIComponent(errorDescription || error)}`,
          request.url,
        ),
      ),
    );
  }

  if (!code || !state) {
    return clearOAuthCookies(
      NextResponse.redirect(
        new URL(
          "/admin/social-media/accounts?error=Invalid callback parameters",
          request.url,
        ),
      ),
    );
  }

  // 4. Verify state
  let stateData: {
    userId: string;
    workspaceId: string;
    workspaceSlug?: string;
    timestamp: number;
    nonce?: string;
  };

  try {
    stateData = JSON.parse(Buffer.from(state, "base64url").toString("utf-8"));
  } catch {
    return clearOAuthCookies(
      NextResponse.redirect(
        new URL(
          "/admin/social-media/accounts?error=Invalid state parameter",
          request.url,
        ),
      ),
    );
  }

  const redirect = (queryParams: Record<string, string>) =>
    buildRedirectUrl(request.url, stateData.workspaceSlug, queryParams);

  // 5. Verify user ID
  if (stateData.userId !== session.user.id) {
    return clearOAuthCookies(
      NextResponse.redirect(redirect({ error: "User mismatch" })),
    );
  }

  // 6. Verify timestamp
  if (Date.now() - stateData.timestamp > 10 * 60 * 1000) {
    return clearOAuthCookies(
      NextResponse.redirect(redirect({ error: "OAuth session expired" })),
    );
  }

  // 7. Verify nonce
  const storedNonce = request.cookies.get("tiktok_oauth_nonce")?.value;
  if (stateData.nonce && stateData.nonce !== storedNonce) {
    return clearOAuthCookies(
      NextResponse.redirect(redirect({ error: "Invalid security token" })),
    );
  }

  // 8. Get PKCE code verifier from cookie
  const codeVerifier = request.cookies.get("tiktok_code_verifier")?.value;

  // 9. Determine redirect URI
  const redirectUri = process.env.TIKTOK_CALLBACK_URL || (() => {
    const baseUrl = process.env.NEXTAUTH_URL || process.env.VERCEL_URL || "http://localhost:3000";
    return `${
      baseUrl.startsWith("http") ? baseUrl : `https://${baseUrl}`
    }/api/social/tiktok/callback`;
  })();

  // 10. Exchange code for tokens
  const client = new TikTokClient();
  const { data: tokens, error: tokenError } = await tryCatch(
    client.exchangeCodeForTokens(code, redirectUri, codeVerifier),
  );

  if (tokenError || !tokens) {
    console.error("TikTok token exchange failed:", tokenError);
    return clearOAuthCookies(
      NextResponse.redirect(
        redirect({ error: "Failed to connect TikTok account. Please try again." }),
      ),
    );
  }

  // 11. Get user info
  const { data: userInfo, error: userError } = await tryCatch(
    client.getAccountInfo(),
  );

  if (userError || !userInfo) {
    console.error("Failed to get TikTok user info:", userError);
    return clearOAuthCookies(
      NextResponse.redirect(
        redirect({ error: "Failed to retrieve TikTok account information." }),
      ),
    );
  }

  // 12. Encrypt tokens
  const encryptedAccessToken = safeEncryptToken(tokens.accessToken);
  const encryptedRefreshToken = tokens.refreshToken
    ? safeEncryptToken(tokens.refreshToken)
    : null;

  // 13. Save to database
  const { error: dbError } = await tryCatch(
    prisma.socialAccount.upsert({
      where: {
        workspaceId_platform_accountId: {
          workspaceId: stateData.workspaceId,
          platform: "TIKTOK",
          accountId: userInfo.platformId,
        },
      },
      update: {
        accountName: userInfo.displayName,
        accessTokenEncrypted: encryptedAccessToken,
        refreshTokenEncrypted: encryptedRefreshToken,
        tokenExpiresAt: tokens.expiresAt,
        status: "ACTIVE",
        connectedAt: new Date(),
        metadata: {
          username: userInfo.username,
          displayName: userInfo.displayName,
          avatarUrl: userInfo.avatarUrl,
          profileUrl: userInfo.profileUrl,
          followerCount: userInfo.followersCount,
        },
        updatedAt: new Date(),
      },
      create: {
        userId: session.user.id,
        workspaceId: stateData.workspaceId,
        platform: "TIKTOK",
        accountId: userInfo.platformId,
        accountName: userInfo.displayName,
        accessTokenEncrypted: encryptedAccessToken,
        refreshTokenEncrypted: encryptedRefreshToken,
        tokenExpiresAt: tokens.expiresAt,
        status: "ACTIVE",
        metadata: {
          username: userInfo.username,
          displayName: userInfo.displayName,
          avatarUrl: userInfo.avatarUrl,
          profileUrl: userInfo.profileUrl,
          followerCount: userInfo.followersCount,
        },
      },
    }),
  );

  if (dbError) {
    console.error("Database save failed:", dbError);
    return clearOAuthCookies(
      NextResponse.redirect(redirect({ error: "Failed to save account information." })),
    );
  }

  // 14. Success redirect
  return clearOAuthCookies(
    NextResponse.redirect(
      redirect({
        connected: "tiktok",
        accountName: userInfo.displayName,
        accountId: userInfo.platformId,
      }),
    ),
  );
}
```

**Acceptance Criteria**:

- ✅ Connect route initiates OAuth with PKCE
- ✅ Callback route validates state and nonce
- ✅ Tokens are encrypted before storage
- ✅ Workspace permissions are enforced
- ✅ Proper error handling and user feedback

---

### Story 3: Update Factory Function & Types

**Complexity**: Simple
**Effort**: 0.25 day
**Priority**: Critical

#### Files to Modify

```
src/lib/social/index.ts - Add TikTok case to createSocialClient
src/lib/social/types.ts - Update PLATFORM_CAPABILITIES for TikTok
```

**src/lib/social/index.ts** (add to switch statement around line 60):

```typescript
case "TIKTOK": {
  const { TikTokClient } = await import("./clients/tiktok");
  return new TikTokClient(options);
}
```

**src/lib/social/index.ts** (add to getSocialAuthUrl around line 105):

```typescript
case "TIKTOK": {
  const { TikTokClient } = await import("./clients/tiktok");
  const client = new TikTokClient();
  return client.getAuthUrl(redirectUri, state, codeChallenge);
}
```

**src/lib/social/types.ts** (update PLATFORM_CAPABILITIES around line 520):

```typescript
TIKTOK: { canLike: false, canReply: false, canShare: false }, // Changed from all false
```

**Note**: TikTok API doesn't support liking/replying/sharing through the API in Login Kit. These require Marketing API or are not available.

**Acceptance Criteria**:

- ✅ TikTok client can be created via factory
- ✅ Auth URL generation works through factory
- ✅ Platform capabilities correctly reflect API limitations

---

### Story 4: Rate Limiting & Quota Management

**Complexity**: Medium
**Effort**: 1 day
**Priority**: High (Critical for production stability)

#### Files to Create

```
src/lib/social/clients/tiktok-rate-limiter.ts (NEW)
```

#### Implementation Details

**src/lib/social/clients/tiktok-rate-limiter.ts**

```typescript
/**
 * TikTok API Rate Limiter
 *
 * Manages rate limits for TikTok Login Kit API:
 * - User Info: 100 calls/day
 * - Video List: 100 calls/day
 * - Video Upload: 24 uploads/day
 *
 * Strategy: In-memory cache + Redis (future) for distributed systems
 */

interface RateLimitConfig {
  maxRequests: number;
  windowMs: number;
  quotaType: "userInfo" | "videoList" | "videoUpload";
}

interface RateLimitEntry {
  count: number;
  resetAt: number;
}

export class TikTokRateLimiter {
  private static limits = new Map<string, RateLimitEntry>();

  private static configs: Record<string, RateLimitConfig> = {
    userInfo: {
      maxRequests: 100,
      windowMs: 24 * 60 * 60 * 1000, // 24 hours
      quotaType: "userInfo",
    },
    videoList: {
      maxRequests: 100,
      windowMs: 24 * 60 * 60 * 1000,
      quotaType: "videoList",
    },
    videoUpload: {
      maxRequests: 24,
      windowMs: 24 * 60 * 60 * 1000,
      quotaType: "videoUpload",
    },
  };

  /**
   * Check if request is allowed under rate limit
   */
  static async checkLimit(
    accountId: string,
    quotaType: "userInfo" | "videoList" | "videoUpload",
  ): Promise<{ allowed: boolean; resetAt?: number; remaining?: number; }> {
    const key = `${accountId}:${quotaType}`;
    const config = this.configs[quotaType];
    const now = Date.now();

    let entry = this.limits.get(key);

    // Reset if window expired
    if (!entry || now >= entry.resetAt) {
      entry = {
        count: 0,
        resetAt: now + config.windowMs,
      };
      this.limits.set(key, entry);
    }

    if (entry.count >= config.maxRequests) {
      return {
        allowed: false,
        resetAt: entry.resetAt,
        remaining: 0,
      };
    }

    return {
      allowed: true,
      remaining: config.maxRequests - entry.count,
    };
  }

  /**
   * Increment rate limit counter
   */
  static async incrementLimit(
    accountId: string,
    quotaType: "userInfo" | "videoList" | "videoUpload",
  ): Promise<void> {
    const key = `${accountId}:${quotaType}`;
    const entry = this.limits.get(key);

    if (entry) {
      entry.count++;
      this.limits.set(key, entry);
    }
  }

  /**
   * Get current limit status
   */
  static async getStatus(
    accountId: string,
    quotaType: "userInfo" | "videoList" | "videoUpload",
  ): Promise<{ count: number; limit: number; resetAt: number; }> {
    const key = `${accountId}:${quotaType}`;
    const config = this.configs[quotaType];
    const entry = this.limits.get(key);
    const now = Date.now();

    if (!entry || now >= entry.resetAt) {
      return {
        count: 0,
        limit: config.maxRequests,
        resetAt: now + config.windowMs,
      };
    }

    return {
      count: entry.count,
      limit: config.maxRequests,
      resetAt: entry.resetAt,
    };
  }

  /**
   * Clear limits for testing
   */
  static clearLimits(): void {
    this.limits.clear();
  }
}
```

**Integration into TikTokClient**:

Update methods in `tiktok.ts` to check/increment limits:

```typescript
async getAccountInfo(): Promise<SocialAccountInfo> {
  // Check rate limit
  const { allowed, resetAt } = await TikTokRateLimiter.checkLimit(
    this.openId || "unknown",
    "userInfo"
  );

  if (!allowed) {
    throw new Error(
      `TikTok rate limit exceeded. Resets at ${new Date(resetAt!).toISOString()}`
    );
  }

  const token = this.getAccessTokenOrThrow();

  // Make API call...

  // Increment counter on success
  await TikTokRateLimiter.incrementLimit(this.openId!, "userInfo");

  return result;
}
```

**Acceptance Criteria**:

- ✅ Rate limiting enforced for all API endpoints
- ✅ Graceful error messages with reset time
- ✅ Status endpoint to check remaining quota
- ✅ Unit tests for rate limiter logic

---

### Story 5: Trend Monitoring Dashboard (Placeholder)

**Complexity**: Medium
**Effort**: 1 day
**Priority**: Medium (Can be implemented later)

**Note**: TikTok Login Kit does **NOT** provide trend/hashtag data. This requires:

- TikTok Marketing API (business accounts only)
- Third-party trend APIs (e.g., TrendPop, Pentos)

**Recommendation**: Create placeholder UI with "Coming Soon" message, implement when Marketing API access is available.

#### Files to Create

```
src/app/orbit/[workspaceSlug]/trends/tiktok/page.tsx (NEW) - Placeholder UI
```

**Minimal Implementation**:

```typescript
export default function TikTokTrendsPage() {
  return (
    <div className="p-8">
      <h1 className="text-2xl font-bold mb-4">TikTok Trends</h1>
      <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-6">
        <p className="text-yellow-800">
          <strong>Coming Soon:</strong>{" "}
          TikTok trend monitoring requires TikTok Marketing API access. This feature will be
          available for business accounts.
        </p>
      </div>
    </div>
  );
}
```

**Acceptance Criteria**:

- ✅ Placeholder UI exists
- ✅ Clear message about Marketing API requirement
- ✅ Link to TikTok Business Center for upgrade

---

### Story 6: Testing & Documentation

**Complexity**: Simple
**Effort**: 0.5 day
**Priority**: High

#### Files to Create

```
e2e/features/tiktok-oauth.feature (NEW)
e2e/step-definitions/tiktok-oauth.steps.ts (NEW)
docs/TIKTOK_INTEGRATION.md (NEW)
```

**e2e/features/tiktok-oauth.feature**:

```gherkin
Feature: TikTok OAuth Integration

Scenario: Connect TikTok account successfully
  Given I am logged in as a workspace member
  And I am on the workspace settings page
  When I click "Connect TikTok"
  Then I should be redirected to TikTok authorization page
  # Manual step: User authorizes in TikTok
  When TikTok redirects back with authorization code
  Then my TikTok account should be connected
  And I should see my TikTok profile information
  And the account status should be "ACTIVE"

Scenario: Handle TikTok OAuth errors
  Given I am logged in as a workspace member
  When I initiate TikTok connection
  And TikTok returns an error "access_denied"
  Then I should see an error message
  And no account should be created

Scenario: Token refresh for expired TikTok tokens
  Given I have a connected TikTok account
  And the access token is expired
  When I try to fetch TikTok metrics
  Then the system should refresh the token automatically
  And the metrics should be retrieved successfully
```

**docs/TIKTOK_INTEGRATION.md**:

````markdown
# TikTok Integration Guide

## Overview

Spike Land integrates with TikTok using the **TikTok Login Kit** API for OAuth 2.0 authentication and content management.

## Setup

### 1. Create TikTok Developer App

1. Go to [TikTok Developers](https://developers.tiktok.com/)
2. Create a new app
3. Enable "Login Kit" product
4. Add redirect URI: `https://spike.land/api/social/tiktok/callback`
5. Copy Client Key and Client Secret

### 2. Configure Environment Variables

```bash
TIKTOK_CLIENT_KEY=your_client_key
TIKTOK_CLIENT_SECRET=your_client_secret
TIKTOK_CALLBACK_URL=https://spike.land/api/social/tiktok/callback
```
````

### 3. Request Required Scopes

- `user.info.basic` - User profile information
- `user.info.stats` - Follower/following counts
- `video.list` - Access user's video list
- `video.publish` - Upload videos

## Features

### Supported

- ✅ OAuth 2.0 with PKCE
- ✅ User account information
- ✅ Video listing with metrics
- ✅ Video upload (MP4 only)
- ✅ Token refresh
- ✅ Rate limiting

### Not Supported (Login Kit Limitations)

- ❌ Liking videos
- ❌ Commenting
- ❌ Trend monitoring (requires Marketing API)
- ❌ Advanced analytics (requires Marketing API)

## Rate Limits

- **User Info API**: 100 requests/day
- **Video List API**: 100 requests/day
- **Video Upload API**: 24 videos/day

## Video Upload Requirements

- **Format**: MP4 only
- **Max Duration**: 60 seconds (standard), 3 minutes (extended accounts)
- **Max File Size**: 287 MB
- **Resolution**: Up to 1080p

## Troubleshooting

### "No TikTok channel found"

- Ensure the user has a TikTok account (not just viewer account)
- Check if user authorized all required scopes

### "Rate limit exceeded"

- Wait for daily reset (shown in error message)
- Implement caching for frequently accessed data

### "Video upload failed"

- Verify video is MP4 format
- Check video duration < 60s
- Ensure file size < 287 MB

## API Reference

- [TikTok Login Kit Documentation](https://developers.tiktok.com/doc/login-kit-web)
- [TikTok Content Posting API](https://developers.tiktok.com/doc/content-posting-api-get-started)

```
**Acceptance Criteria**:
- ✅ E2E tests for OAuth flow
- ✅ Comprehensive documentation
- ✅ Setup instructions for developers
- ✅ Troubleshooting guide

---

## Implementation Order & Timeline

### Phase 1: Core Integration (2 days)
**Priority**: Critical

1. Implement TikTokClient with OAuth (1.5 days)
2. Create API routes (connect/callback) (0.5 day)

**Deliverable**: Users can connect TikTok accounts

### Phase 2: Rate Limiting & Stability (1 day)
**Priority**: High

1. Implement rate limiter (0.5 day)
2. Update factory functions (0.25 day)
3. Add error handling (0.25 day)

**Deliverable**: Production-ready TikTok integration

### Phase 3: Testing & Documentation (0.5 day)
**Priority**: High

1. E2E tests (0.25 day)
2. Documentation (0.25 day)

**Deliverable**: Tested and documented feature

### Phase 4: Future Enhancements (Future)
**Priority**: Low

1. Trend monitoring (requires Marketing API)
2. Advanced analytics
3. Video editor integration

**Total Estimated Effort**: 3-4 days

---

## Technical Risks & Mitigation

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| TikTok API rate limits too restrictive | High | Medium | Implement aggressive caching, request batching |
| Video upload failures due to format issues | Medium | High | Client-side video validation, clear error messages |
| Token refresh issues | Low | High | Implement retry logic, monitor refresh failures |
| PKCE implementation bugs | Low | Medium | Comprehensive unit tests, OAuth flow testing |
| Marketing API access required for trends | High | Low | Implement placeholder UI, document limitation |

---

## Success Metrics

### Functional
- ✅ All acceptance criteria met
- ✅ OAuth flow success rate > 95%
- ✅ Video upload success rate > 90%
- ✅ Zero security vulnerabilities

### Performance
- ✅ OAuth flow completes < 5 seconds
- ✅ Token refresh completes < 2 seconds
- ✅ Rate limit checks < 10ms

### User Experience
- ✅ Clear error messages for all failures
- ✅ Progress indicators for video uploads
- ✅ Rate limit warnings before exhaustion

---

## Out of Scope

Explicitly **NOT** included in this story:

1. **TikTok Marketing API** - Requires business account setup
2. **Trend Monitoring** - Not available in Login Kit
3. **Advanced Analytics** - Requires Marketing API
4. **Hashtag Research** - Requires third-party tools
5. **Video Editing** - Should be separate feature
6. **Scheduled Video Publishing** - Implement in scheduling system
7. **Multi-account Management** - Already handled by workspace system

---

## Dependencies

### External
- TikTok Developer Account (approved)
- Client Key and Client Secret
- Redirect URI whitelisted

### Internal
- ✅ Database models (TIKTOK enum exists)
- ✅ Token encryption utilities
- ✅ Workspace permissions system
- ✅ OAuth flow patterns (from YouTube/Twitter)

### Blockers
- **None identified** - All infrastructure exists

---

## Migration Notes

**No database migration required** - `TIKTOK` enum value already exists in `SocialPlatform`.

However, update `PLATFORM_CAPABILITIES` in `types.ts` to reflect actual API support.

---

## Rollout Plan

### Week 1: Development
- Implement TikTok client
- Create API routes
- Add rate limiting

### Week 2: Testing
- E2E tests
- Manual QA
- Security review

### Week 3: Beta Release
- Enable for beta workspace
- Monitor metrics
- Collect feedback

### Week 4: Production
- Full rollout
- Documentation published
- Marketing announcement

---

## Open Questions

1. **Should we implement chunked video upload for large files?**
   - Current: Single chunk only
   - Benefit: Support larger videos
   - Cost: Additional complexity
   - **Recommendation**: Implement in v2 if users request

2. **Do we need TikTok Marketing API access immediately?**
   - Required for: Trends, advanced analytics
   - **Recommendation**: Implement as separate feature later

3. **Should we cache user info to reduce API calls?**
   - Benefit: Avoid rate limits
   - Risk: Stale data
   - **Recommendation**: Cache with 1-hour TTL

4. **Do we support TikTok Business accounts differently?**
   - They may have different scopes/limits
   - **Recommendation**: Document limitation, support in v2

---

## Acceptance Criteria (Final Checklist)

- [ ] TikTok OAuth 2.0 flow implemented with proper token refresh handling
- [ ] Video posting support with caption, hashtags, and sound selection
- [ ] Analytics collection including views, likes, shares, comments, and follower growth
- [ ] Trend monitoring dashboard showing relevant hashtags and sounds (placeholder)
- [ ] Rate limiting and API quota management implemented

---

## Conclusion

TikTok integration follows the well-established pattern from YouTube, Twitter, and other platforms. The primary challenges are:

1. **Rate Limiting** - TikTok has very strict limits (100 calls/day)
2. **Video Upload Complexity** - 3-step upload process
3. **Limited API Features** - Login Kit doesn't support trends/advanced analytics

**Recommended Approach**:
- Start with Login Kit for broad user support
- Add Marketing API support in Phase 2 for business users
- Implement aggressive caching to work within rate limits

**Total Implementation Time**: 3-4 days for production-ready integration
```

# Implementation Plan: ORB-062 - Build Boost Detector

**Issue**: #565
**Epic**: #521 (Content-to-Ads Loop)
**Complexity**: Medium-High
**Estimated Scope**: Database models, API routes, ML prediction logic, cron jobs

---

## Summary

Build a boost detector system that monitors organic post performance in real-time, calculates boost potential scores, predicts ROI, and enables one-click boost activation. The system will integrate with existing SocialPost/ScheduledPost models, leverage the CampaignAttribution system for conversion tracking, and create paid campaigns via MarketingAccount integrations.

---

## Acceptance Criteria Breakdown

### 1. Automatic identification of posts exceeding performance thresholds

- **Implementation**: Cron job that analyzes post metrics daily
- **Threshold logic**: Top 10% engagement rate, velocity-based scoring
- **Data source**: SocialMetrics model (existing)

### 2. Boost potential score based on engagement velocity and audience match

- **Scoring formula**: Combines engagement rate, velocity, follower growth, historical performance
- **Range**: 0-100 scale
- **Factors**: Engagement velocity (40%), audience match (30%), content type (20%), timing (10%)

### 3. ROI prediction model showing expected reach, engagement, and cost

- **Historical data**: Train on past GoogleAdsCampaign spend vs SocialMetrics
- **Prediction outputs**: Estimated impressions, clicks, conversions, cost-per-result
- **Confidence intervals**: Include prediction accuracy score

### 4. One-click boost with pre-configured targeting and budget options

- **Boost templates**: Predefined audience segments, budgets ($50/$100/$200)
- **Platform selection**: Auto-select based on MarketingAccount availability
- **Approval workflow**: Status flow (PENDING → ACCEPTED → APPLIED)

### 5. Performance comparison dashboard for boosted vs organic reach

- **Metrics tracking**: Before/after comparison, incremental lift
- **Attribution**: Link boosted posts to CampaignAttribution records
- **Reporting**: Weekly performance summaries

---

## Database Schema Changes

### New Models

```prisma
// Performance tracking for all posts
model PostPerformance {
  id              String   @id @default(cuid())

  // Post reference (polymorphic - can be SocialPost or ScheduledPost)
  postId          String
  postType        PostType // SOCIAL_POST | SCHEDULED_POST
  workspaceId     String

  // Performance metrics
  impressions     Int      @default(0)
  engagementCount Int      @default(0)  // likes + comments + shares
  engagementRate  Float    @default(0)   // engagementCount / impressions
  clicks          Int      @default(0)
  conversions     Int      @default(0)
  conversionValue Float    @default(0)

  // Velocity metrics (change over time)
  engagementVelocity Float @default(0)  // engagements per hour
  impressionVelocity Float @default(0)  // impressions per hour

  // Boost readiness
  boostScore      Float?   // 0-100, calculated by ML model
  boostTrigger    String?  // "HIGH_ENGAGEMENT" | "VIRAL_VELOCITY" | "CONVERSION_SPIKE"
  estimatedROI    Float?   // Predicted return if boosted (e.g., 2.5x)

  // Metadata
  metricPeriod    DateTime // Day/week for aggregation
  checkedAt       DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  workspace       Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  recommendations PostBoostRecommendation[]

  @@index([workspaceId, boostScore])
  @@index([workspaceId, metricPeriod])
  @@index([postId, postType])
  @@map("post_performance")
}

// Boost recommendations generated by the detector
model PostBoostRecommendation {
  id                String   @id @default(cuid())
  postPerformanceId String

  // Post reference
  postId          String
  postType        PostType
  workspaceId     String
  userId          String   // Who should receive this recommendation

  // Recommendation details
  status          BoostRecommendationStatus @default(PENDING)
  reasoning       String   @db.Text  // Why this post should be boosted
  suggestedBudget Float    // Suggested spend in USD
  estimatedImpressions Int
  estimatedClicks Int
  estimatedConversions Int
  estimatedCost   Float    // Total estimated cost
  confidenceScore Float    // 0-1, how confident is the prediction

  // Platform targeting
  recommendedPlatforms String[]  // ["FACEBOOK", "GOOGLE_ADS"]
  targetAudience  Json?    // Audience targeting suggestions

  // Outcome tracking
  acceptedAt      DateTime?
  rejectedAt      DateTime?
  appliedAt       DateTime?
  actualSpend     Float?
  actualROI       Float?

  // Lifecycle
  createdAt       DateTime @default(now())
  expiresAt       DateTime // 7 days expiration

  // Relations
  postPerformance PostPerformance @relation(fields: [postPerformanceId], references: [id], onDelete: Cascade)
  workspace       Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  appliedBoost    AppliedBoost?

  @@index([workspaceId, status])
  @@index([userId, status])
  @@index([expiresAt])
  @@index([postId, postType])
  @@map("post_boost_recommendations")
}

// Track applied boosts and their performance
model AppliedBoost {
  id               String   @id @default(cuid())
  recommendationId String   @unique

  // Post reference
  postId          String
  postType        PostType
  workspaceId     String

  // Campaign tracking
  platform        MarketingPlatform
  externalCampaignId String?  // Campaign ID from FB/Google
  budget          Float

  // Performance metrics
  actualImpressions Int      @default(0)
  actualClicks     Int      @default(0)
  actualConversions Int     @default(0)
  actualSpend      Float    @default(0)
  actualROI        Float?   // calculated: (conversionValue - actualSpend) / actualSpend

  // Status
  status          AppliedBoostStatus @default(ACTIVE)
  startedAt       DateTime  @default(now())
  endedAt         DateTime?

  // Relations
  recommendation  PostBoostRecommendation @relation(fields: [recommendationId], references: [id], onDelete: Cascade)
  workspace       Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId])
  @@index([status])
  @@index([externalCampaignId])
  @@map("applied_boosts")
}

// Enums
enum PostType {
  SOCIAL_POST
  SCHEDULED_POST
}

enum BoostRecommendationStatus {
  PENDING      // Generated, awaiting review
  ACCEPTED     // User approved, awaiting application
  REJECTED     // User declined
  APPLIED      // Boost active
  EXPIRED      // Recommendation expired
}

enum AppliedBoostStatus {
  ACTIVE       // Campaign running
  PAUSED       // Temporarily paused
  COMPLETED    // Campaign ended
  FAILED       // Campaign creation failed
}
```

### Updated Models

```prisma
// Add relation to User model
model User {
  // ... existing fields
  boostRecommendations PostBoostRecommendation[]
}

// Add relation to Workspace model
model Workspace {
  // ... existing fields
  postPerformance       PostPerformance[]
  boostRecommendations  PostBoostRecommendation[]
  appliedBoosts         AppliedBoost[]
}
```

---

## Files to Create

### 1. Database Migration

**Path**: `prisma/migrations/YYYYMMDDHHMMSS_add_boost_detector/migration.sql`

- Create PostPerformance, PostBoostRecommendation, AppliedBoost tables
- Add enums: PostType, BoostRecommendationStatus, AppliedBoostStatus
- Add indexes for performance

### 2. Type Definitions

**Path**: `src/lib/boost-detector/types.ts`

```typescript
export interface BoostDetectorConfig {
  engagementThreshold: number;
  velocityThreshold: number;
  minImpressions: number;
  lookbackPeriod: number; // days
}

export interface BoostScore {
  score: number;
  factors: {
    engagementVelocity: number;
    audienceMatch: number;
    contentType: number;
    timing: number;
  };
  trigger: "HIGH_ENGAGEMENT" | "VIRAL_VELOCITY" | "CONVERSION_SPIKE";
}

export interface ROIPrediction {
  estimatedImpressions: number;
  estimatedClicks: number;
  estimatedConversions: number;
  estimatedCost: number;
  estimatedROI: number;
  confidenceScore: number;
}
```

### 3. Boost Scoring Engine

**Path**: `src/lib/boost-detector/scoring.ts`

```typescript
export async function calculateBoostScore(
  postId: string,
  postType: PostType,
  workspaceId: string,
): Promise<BoostScore>;

export async function predictROI(
  postPerformance: PostPerformance,
  suggestedBudget: number,
  platform: MarketingPlatform,
): Promise<ROIPrediction>;

export async function analyzeEngagementVelocity(
  postId: string,
  lookbackHours: number,
): Promise<number>;
```

### 4. ML Prediction Model

**Path**: `src/lib/boost-detector/ml-model.ts`

```typescript
export class BoostROIPredictor {
  async train(historicalData: HistoricalBoostData[]): Promise<void>;
  async predict(features: PostFeatures): Promise<ROIPrediction>;
  async getModelMetrics(): Promise<ModelPerformanceMetrics>;
}

// Uses linear regression or simple neural network
// Trains on: historical boost spend, impressions, conversions
// Features: engagement rate, follower count, content type, day of week, time of day
```

### 5. API Routes

**Path**: `src/app/api/orbit/[workspaceSlug]/boost/detect/route.ts`

```typescript
// POST: Manually trigger boost detection for specific posts
// Query params: ?postIds=xxx,yyy&force=true
export async function POST(request: NextRequest);
```

**Path**: `src/app/api/orbit/[workspaceSlug]/boost/recommendations/route.ts`

```typescript
// GET: List all boost recommendations for workspace
// Query params: ?status=PENDING&limit=20&offset=0
export async function GET(request: NextRequest);

// DELETE: Bulk expire recommendations
export async function DELETE(request: NextRequest);
```

**Path**: `src/app/api/orbit/[workspaceSlug]/boost/recommendations/[id]/route.ts`

```typescript
// GET: Get single recommendation details
export async function GET(request: NextRequest);

// PATCH: Accept or reject recommendation
// Body: { action: 'accept' | 'reject' }
export async function PATCH(request: NextRequest);
```

**Path**: `src/app/api/orbit/[workspaceSlug]/boost/apply/route.ts`

```typescript
// POST: Apply boost to a post (create ad campaign)
// Body: { recommendationId, platform, budget?, targetAudience? }
export async function POST(request: NextRequest);
```

**Path**: `src/app/api/orbit/[workspaceSlug]/boost/performance/route.ts`

```typescript
// GET: Performance dashboard data
// Query params: ?startDate=YYYY-MM-DD&endDate=YYYY-MM-DD
export async function GET(request: NextRequest);
```

**Path**: `src/app/api/orbit/[workspaceSlug]/boost/compare/route.ts`

```typescript
// GET: Compare boosted vs organic performance
// Query params: ?postId=xxx&postType=SOCIAL_POST
export async function GET(request: NextRequest);
```

### 6. Cron Jobs

**Path**: `src/app/api/cron/boost-detector/route.ts`

```typescript
// Runs daily at 6 AM UTC
// 1. Analyze all published posts from last 7 days
// 2. Calculate boost scores
// 3. Generate recommendations for top performers
// 4. Expire old recommendations
// 5. Sync performance metrics from platforms
export async function GET(request: NextRequest);
```

**Path**: `src/app/api/cron/boost-performance-sync/route.ts`

```typescript
// Runs hourly
// Sync actual performance data from FB/Google Ads API
// Update AppliedBoost records with real metrics
export async function GET(request: NextRequest);
```

### 7. Utility Functions

**Path**: `src/lib/boost-detector/detector.ts`

```typescript
export async function detectBoostOpportunities(
  workspaceId: string,
  config: BoostDetectorConfig,
): Promise<PostBoostRecommendation[]>;

export async function generateRecommendation(
  postPerformance: PostPerformance,
  userId: string,
): Promise<PostBoostRecommendation>;
```

**Path**: `src/lib/boost-detector/platform-integration.ts`

```typescript
export async function createAdCampaign(
  platform: MarketingPlatform,
  postId: string,
  budget: number,
  targeting: TargetAudience,
): Promise<string>; // returns externalCampaignId

export async function syncCampaignMetrics(
  externalCampaignId: string,
  platform: MarketingPlatform,
): Promise<CampaignMetrics>;
```

### 8. Webhook Handlers

**Path**: `src/lib/boost-detector/webhooks/facebook.ts`
**Path**: `src/lib/boost-detector/webhooks/google-ads.ts`

```typescript
// Handle real-time post performance updates from platforms
export async function handlePostUpdate(payload: WebhookPayload): Promise<void>;
```

---

## Files to Modify

### 1. Prisma Schema

**Path**: `prisma/schema.prisma`
**Changes**:

- Add PostPerformance, PostBoostRecommendation, AppliedBoost models
- Add relations to User and Workspace models
- Add new enums

### 2. Workspace Dashboard

**Path**: `src/app/orbit/[workspaceSlug]/dashboard/page.tsx`
**Changes**:

- Add "Boost Opportunities" widget showing pending recommendations count
- Link to new boost dashboard

### 3. Post Detail View

**Path**: `src/app/orbit/[workspaceSlug]/calendar/posts/[postId]/page.tsx` (if exists)
**Changes**:

- Display boost score badge if available
- Show "Boost This Post" button for eligible posts

### 4. Navigation

**Path**: `src/components/orbit/OrbitSidebar.tsx` (or similar)
**Changes**:

- Add "Boost Detector" menu item under Content section

---

## Testing Considerations

### Unit Tests

1. **Scoring Algorithm**: Test boost score calculation with various inputs
2. **ROI Prediction**: Validate prediction logic with mock historical data
3. **API Routes**: Test all endpoints with Vitest + msw
4. **Webhook Handlers**: Test with sample payloads

### Integration Tests

1. **Cron Job Flow**: Test full detection → recommendation → application flow
2. **Platform API Integration**: Test with sandbox accounts
3. **Attribution Tracking**: Verify CampaignAttribution records are created

### E2E Tests

1. **Recommendation Flow**: User receives, accepts, and applies boost
2. **Performance Dashboard**: View boosted vs organic comparison
3. **Rejection Flow**: User rejects recommendation

---

## Potential Risks & Blockers

### Technical Risks

1. **Platform API Rate Limits**: Facebook/Google APIs have strict limits
   - **Mitigation**: Implement exponential backoff, request queueing

2. **ML Model Accuracy**: ROI predictions may be inaccurate initially
   - **Mitigation**: Start with simple linear regression, improve over time with more data

3. **Real-time Webhook Processing**: High-volume webhooks could overwhelm system
   - **Mitigation**: Use queue (e.g., Vercel Queue, BullMQ) for async processing

### Business Risks

1. **User Confusion**: Recommendations may not align with user's goals
   - **Mitigation**: Clear reasoning text explaining why post is recommended

2. **Budget Management**: Users may not have sufficient ad budget
   - **Mitigation**: Check MarketingAccount balance before recommending

### Dependencies

1. **MarketingAccount OAuth Flow**: Users must connect FB/Google accounts first
2. **SocialMetrics Data**: Requires existing post performance tracking
3. **CampaignAttribution System**: Must be functional for ROI tracking

---

## Implementation Phases

### Phase 1: Foundation (Week 1)

- [ ] Database schema and migration
- [ ] Type definitions
- [ ] Basic API routes (detect, recommendations)
- [ ] Simple boost score calculation (no ML)

### Phase 2: Scoring & Prediction (Week 2)

- [ ] Engagement velocity calculation
- [ ] ROI prediction model (linear regression)
- [ ] Historical data aggregation
- [ ] Cron job for detection

### Phase 3: One-Click Boost (Week 3)

- [ ] Platform integration (Facebook, Google Ads)
- [ ] Apply boost endpoint
- [ ] AppliedBoost tracking
- [ ] Webhook handlers for real-time updates

### Phase 4: Dashboard & UI (Week 4)

- [ ] Performance comparison dashboard
- [ ] Boost recommendation cards
- [ ] Organic vs boosted analytics
- [ ] Email notifications for recommendations

---

## Success Metrics

1. **Detection Accuracy**: 80%+ of recommended posts perform better than average when boosted
2. **User Adoption**: 30%+ of eligible users accept at least one recommendation
3. **ROI Accuracy**: Predicted ROI within 20% margin of actual ROI
4. **Response Time**: Recommendations generated within 1 hour of post reaching threshold
5. **System Performance**: Cron jobs complete in < 5 minutes for workspaces with 1000+ posts

---

## Related Documentation

- [Epic #521: Content-to-Ads Loop](../.github/issues/521.md)
- [Database Schema](./DATABASE_SCHEMA.md)
- [Marketing API Integration](./API_REFERENCE.md#marketing-apis)
- [Campaign Attribution System](./TOKEN_SYSTEM.md#attribution)

---

## Notes

- **Privacy**: Ensure post performance data respects user consent and platform policies
- **Security**: Encrypt MarketingAccount tokens, validate webhook signatures
- **Scalability**: Design for 100k+ posts analyzed daily per workspace
- **Monitoring**: Track detection latency, prediction accuracy, API error rates

---

## Out of Scope (For Future Stories)

- ORB-063: Converting organic posts to ad creatives (image/video optimization)
- ORB-064: Feedback loop analytics (measuring incremental lift)
- Multi-language support for boost recommendations
- Advanced ML models (gradient boosting, neural networks)
- A/B testing of boost recommendations

# Implementation Plan: Issue #790

**Title**: Test: Add coverage for Scout and Inbox modules

**Created**: 2026-01-29

**Complexity**: Medium

---

## Summary

Add comprehensive test coverage for three Scout module files to achieve 100% code coverage:

- `competitor-tracker.ts` - Manages competitor accounts and syncs their posts
- `competitor-analyzer.ts` - Analyzes competitor engagement metrics and generates benchmarks
- `topic-monitor.ts` - Stub implementation (minimal testing required)

All tests will follow the existing Vitest + Prisma mocking patterns established in `suggestion-manager.test.ts`.

---

## Files to Create

### 1. `src/lib/scout/competitor-tracker.test.ts` (NEW)

**Purpose**: Test suite for competitor tracking functionality

**Test Coverage Required**:

#### `addCompetitor(workspaceId, platform, handle)`

- ✅ Happy path: Successfully adds a competitor after validation
- ✅ Edge case: Returns null for empty/whitespace handle
- ✅ Edge case: Returns null for invalid handle type
- ✅ Error case: Returns null when account validation fails
- ✅ Verify: Calls correct public API client based on platform (TWITTER, FACEBOOK, INSTAGRAM)
- ✅ Verify: Trims handle and stores account info correctly

#### `syncCompetitorPosts(competitorId)`

- ✅ Happy path: Fetches and stores posts for active competitor
- ✅ Edge case: Handles competitor not found
- ✅ Edge case: Handles inactive competitor (skips sync)
- ✅ Edge case: Handles zero posts returned from API
- ✅ Edge case: Handles posts with missing shares (Instagram case)
- ✅ Verify: Uses `createMany` with `skipDuplicates: true`
- ✅ Verify: Correctly maps post data including likes, comments, shares

#### `syncAllCompetitorsForWorkspace(workspaceId, concurrency, delayMs)`

- ✅ Happy path: Syncs all active competitors with default concurrency
- ✅ Happy path: Syncs with custom concurrency and delay settings
- ✅ Edge case: Handles workspace with no competitors
- ✅ Error handling: Continues processing when individual sync fails
- ✅ Verify: Processes competitors in batches
- ✅ Verify: Adds delay between batches (except last)
- ✅ Verify: Returns success/failure results for each competitor

#### Helper `getPublicApiClient(platform)`

- ✅ Returns correct client for each platform
- ✅ Throws error for unsupported platform

**Mocking Strategy**:

- Mock `@/lib/prisma` with scoutCompetitor.create, findUnique, findMany
- Mock `@/lib/prisma` with scoutCompetitorPost.createMany
- Mock public API clients (Twitter, Facebook, Instagram) with `vi.mock()`
- Use `vi.spyOn()` for console.error in error cases

**Dependencies**:

- PublicTwitterClient, PublicFacebookClient, PublicInstagramClient (mocked)
- Prisma client (mocked)
- SocialPlatform type from @prisma/client

---

### 2. `src/lib/scout/competitor-analyzer.test.ts` (NEW)

**Purpose**: Test suite for competitor analytics and benchmarking

**Test Coverage Required**:

#### `analyzeCompetitorEngagement(competitorId, startDate, endDate)`

- ✅ Happy path: Calculates metrics correctly with multiple posts
- ✅ Edge case: Returns zero metrics when no posts in date range
- ✅ Verify: Correctly sums likes, comments, shares
- ✅ Verify: Calculates averages correctly
- ✅ Verify: Calculates engagement rate (total interactions / total posts)

#### `getTopCompetitorPosts(competitorId, metric, limit)`

- ✅ Happy path: Returns top posts sorted by likes (default)
- ✅ Happy path: Returns top posts sorted by comments
- ✅ Happy path: Returns top posts sorted by shares
- ✅ Edge case: Respects limit parameter (default 5)
- ✅ Edge case: Returns empty array when no posts exist

#### `generateBenchmarkReport(workspaceId, startDate, endDate)`

- ✅ Happy path: Generates benchmark with competitor and workspace metrics
- ✅ Edge case: Returns null when workspace has no competitors
- ✅ Verify: Parallelizes competitor metric calculations with Promise.all
- ✅ Verify: Calls getWorkspaceMetrics for own metrics
- ✅ Verify: Saves benchmark to database with correct period format
- ✅ Verify: Calculates weighted averages correctly across all competitors
- ✅ Integration: Handles workspace with multiple competitors

**Mocking Strategy**:

- Mock `@/lib/prisma` with scoutCompetitor.findMany, scoutCompetitorPost.findMany
- Mock `@/lib/prisma` with scoutBenchmark.create
- Mock `@/lib/scout/workspace-metrics` getWorkspaceMetrics function
- Create mock competitor and post data matching database schema

**Dependencies**:

- Prisma client (mocked)
- getWorkspaceMetrics from workspace-metrics.ts (mocked)
- EngagementMetrics interface (defined in file)

---

### 3. `src/lib/scout/topic-monitor.test.ts` (NEW)

**Purpose**: Test suite for topic monitoring stub

**Test Coverage Required**:

#### `runTopicMonitoring(workspaceId)`

- ✅ Stub test: Verifies function exists and can be called
- ✅ Verify: Logs stub message to console
- ✅ Note: Minimal coverage for stub implementation

**Mocking Strategy**:

- Mock `console.log` with `vi.spyOn()` to verify stub behavior
- No Prisma mocking needed (stub implementation)

**Dependencies**: None (standalone stub function)

---

## Testing Patterns to Follow

Based on `suggestion-manager.test.ts` and public API client tests:

### 1. **Mock Setup Pattern**

```typescript
// Mock prisma BEFORE imports
vi.mock("@/lib/prisma", () => ({
  default: {
    scoutCompetitor: {
      create: vi.fn(),
      findUnique: vi.fn(),
      findMany: vi.fn(),
    },
    scoutCompetitorPost: {
      createMany: vi.fn(),
      findMany: vi.fn(),
    },
    scoutBenchmark: {
      create: vi.fn(),
    },
  },
}));

// Import AFTER mocks
import prisma from "@/lib/prisma";
```

### 2. **Test Structure Pattern**

```typescript
describe("Module Name", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("functionName", () => {
    it("should handle happy path", async () => {
      // Setup
      vi.mocked(prisma.model.method).mockResolvedValue(mockData);

      // Execute
      const result = await functionName(args);

      // Verify
      expect(result).toBe(expected);
      expect(prisma.model.method).toHaveBeenCalledWith(expectedArgs);
    });
  });
});
```

### 3. **Mock Data Pattern**

```typescript
const mockCompetitor = {
  id: "comp_abc123",
  workspaceId: "ws-1",
  platform: "TWITTER" as SocialPlatform,
  handle: "testuser",
  name: "Test User",
  isActive: true,
};

const mockPost = {
  id: "post_123",
  competitorId: "comp_abc123",
  platformPostId: "123456789",
  content: "Test post content",
  postedAt: new Date("2024-01-15T10:00:00Z"),
  likes: 100,
  comments: 20,
  shares: 5,
};
```

### 4. **Async Testing Pattern**

```typescript
it("should handle async operations", async () => {
  // Use async/await throughout
  vi.mocked(prisma.model.method).mockResolvedValue(data);
  const result = await asyncFunction();
  expect(result).toBeDefined();
});
```

---

## Potential Risks & Considerations

### 1. **Public API Client Mocking**

- **Risk**: Public API clients are external dependencies
- **Solution**: Mock entire modules with `vi.mock()` before imports
- **Example**:
  ```typescript
  vi.mock("./public-api-clients/twitter", () => ({
    PublicTwitterClient: vi.fn().mockImplementation(() => ({
      getAccountInfo: vi.fn(),
      getPosts: vi.fn(),
    })),
  }));
  ```

### 2. **Date Handling**

- **Risk**: Date comparisons in tests can be flaky
- **Solution**: Use fixed dates in mocks (e.g., `new Date("2024-01-15T10:00:00Z")`)
- **Verify**: Test date range filtering logic explicitly

### 3. **Parallel Processing**

- **Risk**: `syncAllCompetitorsForWorkspace` uses Promise.allSettled and delays
- **Solution**: Mock setTimeout with `vi.useFakeTimers()` or test with small batches
- **Verify**: Check batch processing logic and result aggregation

### 4. **Type Safety**

- **Risk**: Prisma return types need explicit casting in mocks
- **Solution**: Use `as any` or proper type definitions for mock data
- **Example**: `mockResolvedValue(mockDbRecord as any)`

### 5. **Workspace Metrics Integration**

- **Risk**: `competitor-analyzer.ts` depends on workspace-metrics module
- **Solution**: Mock `getWorkspaceMetrics` function separately
- **Pattern**:
  ```typescript
  vi.mock("@/lib/scout/workspace-metrics", () => ({
    getWorkspaceMetrics: vi.fn(),
  }));
  ```

---

## Verification Strategy

### Coverage Verification

```bash
# Run tests with coverage
yarn test:coverage src/lib/scout/competitor-tracker.test.ts
yarn test:coverage src/lib/scout/competitor-analyzer.test.ts
yarn test:coverage src/lib/scout/topic-monitor.test.ts

# Check coverage report
# Ensure all files show 100% coverage in:
# - Statements
# - Branches
# - Functions
# - Lines
```

### Test Execution

```bash
# Run all Scout tests
yarn test src/lib/scout/

# Run specific test file
yarn test competitor-tracker.test.ts

# Watch mode during development
yarn test --watch competitor-tracker.test.ts
```

---

## Out of Scope

As per issue requirements:

- ❌ Inbox collector tests (twitter, facebook, instagram) - separate ticket recommended
- ❌ Refactoring existing Scout modules
- ❌ Adding new features to Scout modules
- ❌ Testing public API clients (already have test files)
- ❌ Testing workspace-metrics.ts (separate module)

---

## Implementation Checklist

- [ ] Create `competitor-tracker.test.ts` with full coverage
- [ ] Create `competitor-analyzer.test.ts` with full coverage
- [ ] Create `topic-monitor.test.ts` with minimal coverage
- [ ] Verify all tests pass: `yarn test src/lib/scout/`
- [ ] Verify 100% coverage: `yarn test:coverage`
- [ ] Review coverage report HTML for missed branches
- [ ] Ensure all mocks follow existing patterns
- [ ] Add descriptive test names following "should..." convention
- [ ] Include error cases with console.error spies

---

## Notes

- **Estimated Test Count**: ~40-50 test cases total
- **Key Pattern**: Mock Prisma before imports, clear mocks in beforeEach
- **Reference Files**:
  - `suggestion-manager.test.ts` for Prisma mocking patterns
  - `twitter.test.ts` for external API mocking patterns
- **TypeScript**: Use strict type checking, cast mocks as `any` when needed
- **Console Mocking**: Use `vi.spyOn(console, 'error').mockImplementation(() => {})` for error cases

# Implementation Plan: Issue #525 - YouTube Full Integration

**Issue:** #525
**Title:** [Story] ORB-053: Add YouTube full integration
**Parent Epic:** #518 (Platform Integration)
**Planning Date:** 2026-01-29
**Complexity:** Medium

## Summary

Complete the YouTube integration by adding video upload capabilities (resumable protocol), comment management system, scheduled publishing with timezone support, comprehensive analytics using YouTube Analytics API, and playlist management. The basic infrastructure (OAuth, client library, metrics API) already exists and is working.

## Current State Analysis

### ✅ Already Implemented

- **YouTube Client** (`src/lib/social/clients/youtube.ts`, 806 lines)
  - OAuth 2.0 with Google (getAuthUrl, exchangeCodeForTokens, refreshAccessToken)
  - Channel info retrieval (getAccountInfo)
  - Video listing (getPosts, getVideoDetails)
  - Basic metrics (getMetrics, getChannelMetrics)
  - Full test coverage

- **OAuth Routes** (Working)
  - `src/app/api/social/youtube/connect/route.ts` - Initiates OAuth flow
  - `src/app/api/social/youtube/callback/route.ts` - Handles callback, stores tokens
  - CSRF protection with nonces
  - Workspace-scoped connections

- **API Routes** (Functional)
  - `src/app/api/social/youtube/videos/route.ts` - Lists videos with stats
  - `src/app/api/social/youtube/metrics/route.ts` - Channel statistics
  - Token-based authentication ready

- **Database**
  - `YOUTUBE` already in `SocialPlatform` enum (prisma/schema.prisma:2304)
  - `SocialAccount` model supports encrypted tokens
  - OAuth callback successfully stores accounts

### ❌ Missing Features (Per Issue #525)

1. **Video Upload** (Resumable Upload Protocol)
   - Current `createPost()` throws error - not implemented
   - Need to support large files (>100MB) with resumable uploads
   - Video processing status polling required

2. **Comment Management**
   - No comment fetching implemented
   - Need reply/moderate/bulk action capabilities
   - YouTube API has CommentThreads and Comments endpoints

3. **Scheduled Publishing**
   - No scheduling infrastructure for YouTube
   - Need timezone-aware scheduling
   - Metadata scheduling (title/description updates)

4. **Full Analytics Suite**
   - Currently using YouTube Data API v3 (basic stats only)
   - Need YouTube Analytics API for advanced metrics:
     - Watch time and retention graphs
     - Traffic sources breakdown
     - Demographics (age, gender, geography)
     - Engagement metrics over time

5. **Playlist Management**
   - No playlist operations implemented
   - Need create/update/delete/organize capabilities
   - Video-to-playlist assignment

## Architecture Overview

### Existing Infrastructure (Reuse)

```
src/lib/social/clients/youtube.ts
├── OAuth 2.0 (Google)
├── Channel Management
├── Video Listing
└── Basic Metrics

src/app/api/social/youtube/
├── connect/route.ts (OAuth init)
├── callback/route.ts (OAuth complete)
├── videos/route.ts (List videos)
└── metrics/route.ts (Channel stats)
```

### New Components Needed

```
src/lib/social/clients/youtube.ts (extend)
├── uploadVideo() - Resumable upload
├── updateVideoStatus() - Check processing
├── getComments() - Fetch comment threads
├── replyToComment() - Reply capability
├── moderateComment() - Delete/hide
├── getAnalytics() - YouTube Analytics API
├── createPlaylist() - Playlist management
├── addToPlaylist() - Organize videos
└── updatePlaylist() - Modify playlists

src/app/api/social/youtube/
├── upload/route.ts - Initiate resumable upload
├── upload/[sessionId]/route.ts - Resume upload chunks
├── comments/route.ts - Comment management
├── analytics/route.ts - Advanced analytics
└── playlists/route.ts - Playlist CRUD

src/lib/social/youtube/
├── resumable-uploader.ts - Chunked upload handler
├── video-processor.ts - Processing status polling
└── comment-moderator.ts - Comment operations

src/lib/scheduling/ (or extend existing)
└── youtube-scheduler.ts - Timezone-aware scheduling
```

## Implementation Breakdown

---

## Phase 1: Resumable Video Upload (High Priority)

**Complexity:** High
**API Reference:** https://developers.google.com/youtube/v3/guides/using_resumable_upload_protocol

### 1.1 Update OAuth Scopes

**File:** `src/lib/social/clients/youtube.ts`

**Current scopes (lines 27-30):**

```typescript
const YOUTUBE_SCOPES = [
  "https://www.googleapis.com/auth/youtube.readonly",
  "https://www.googleapis.com/auth/youtube.force-ssl",
].join(" ");
```

**Add upload scope:**

```typescript
const YOUTUBE_SCOPES = [
  "https://www.googleapis.com/auth/youtube.readonly",
  "https://www.googleapis.com/auth/youtube.force-ssl",
  "https://www.googleapis.com/auth/youtube.upload", // ADD THIS
].join(" ");
```

**Impact:** Existing connected accounts need to reconnect to grant new scope.

### 1.2 Implement Resumable Uploader Utility

**File to create:** `src/lib/social/youtube/resumable-uploader.ts` (~400 lines)

**Responsibilities:**

- Initialize resumable upload session with video metadata
- Split video into 256KB chunks (or configurable)
- Upload chunks with retry logic
- Handle upload resumption on network failure
- Track upload progress
- Return video ID when complete

**Key Methods:**

```typescript
export class YouTubeResumableUploader {
  async initiate(
    accessToken: string,
    video: {
      file: File | Buffer;
      title: string;
      description?: string;
      tags?: string[];
      categoryId?: string;
      privacyStatus: "public" | "private" | "unlisted";
    },
  ): Promise<{ uploadUrl: string; sessionId: string; }>;

  async uploadChunk(
    uploadUrl: string,
    chunk: Buffer,
    start: number,
    total: number,
  ): Promise<{ status: "uploading" | "complete"; videoId?: string; }>;

  async resumeUpload(
    uploadUrl: string,
    accessToken: string,
  ): Promise<{ uploadedBytes: number; }>;
}
```

**API Endpoints:**

1. `POST https://www.googleapis.com/upload/youtube/v3/videos?uploadType=resumable&part=snippet,status`
   - Initiates session, returns upload URL
2. `PUT <upload-url>` with chunk data
   - Uploads chunk, returns 308 (resume) or 200/201 (complete)
3. `PUT <upload-url>` with `Content-Range: bytes */total`
   - Queries current upload status

**Error Handling:**

- Network errors: Retry with exponential backoff
- 5xx errors: Resume from last byte
- 4xx errors: Report to user (invalid metadata, quota exceeded)

**Test File:** `src/lib/social/youtube/resumable-uploader.test.ts` (~300 lines)

- Mock upload session creation
- Test chunk upload with mocked responses
- Test resume functionality
- Test error scenarios

### 1.3 Implement Video Processing Status Poller

**File to create:** `src/lib/social/youtube/video-processor.ts` (~200 lines)

**Responsibilities:**

- Poll video processing status every 10-30 seconds
- Detect when video is ready (status = 'processed')
- Handle processing failures
- Timeout after configurable duration (e.g., 30 minutes)

**Key Method:**

```typescript
export async function pollVideoProcessingStatus(
  client: YouTubeClient,
  videoId: string,
  options?: {
    maxAttempts?: number;
    intervalMs?: number;
    timeoutMs?: number;
  },
): Promise<{
  status: "processed" | "processing" | "failed" | "timeout";
  processingDetails?: {
    processingStatus: string;
    processingProgress: { partsProcessed: number; partsTotal: number; timeLeftMs: number; };
  };
}>;
```

**API Endpoint:**

- `GET /youtube/v3/videos?part=processingDetails,status&id={videoId}`

**Test File:** `src/lib/social/youtube/video-processor.test.ts` (~150 lines)

### 1.4 Update YouTubeClient with Upload Method

**File to modify:** `src/lib/social/clients/youtube.ts`

**Replace stubbed createPost method (lines 501-510):**

```typescript
/**
 * Upload a video to YouTube with resumable upload protocol
 *
 * @param content - Video title (required)
 * @param options - Video file, description, tags, privacy settings
 * @returns Upload result with video ID and processing status
 */
async createPost(
  content: string,
  options?: PostOptions & {
    videoFile?: File | Buffer;
    description?: string;
    tags?: string[];
    categoryId?: string;
    privacyStatus?: 'public' | 'private' | 'unlisted';
    scheduledPublishTime?: Date;
  }
): Promise<PostResult> {
  if (!options?.videoFile) {
    throw new Error(
      "YouTube requires a video file. Use videoFile option to upload a video."
    );
  }

  const uploader = new YouTubeResumableUploader();

  // Initialize resumable upload
  const { uploadUrl, sessionId } = await uploader.initiate(
    this.getAccessTokenOrThrow(),
    {
      file: options.videoFile,
      title: content,
      description: options.description,
      tags: options.tags,
      categoryId: options.categoryId || '22', // Default to "People & Blogs"
      privacyStatus: options.privacyStatus || 'private',
    }
  );

  // Upload in chunks (simplified - actual implementation handles streaming)
  const fileBuffer = options.videoFile instanceof Buffer
    ? options.videoFile
    : await fileToBuffer(options.videoFile);

  const chunkSize = 256 * 1024; // 256 KB
  let uploadedBytes = 0;
  let videoId: string | undefined;

  while (uploadedBytes < fileBuffer.length) {
    const chunk = fileBuffer.slice(uploadedBytes, uploadedBytes + chunkSize);
    const result = await uploader.uploadChunk(
      uploadUrl,
      chunk,
      uploadedBytes,
      fileBuffer.length
    );

    uploadedBytes += chunk.length;

    if (result.status === 'complete') {
      videoId = result.videoId;
      break;
    }
  }

  if (!videoId) {
    throw new Error("Video upload completed but no video ID returned");
  }

  // Poll for processing completion (optional, async in production)
  // const processingStatus = await pollVideoProcessingStatus(this, videoId, {
  //   maxAttempts: 60,
  //   intervalMs: 10000, // 10 seconds
  // });

  return {
    platformPostId: videoId,
    url: `https://www.youtube.com/watch?v=${videoId}`,
    // Processing may still be ongoing - client should poll separately
    metadata: {
      uploadSessionId: sessionId,
      processingStatus: 'processing', // Assume still processing
    },
  };
}
```

**Add helper:**

```typescript
async function fileToBuffer(file: File): Promise<Buffer> {
  const arrayBuffer = await file.arrayBuffer();
  return Buffer.from(arrayBuffer);
}
```

**Update test file:** `src/lib/social/clients/youtube.test.ts`

- Add tests for createPost with video file
- Mock resumable upload flow
- Test error scenarios (file too large, quota exceeded)

### 1.5 Create Upload API Routes

**File to create:** `src/app/api/social/youtube/upload/route.ts` (~300 lines)

**Purpose:** Initiate resumable upload session (browser-based uploads)

**POST /api/social/youtube/upload**

Request body:

```typescript
{
  workspaceId: string;
  accountId: string; // SocialAccount ID
  metadata: {
    title: string;
    description?: string;
    tags?: string[];
    categoryId?: string;
    privacyStatus: 'public' | 'private' | 'unlisted';
  };
  fileSize: number; // Client provides total file size
}
```

Response:

```typescript
{
  uploadUrl: string; // Client uses this to upload chunks directly to Google
  sessionId: string; // Track upload in database
  expiresAt: string; // Upload URL expires after 24 hours
}
```

**Implementation:**

1. Authenticate user and workspace permissions
2. Retrieve YouTube account from database
3. Decrypt access token
4. Initiate resumable upload with YouTube API
5. Store upload session in database (optional: track progress)
6. Return upload URL to client

**File to create:** `src/app/api/social/youtube/upload/[sessionId]/route.ts` (~200 lines)

**Purpose:** Query upload status or finalize upload

**GET /api/social/youtube/upload/[sessionId]**

Response:

```typescript
{
  status: 'uploading' | 'processing' | 'processed' | 'failed';
  uploadedBytes: number;
  totalBytes: number;
  videoId?: string; // Available when upload complete
  processingProgress?: {
    partsProcessed: number;
    partsTotal: number;
  };
}
```

**Implementation:**

1. Retrieve upload session from database
2. Query YouTube API for video processing status
3. Return current state

**Files to create:**

- `src/app/api/social/youtube/upload/route.ts` (~300 lines)
- `src/app/api/social/youtube/upload/[sessionId]/route.ts` (~200 lines)
- `src/app/api/social/youtube/upload/route.test.ts` (~200 lines)

---

## Phase 2: Comment Management (Medium Priority)

**Complexity:** Medium
**API Reference:** https://developers.google.com/youtube/v3/docs/commentThreads

### 2.1 Add Comment Methods to YouTubeClient

**File to modify:** `src/lib/social/clients/youtube.ts`

**Add methods (append to class):**

```typescript
/**
 * Get comment threads for a video
 *
 * @param videoId - YouTube video ID
 * @param options - Pagination and filtering options
 * @returns List of comment threads with replies
 */
async getComments(
  videoId: string,
  options?: {
    maxResults?: number;
    pageToken?: string;
    order?: 'time' | 'relevance';
  }
): Promise<{
  comments: YouTubeComment[];
  nextPageToken?: string;
  totalResults: number;
}> {
  const token = this.getAccessTokenOrThrow();

  const params = new URLSearchParams({
    part: 'snippet,replies',
    videoId,
    maxResults: (options?.maxResults || 20).toString(),
    order: options?.order || 'time',
  });

  if (options?.pageToken) {
    params.set('pageToken', options.pageToken);
  }

  const response = await fetch(
    `${YOUTUBE_API_BASE}/commentThreads?${params.toString()}`,
    {
      headers: { Authorization: `Bearer ${token}` },
    }
  );

  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(
      `Failed to fetch comments: ${error.error?.message || response.statusText}`
    );
  }

  const data = await response.json();

  return {
    comments: (data.items || []).map(this.parseCommentThread),
    nextPageToken: data.nextPageToken,
    totalResults: data.pageInfo?.totalResults || 0,
  };
}

/**
 * Reply to a comment
 *
 * @param commentId - Parent comment ID
 * @param text - Reply text
 * @returns The created reply comment
 */
async replyToComment(
  commentId: string,
  text: string
): Promise<YouTubeComment> {
  const token = this.getAccessTokenOrThrow();

  const response = await fetch(
    `${YOUTUBE_API_BASE}/comments?part=snippet`,
    {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        snippet: {
          parentId: commentId,
          textOriginal: text,
        },
      }),
    }
  );

  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(
      `Failed to reply to comment: ${error.error?.message || response.statusText}`
    );
  }

  const data = await response.json();
  return this.parseComment(data);
}

/**
 * Moderate a comment (delete or mark as spam)
 *
 * @param commentId - Comment ID to moderate
 * @param action - Moderation action
 */
async moderateComment(
  commentId: string,
  action: 'delete' | 'markAsSpam' | 'setModerationStatus'
): Promise<void> {
  const token = this.getAccessTokenOrThrow();

  if (action === 'delete') {
    const response = await fetch(
      `${YOUTUBE_API_BASE}/comments?id=${commentId}`,
      {
        method: 'DELETE',
        headers: { Authorization: `Bearer ${token}` },
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to delete comment: ${response.statusText}`);
    }
  } else if (action === 'markAsSpam') {
    const response = await fetch(
      `${YOUTUBE_API_BASE}/comments/markAsSpam?id=${commentId}`,
      {
        method: 'POST',
        headers: { Authorization: `Bearer ${token}` },
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to mark comment as spam: ${response.statusText}`);
    }
  } else {
    const response = await fetch(
      `${YOUTUBE_API_BASE}/comments/setModerationStatus?id=${commentId}&moderationStatus=published`,
      {
        method: 'POST',
        headers: { Authorization: `Bearer ${token}` },
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to set moderation status: ${response.statusText}`);
    }
  }
}

/**
 * Bulk moderate comments
 *
 * @param commentIds - Array of comment IDs
 * @param action - Action to perform on all comments
 */
async bulkModerateComments(
  commentIds: string[],
  action: 'delete' | 'markAsSpam'
): Promise<{ succeeded: string[]; failed: { id: string; error: string }[] }> {
  const results = {
    succeeded: [] as string[],
    failed: [] as { id: string; error: string }[],
  };

  // YouTube API doesn't support true bulk operations
  // Execute sequentially with rate limiting (5 requests/second)
  for (const commentId of commentIds) {
    try {
      await this.moderateComment(commentId, action);
      results.succeeded.push(commentId);
    } catch (error) {
      results.failed.push({
        id: commentId,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
    }

    // Rate limiting: 5 requests per second
    await new Promise(resolve => setTimeout(resolve, 200));
  }

  return results;
}

/**
 * Parse comment thread from YouTube API response
 */
private parseCommentThread(thread: any): YouTubeComment {
  const topLevelComment = thread.snippet.topLevelComment.snippet;

  return {
    id: thread.id,
    videoId: thread.snippet.videoId,
    authorName: topLevelComment.authorDisplayName,
    authorChannelId: topLevelComment.authorChannelId?.value,
    authorProfileImageUrl: topLevelComment.authorProfileImageUrl,
    text: topLevelComment.textDisplay,
    likeCount: topLevelComment.likeCount || 0,
    publishedAt: new Date(topLevelComment.publishedAt),
    updatedAt: new Date(topLevelComment.updatedAt),
    replies: thread.replies?.comments?.map(this.parseComment) || [],
    totalReplyCount: thread.snippet.totalReplyCount || 0,
  };
}

/**
 * Parse single comment from YouTube API response
 */
private parseComment(comment: any): YouTubeComment {
  return {
    id: comment.id,
    videoId: comment.snippet.videoId,
    authorName: comment.snippet.authorDisplayName,
    authorChannelId: comment.snippet.authorChannelId?.value,
    authorProfileImageUrl: comment.snippet.authorProfileImageUrl,
    text: comment.snippet.textDisplay,
    likeCount: comment.snippet.likeCount || 0,
    publishedAt: new Date(comment.snippet.publishedAt),
    updatedAt: new Date(comment.snippet.updatedAt),
    parentId: comment.snippet.parentId,
  };
}
```

**Add TypeScript type:**

```typescript
export interface YouTubeComment {
  id: string;
  videoId: string;
  authorName: string;
  authorChannelId?: string;
  authorProfileImageUrl?: string;
  text: string;
  likeCount: number;
  publishedAt: Date;
  updatedAt: Date;
  parentId?: string; // Present if this is a reply
  replies?: YouTubeComment[]; // Nested replies
  totalReplyCount?: number;
}
```

### 2.2 Create Comments API Route

**File to create:** `src/app/api/social/youtube/comments/route.ts` (~400 lines)

**GET /api/social/youtube/comments?videoId={id}&accountId={id}**

Response:

```typescript
{
  comments: YouTubeComment[];
  nextPageToken?: string;
  totalResults: number;
}
```

**POST /api/social/youtube/comments (Reply)**

Request:

```typescript
{
  accountId: string;
  commentId: string;
  text: string;
}
```

**DELETE /api/social/youtube/comments?commentId={id}&accountId={id}**

**POST /api/social/youtube/comments/bulk-moderate**

Request:

```typescript
{
  accountId: string;
  commentIds: string[];
  action: 'delete' | 'markAsSpam';
}
```

**Implementation:**

1. Authenticate user and workspace
2. Retrieve account and decrypt token
3. Call YouTubeClient methods
4. Return formatted results

**Files to create:**

- `src/app/api/social/youtube/comments/route.ts` (~400 lines)
- `src/app/api/social/youtube/comments/route.test.ts` (~250 lines)

---

## Phase 3: Scheduled Publishing (Medium Priority)

**Complexity:** Medium

### 3.1 Extend Scheduling Infrastructure

YouTube scheduling is different from other platforms:

- Cannot schedule video uploads (must upload first, then set scheduled publish time)
- Can schedule visibility changes (private → public at specific time)
- Can schedule metadata updates (title, description changes)

**File to create:** `src/lib/social/youtube/scheduler.ts` (~300 lines)

**Key Methods:**

```typescript
export class YouTubeScheduler {
  /**
   * Schedule a video to be published at a specific time
   * Video must already be uploaded as 'private' or 'unlisted'
   */
  async schedulePublish(
    client: YouTubeClient,
    videoId: string,
    publishAt: Date,
    timezone: string,
  ): Promise<void>;

  /**
   * Schedule metadata update (title, description)
   */
  async scheduleMetadataUpdate(
    client: YouTubeClient,
    videoId: string,
    metadata: { title?: string; description?: string; },
    updateAt: Date,
    timezone: string,
  ): Promise<void>;

  /**
   * Cancel scheduled action
   */
  async cancelScheduledAction(actionId: string): Promise<void>;
}
```

**Implementation Approach:**

YouTube doesn't have native scheduling API for visibility changes. Two approaches:

**Option A: Use YouTube's `publishAt` field (Recommended)**

- When uploading, set `status.publishAt` to future timestamp
- YouTube automatically publishes at that time
- Limitation: Only works at upload time, can't reschedule

**Option B: Custom scheduler with cron jobs**

- Store scheduled actions in database
- Run cron job to execute at scheduled time
- More flexible but requires infrastructure

**Recommendation:** Use Option A for simplicity, document limitation clearly.

**Update YouTubeClient createPost method:**

```typescript
async createPost(
  content: string,
  options?: PostOptions & {
    videoFile?: File | Buffer;
    scheduledPublishTime?: Date; // ADD THIS
    // ... other options
  }
): Promise<PostResult> {
  // In upload initiation:
  const uploadData = {
    snippet: {
      title: content,
      description: options?.description,
      tags: options?.tags,
      categoryId: options?.categoryId || '22',
    },
    status: {
      privacyStatus: options?.scheduledPublishTime ? 'private' : (options?.privacyStatus || 'private'),
      publishAt: options?.scheduledPublishTime?.toISOString(), // ADD THIS
    },
  };

  // ... rest of upload logic
}
```

### 3.2 Timezone Handling

**File to create:** `src/lib/social/youtube/timezone-handler.ts` (~150 lines)

**Purpose:** Convert user's local timezone to UTC for YouTube API

```typescript
import { format, utcToZonedTime, zonedTimeToUtc } from "date-fns-tz";

export function convertToYouTubePublishTime(
  localTime: Date,
  timezone: string,
): string {
  // YouTube expects ISO 8601 UTC timestamp
  const utcTime = zonedTimeToUtc(localTime, timezone);
  return utcTime.toISOString();
}

export function displayScheduledTime(
  utcTime: string,
  timezone: string,
): string {
  const zonedTime = utcToZonedTime(new Date(utcTime), timezone);
  return format(zonedTime, "PPpp", { timeZone: timezone });
}
```

**Dependencies:**

- `date-fns-tz` (likely already installed)

### 3.3 Update Upload API for Scheduling

**File to modify:** `src/app/api/social/youtube/upload/route.ts`

**Add to request body:**

```typescript
{
  // ... existing fields
  scheduledPublishTime?: string; // ISO 8601 UTC
  timezone?: string; // User's timezone for validation
}
```

**Validation:**

1. Ensure `scheduledPublishTime` is in the future
2. Ensure not more than 6 months in future (YouTube limit)
3. Convert to UTC if timezone provided

**Files to modify:**

- `src/app/api/social/youtube/upload/route.ts` - Add scheduling support

**Files to create:**

- `src/lib/social/youtube/scheduler.ts` (~300 lines)
- `src/lib/social/youtube/timezone-handler.ts` (~150 lines)
- `src/lib/social/youtube/scheduler.test.ts` (~200 lines)

---

## Phase 4: Full Analytics Suite (High Priority)

**Complexity:** High
**API:** YouTube Analytics API (different from YouTube Data API v3)
**Reference:** https://developers.google.com/youtube/analytics

### 4.1 Enable YouTube Analytics API

**Google Cloud Console Setup:**

1. Enable "YouTube Analytics API" in Google Cloud Console (separate from YouTube Data API)
2. No additional OAuth scopes required (same credentials)
3. Verify quota limits (10,000 units/day default)

**Environment Variables:**

- Same as existing YouTube credentials (YOUTUBE_CLIENT_ID/SECRET)

### 4.2 Implement Analytics Client

**File to create:** `src/lib/social/youtube/analytics-client.ts` (~600 lines)

**Purpose:** Dedicated client for YouTube Analytics API

```typescript
export class YouTubeAnalyticsClient {
  private accessToken: string;

  constructor(accessToken: string) {
    this.accessToken = accessToken;
  }

  /**
   * Get watch time and average view duration for a date range
   */
  async getWatchTime(
    channelId: string,
    startDate: Date,
    endDate: Date,
  ): Promise<{
    totalWatchTimeMinutes: number;
    averageViewDuration: number;
    views: number;
  }>;

  /**
   * Get audience retention graph for a video
   */
  async getRetentionData(
    videoId: string,
  ): Promise<{
    retentionPercentage: Array<{ elapsed: number; percentage: number; }>;
    relativeRetention: number;
  }>;

  /**
   * Get traffic sources breakdown
   */
  async getTrafficSources(
    channelId: string,
    startDate: Date,
    endDate: Date,
  ): Promise<{
    sources: Array<{
      source: "YOUTUBE_SEARCH" | "EXTERNAL" | "SUGGESTED_VIDEOS" | "BROWSE" | "OTHER";
      views: number;
      percentage: number;
    }>;
  }>;

  /**
   * Get demographics (age and gender)
   */
  async getDemographics(
    channelId: string,
    startDate: Date,
    endDate: Date,
  ): Promise<{
    ageGroups: Array<{ range: string; percentage: number; }>;
    gender: { male: number; female: number; other: number; };
  }>;

  /**
   * Get geography data (views by country)
   */
  async getGeography(
    channelId: string,
    startDate: Date,
    endDate: Date,
    limit?: number,
  ): Promise<{
    countries: Array<{ code: string; name: string; views: number; percentage: number; }>;
  }>;

  /**
   * Get engagement metrics over time (likes, comments, shares)
   */
  async getEngagementMetrics(
    channelId: string,
    startDate: Date,
    endDate: Date,
    granularity: "day" | "week" | "month",
  ): Promise<{
    data: Array<{
      date: string;
      likes: number;
      comments: number;
      shares: number;
      subscribersGained: number;
      subscribersLost: number;
    }>;
  }>;
}
```

**API Endpoints:**

YouTube Analytics uses a single endpoint with query dimensions:

`GET https://youtubeanalytics.googleapis.com/v2/reports`

Query parameters vary by metric:

- `ids=channel=={channelId}`
- `startDate=YYYY-MM-DD`
- `endDate=YYYY-MM-DD`
- `metrics=views,estimatedMinutesWatched,averageViewDuration`
- `dimensions=day` (for time series)
- `filters=video=={videoId}` (for video-specific data)

**Example implementation:**

```typescript
async getWatchTime(
  channelId: string,
  startDate: Date,
  endDate: Date
): Promise<WatchTimeMetrics> {
  const params = new URLSearchParams({
    ids: `channel==${channelId}`,
    startDate: formatDate(startDate),
    endDate: formatDate(endDate),
    metrics: 'views,estimatedMinutesWatched,averageViewDuration',
  });

  const response = await fetch(
    `https://youtubeanalytics.googleapis.com/v2/reports?${params.toString()}`,
    {
      headers: { Authorization: `Bearer ${this.accessToken}` },
    }
  );

  if (!response.ok) {
    throw new Error(`Analytics API error: ${response.statusText}`);
  }

  const data = await response.json();
  const row = data.rows[0] || [0, 0, 0];

  return {
    views: row[0],
    totalWatchTimeMinutes: row[1],
    averageViewDuration: row[2],
  };
}
```

**Files to create:**

- `src/lib/social/youtube/analytics-client.ts` (~600 lines)
- `src/lib/social/youtube/analytics-client.test.ts` (~400 lines)

### 4.3 Create Analytics API Route

**File to create:** `src/app/api/social/youtube/analytics/route.ts` (~500 lines)

**GET /api/social/youtube/analytics?accountId={id}&type={type}&startDate={date}&endDate={date}**

Query parameters:

- `accountId` - SocialAccount ID
- `type` - Analytics type: `watch-time` | `retention` | `traffic-sources` | `demographics` | `geography` | `engagement`
- `startDate` - Start date (ISO 8601)
- `endDate` - End date (ISO 8601)
- `videoId` - Optional, for video-specific analytics

Response varies by type:

```typescript
// type=watch-time
{
  totalWatchTimeMinutes: number;
  averageViewDuration: number;
  views: number;
}

// type=traffic-sources
{
  sources: Array<{ source: string; views: number; percentage: number; }>;
}

// type=demographics
{
  ageGroups: Array<{ range: string; percentage: number; }>;
  gender: {
    male: number;
    female: number;
    other: number;
  }
}

// ... etc
```

**Implementation:**

1. Authenticate user and workspace
2. Retrieve account, decrypt token
3. Create YouTubeAnalyticsClient
4. Call appropriate method based on `type`
5. Cache results (analytics data is not real-time)

**Caching Strategy:**

- Cache analytics for 6 hours (YouTube updates every 24-48 hours)
- Use Redis or database caching
- Key: `youtube:analytics:{accountId}:{type}:{startDate}:{endDate}`

**Files to create:**

- `src/app/api/social/youtube/analytics/route.ts` (~500 lines)
- `src/app/api/social/youtube/analytics/route.test.ts` (~300 lines)

---

## Phase 5: Playlist Management (Low Priority)

**Complexity:** Medium
**API Reference:** https://developers.google.com/youtube/v3/docs/playlists

### 5.1 Add Playlist Methods to YouTubeClient

**File to modify:** `src/lib/social/clients/youtube.ts`

**Add methods:**

```typescript
/**
 * List playlists for the authenticated channel
 */
async getPlaylists(
  options?: { maxResults?: number; pageToken?: string }
): Promise<{
  playlists: YouTubePlaylist[];
  nextPageToken?: string;
}> {
  const token = this.getAccessTokenOrThrow();

  const params = new URLSearchParams({
    part: 'snippet,contentDetails',
    mine: 'true',
    maxResults: (options?.maxResults || 25).toString(),
  });

  if (options?.pageToken) {
    params.set('pageToken', options.pageToken);
  }

  const response = await fetch(
    `${YOUTUBE_API_BASE}/playlists?${params.toString()}`,
    {
      headers: { Authorization: `Bearer ${token}` },
    }
  );

  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(
      `Failed to fetch playlists: ${error.error?.message || response.statusText}`
    );
  }

  const data = await response.json();

  return {
    playlists: (data.items || []).map(this.parsePlaylist),
    nextPageToken: data.nextPageToken,
  };
}

/**
 * Create a new playlist
 */
async createPlaylist(
  title: string,
  description?: string,
  privacyStatus: 'public' | 'private' | 'unlisted' = 'private'
): Promise<YouTubePlaylist> {
  const token = this.getAccessTokenOrThrow();

  const response = await fetch(
    `${YOUTUBE_API_BASE}/playlists?part=snippet,status`,
    {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        snippet: {
          title,
          description: description || '',
        },
        status: {
          privacyStatus,
        },
      }),
    }
  );

  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(
      `Failed to create playlist: ${error.error?.message || response.statusText}`
    );
  }

  const data = await response.json();
  return this.parsePlaylist(data);
}

/**
 * Add a video to a playlist
 */
async addToPlaylist(
  playlistId: string,
  videoId: string,
  position?: number
): Promise<void> {
  const token = this.getAccessTokenOrThrow();

  const requestBody: any = {
    snippet: {
      playlistId,
      resourceId: {
        kind: 'youtube#video',
        videoId,
      },
    },
  };

  if (position !== undefined) {
    requestBody.snippet.position = position;
  }

  const response = await fetch(
    `${YOUTUBE_API_BASE}/playlistItems?part=snippet`,
    {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody),
    }
  );

  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(
      `Failed to add video to playlist: ${error.error?.message || response.statusText}`
    );
  }
}

/**
 * Update playlist metadata
 */
async updatePlaylist(
  playlistId: string,
  updates: {
    title?: string;
    description?: string;
    privacyStatus?: 'public' | 'private' | 'unlisted';
  }
): Promise<YouTubePlaylist> {
  const token = this.getAccessTokenOrThrow();

  // First, get current playlist data
  const currentResponse = await fetch(
    `${YOUTUBE_API_BASE}/playlists?part=snippet,status&id=${playlistId}`,
    {
      headers: { Authorization: `Bearer ${token}` },
    }
  );

  if (!currentResponse.ok) {
    throw new Error('Failed to fetch current playlist data');
  }

  const currentData = await currentResponse.json();
  const current = currentData.items[0];

  if (!current) {
    throw new Error(`Playlist not found: ${playlistId}`);
  }

  // Merge updates with current data
  const updateBody = {
    id: playlistId,
    snippet: {
      title: updates.title || current.snippet.title,
      description: updates.description !== undefined
        ? updates.description
        : current.snippet.description,
    },
    status: {
      privacyStatus: updates.privacyStatus || current.status.privacyStatus,
    },
  };

  const response = await fetch(
    `${YOUTUBE_API_BASE}/playlists?part=snippet,status`,
    {
      method: 'PUT',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(updateBody),
    }
  );

  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(
      `Failed to update playlist: ${error.error?.message || response.statusText}`
    );
  }

  const data = await response.json();
  return this.parsePlaylist(data);
}

/**
 * Delete a playlist
 */
async deletePlaylist(playlistId: string): Promise<void> {
  const token = this.getAccessTokenOrThrow();

  const response = await fetch(
    `${YOUTUBE_API_BASE}/playlists?id=${playlistId}`,
    {
      method: 'DELETE',
      headers: { Authorization: `Bearer ${token}` },
    }
  );

  if (!response.ok) {
    throw new Error(`Failed to delete playlist: ${response.statusText}`);
  }
}

/**
 * Parse playlist from YouTube API response
 */
private parsePlaylist(playlist: any): YouTubePlaylist {
  return {
    id: playlist.id,
    title: playlist.snippet.title,
    description: playlist.snippet.description,
    publishedAt: new Date(playlist.snippet.publishedAt),
    thumbnailUrl: playlist.snippet.thumbnails?.medium?.url,
    privacyStatus: playlist.status?.privacyStatus || 'private',
    itemCount: playlist.contentDetails?.itemCount || 0,
  };
}
```

**Add TypeScript type:**

```typescript
export interface YouTubePlaylist {
  id: string;
  title: string;
  description: string;
  publishedAt: Date;
  thumbnailUrl?: string;
  privacyStatus: "public" | "private" | "unlisted";
  itemCount: number;
}
```

### 5.2 Create Playlists API Route

**File to create:** `src/app/api/social/youtube/playlists/route.ts` (~400 lines)

**GET /api/social/youtube/playlists?accountId={id}**

Response:

```typescript
{
  playlists: YouTubePlaylist[];
  nextPageToken?: string;
}
```

**POST /api/social/youtube/playlists (Create)**

Request:

```typescript
{
  accountId: string;
  title: string;
  description?: string;
  privacyStatus?: 'public' | 'private' | 'unlisted';
}
```

**PUT /api/social/youtube/playlists (Update)**

Request:

```typescript
{
  accountId: string;
  playlistId: string;
  updates: {
    title?: string;
    description?: string;
    privacyStatus?: 'public' | 'private' | 'unlisted';
  };
}
```

**DELETE /api/social/youtube/playlists?accountId={id}&playlistId={id}**

**POST /api/social/youtube/playlists/add-video**

Request:

```typescript
{
  accountId: string;
  playlistId: string;
  videoId: string;
  position?: number;
}
```

**Files to create:**

- `src/app/api/social/youtube/playlists/route.ts` (~400 lines)
- `src/app/api/social/youtube/playlists/route.test.ts` (~250 lines)

---

## Cross-Cutting Tasks

### Task 1: Update Platform Capabilities

**File:** `src/lib/social/types.ts` (line 522)

**Current:**

```typescript
YOUTUBE: { canLike: false, canReply: false, canShare: false },
```

**Update to:**

```typescript
YOUTUBE: {
  canLike: true,     // Can like comments (via Analytics API)
  canReply: true,    // Can reply to comments
  canShare: false    // No native share API
},
```

### Task 2: Integration into Stream Aggregator

**File:** `src/lib/social/index.ts` (lines 51-54)

YouTube case already exists but verify it works:

```typescript
case "YOUTUBE": {
  const { YouTubeClient } = await import("./clients/youtube");
  return new YouTubeClient(options);
}
```

**File:** `src/lib/social/stream-aggregator.ts`

Verify YouTube is included in platform list and posts display correctly.

### Task 3: UI Components

**Files to update:**

1. **Upload Form** (create new)
   - `src/components/orbit/youtube/VideoUploadForm.tsx`
   - File upload with progress bar
   - Metadata fields (title, description, tags, category)
   - Privacy and scheduling options
   - Processing status indicator

2. **Comment Management UI** (create new)
   - `src/components/orbit/youtube/CommentManager.tsx`
   - List comments with replies
   - Reply form
   - Moderation actions (delete, mark spam)
   - Bulk selection and actions

3. **Analytics Dashboard** (create new)
   - `src/components/orbit/youtube/AnalyticsDashboard.tsx`
   - Watch time charts
   - Retention graphs
   - Traffic sources pie chart
   - Demographics breakdown
   - Geography heatmap

4. **Playlist Manager** (create new)
   - `src/components/orbit/youtube/PlaylistManager.tsx`
   - List playlists
   - Create/edit/delete playlist
   - Add videos to playlist
   - Reorder videos

**Files to modify:**

- `src/app/orbit/[workspaceSlug]/settings/accounts/SocialAccountsClient.tsx`
  - Verify YouTube connect button works
  - Display connected YouTube channel

- `src/components/streams/StreamPostCard.tsx`
  - Ensure YouTube videos display correctly
  - Add video thumbnail
  - Show view count, likes, comments

### Task 4: Documentation

**Files to update:**

- `docs/API_REFERENCE.md`
  - Document new YouTube endpoints (upload, comments, analytics, playlists)
  - Include request/response examples
  - Document rate limits and quotas

- `docs/FEATURES.md`
  - Update Orbit platform support:
    - YouTube video upload (resumable protocol)
    - Comment management with replies
    - Scheduled publishing (timezone-aware)
    - Advanced analytics (watch time, retention, demographics)
    - Playlist management

- `README.md`
  - Update platform list to emphasize YouTube is fully supported

**New documentation:**

- `docs/YOUTUBE_INTEGRATION.md` (~500 lines)
  - Complete YouTube integration guide
  - OAuth setup instructions
  - API quotas and rate limits
  - Video upload best practices
  - Scheduling limitations
  - Analytics data refresh intervals
  - Troubleshooting common issues

---

## Testing Strategy

### Unit Tests (100% Coverage Required)

**Existing tests to update:**

- `src/lib/social/clients/youtube.test.ts`
  - Add tests for new methods (upload, comments, playlists)
  - Mock resumable upload flow
  - Test error scenarios

**New test files:**

- `src/lib/social/youtube/resumable-uploader.test.ts` (~300 lines)
  - Test chunk upload logic
  - Test resume on network failure
  - Test upload completion detection

- `src/lib/social/youtube/video-processor.test.ts` (~150 lines)
  - Test polling logic
  - Test timeout scenarios
  - Test processing failure detection

- `src/lib/social/youtube/analytics-client.test.ts` (~400 lines)
  - Mock Analytics API responses
  - Test all metric types
  - Test date range validation

- `src/lib/social/youtube/scheduler.test.ts` (~200 lines)
  - Test timezone conversion
  - Test scheduling validation (future dates, 6-month limit)

### Integration Tests

- `src/app/api/social/youtube/upload/route.test.ts` (~200 lines)
  - Test upload session creation
  - Test permission checks
  - Test error handling

- `src/app/api/social/youtube/comments/route.test.ts` (~250 lines)
  - Test comment fetching
  - Test reply functionality
  - Test moderation actions

- `src/app/api/social/youtube/analytics/route.test.ts` (~300 lines)
  - Test each analytics type
  - Test caching behavior
  - Test date range handling

- `src/app/api/social/youtube/playlists/route.test.ts` (~250 lines)
  - Test CRUD operations
  - Test adding videos to playlists

### E2E Tests (Playwright + Cucumber)

**File:** `e2e/features/youtube-integration.feature` (~200 lines)

```gherkin
Feature: YouTube Full Integration

  Background:
    Given I am logged in as a workspace admin
    And I have a YouTube account connected

  Scenario: Upload a video with resumable protocol
    When I navigate to YouTube upload form
    And I select a video file "test-video.mp4"
    And I enter title "Test Video Upload"
    And I enter description "Testing resumable upload"
    And I select privacy "Private"
    And I click "Upload"
    Then I should see upload progress
    And the video should be uploaded successfully
    And I should see "Video processing" status

  Scenario: Schedule a video for future publish
    When I navigate to YouTube upload form
    And I select a video file "scheduled-video.mp4"
    And I enter title "Scheduled Video"
    And I select "Schedule for later"
    And I set publish date to "2026-02-15 10:00 AM EST"
    And I click "Upload"
    Then the video should be uploaded as private
    And the scheduled publish time should be set
    And I should see "Scheduled for Feb 15, 2026 10:00 AM EST"

  Scenario: Manage video comments
    Given I have a video with comments
    When I navigate to YouTube comments
    Then I should see the list of comments
    When I click "Reply" on a comment
    And I enter reply text "Thanks for watching!"
    And I click "Send Reply"
    Then my reply should appear under the comment

  Scenario: Moderate comments in bulk
    Given I have multiple spam comments on a video
    When I navigate to YouTube comments
    And I select 5 spam comments
    And I click "Mark as Spam"
    Then all selected comments should be marked as spam
    And I should see "5 comments marked as spam"

  Scenario: View advanced analytics
    When I navigate to YouTube analytics
    And I select date range "Last 30 days"
    Then I should see watch time graph
    And I should see retention chart
    And I should see traffic sources breakdown
    And I should see demographics data
    And I should see top countries by views

  Scenario: Manage playlists
    When I navigate to YouTube playlists
    And I click "Create Playlist"
    And I enter playlist name "Tutorial Series"
    And I set privacy to "Public"
    And I click "Create"
    Then the playlist should be created
    When I select a video
    And I click "Add to Playlist"
    And I select "Tutorial Series"
    Then the video should be added to the playlist
```

**Step definitions:** `e2e/step-definitions/youtube-integration.steps.ts` (~400 lines)

### Manual Testing Checklist

- [ ] Upload a small video (<5MB) successfully
- [ ] Upload a large video (>100MB) using resumable upload
- [ ] Test upload resume after network interruption
- [ ] Schedule video for future publish (verify it publishes on time)
- [ ] Fetch comments and verify reply works
- [ ] Delete a comment as channel owner
- [ ] Mark multiple comments as spam
- [ ] View watch time analytics for last 30 days
- [ ] View retention graph for a specific video
- [ ] View traffic sources breakdown
- [ ] View demographics data
- [ ] Create a new playlist
- [ ] Add 5 videos to playlist
- [ ] Reorder videos in playlist
- [ ] Delete a playlist
- [ ] Verify all YouTube data displays in Orbit stream

---

## Dependencies & Prerequisites

### External Dependencies

1. **Google Cloud Console Setup**
   - Enable YouTube Data API v3 (already done)
   - Enable YouTube Analytics API (new)
   - Verify OAuth credentials have upload scope
   - Check API quotas:
     - YouTube Data API: 10,000 units/day (uploads cost 1,600 units)
     - YouTube Analytics API: 10,000 queries/day

2. **OAuth Scope Updates**
   - Existing connected accounts need to reconnect to grant `youtube.upload` scope
   - Show notification to users: "Reconnect YouTube to enable video uploads"

### Internal Dependencies

1. **Existing Infrastructure** (working)
   - YouTubeClient base implementation
   - OAuth connect/callback routes
   - Token encryption/decryption
   - Workspace permissions

2. **New Dependencies**
   - `date-fns-tz` - Timezone handling (likely already installed)
   - File upload handling library (Next.js handles this natively)

---

## Database Schema Changes

### No schema changes required

YouTube is already in the `SocialPlatform` enum (prisma/schema.prisma:2304).
`SocialAccount` model already supports all required fields.

### Optional: Upload Session Tracking

If tracking resumable upload sessions in database:

**New model (optional):**

```prisma
model YouTubeUploadSession {
  id              String   @id @default(cuid())
  workspaceId     String
  accountId       String   // SocialAccount reference
  uploadUrl       String   // Google's resumable upload URL
  videoId         String?  // Set when upload completes
  metadata        Json     // Video title, description, tags
  fileSize        BigInt
  uploadedBytes   BigInt   @default(0)
  status          String   // 'uploading' | 'processing' | 'completed' | 'failed'
  expiresAt       DateTime // Upload URL expires after 24 hours
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  workspace       Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  account         SocialAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@index([workspaceId, status])
  @@index([accountId])
}
```

**Decision:** Skip for MVP. Track upload client-side, only store final video in SocialPost.

---

## Rollout Plan

### Phase 1: Video Upload (Week 1)

**Duration:** 4-5 days
**Deliverables:**

- Resumable upload utility
- Video processing poller
- Update YouTubeClient.createPost()
- Upload API routes
- Unit and integration tests

### Phase 2: Comment Management (Week 2)

**Duration:** 2-3 days
**Deliverables:**

- Comment fetching, reply, moderation methods
- Comments API route
- Comment UI component
- Tests

### Phase 3: Analytics (Week 2)

**Duration:** 3-4 days
**Deliverables:**

- YouTube Analytics API client
- Analytics API route
- Analytics dashboard UI
- Tests

### Phase 4: Scheduled Publishing (Week 3)

**Duration:** 2 days
**Deliverables:**

- Scheduling integration in upload flow
- Timezone conversion utilities
- UI for scheduling
- Tests

### Phase 5: Playlist Management (Week 3)

**Duration:** 2-3 days
**Deliverables:**

- Playlist CRUD methods
- Playlist API route
- Playlist UI component
- Tests

### Phase 6: Integration & Polish (Week 4)

**Duration:** 2-3 days
**Deliverables:**

- E2E test suite
- Documentation updates
- UI polish and error handling
- Performance testing
- User acceptance testing

**Total Estimated Duration:** 15-20 days (3-4 weeks)

---

## Risks & Mitigation

### Risk 1: Resumable Upload Complexity

**Impact:** High
**Probability:** Medium
**Mitigation:**

- Use proven libraries or patterns (Google provides examples)
- Test with various file sizes (1MB, 10MB, 100MB, 500MB)
- Implement comprehensive retry logic
- Document file size limits clearly (2GB max for YouTube)

### Risk 2: Video Processing Time

**Impact:** Medium
**Probability:** High (processing can take 10-60 minutes for large videos)
**Mitigation:**

- Don't block UI during processing
- Implement background polling job
- Show clear processing status
- Allow user to navigate away and return later
- Send notification when processing completes

### Risk 3: YouTube API Quotas

**Impact:** High
**Probability:** Medium
**Mitigation:**

- Monitor quota usage in Google Cloud Console
- Cache analytics data (updates every 24-48 hours anyway)
- Implement rate limiting on client side
- Request quota increase if needed
- Document quota costs per operation

**Quota Costs:**

- Video upload: 1,600 units (only 6 uploads per day with default quota!)
- Comment fetch: 1 unit
- Analytics query: 1 unit

**Action:** Request quota increase to 50,000 units/day for production.

### Risk 4: OAuth Scope Changes

**Impact:** Medium
**Probability:** High (existing users need to reconnect)
**Mitigation:**

- Show clear notification: "Reconnect YouTube to enable video uploads"
- Provide migration guide
- Keep existing functionality working (read-only)
- Add banner in UI when upload scope missing

### Risk 5: Scheduled Publishing Limitations

**Impact:** Low
**Probability:** High (YouTube only supports scheduling at upload time)
**Mitigation:**

- Document limitation clearly
- Explain workaround: upload as private, manually publish later
- Consider implementing custom scheduler for rescheduling (Phase 2 enhancement)

---

## Acceptance Criteria (From Issue #525)

- [x] Video upload with resumable upload support for large files ✅
  - Resumable upload protocol implemented
  - Supports files >100MB
  - Retry logic on network failure
  - Upload progress tracking

- [x] Scheduled publishing with timezone-aware scheduling ✅
  - Uses YouTube's `publishAt` field
  - Timezone conversion utilities
  - Validation (future date, <6 months)
  - Clear UI for scheduling

- [x] Comment management including view, reply, moderate, and bulk actions ✅
  - Fetch comment threads with replies
  - Reply to comments
  - Delete/mark spam
  - Bulk moderation

- [x] Full analytics including watch time, retention, traffic sources, and demographics ✅
  - YouTube Analytics API integration
  - Watch time and average view duration
  - Retention graphs
  - Traffic sources breakdown
  - Demographics (age, gender, geography)

- [x] Playlist management and video organization features ✅
  - List playlists
  - Create/update/delete playlists
  - Add videos to playlists
  - Reorder videos (via position parameter)

---

## Files to Create

### Core Libraries

- `src/lib/social/youtube/resumable-uploader.ts` (~400 lines)
- `src/lib/social/youtube/resumable-uploader.test.ts` (~300 lines)
- `src/lib/social/youtube/video-processor.ts` (~200 lines)
- `src/lib/social/youtube/video-processor.test.ts` (~150 lines)
- `src/lib/social/youtube/analytics-client.ts` (~600 lines)
- `src/lib/social/youtube/analytics-client.test.ts` (~400 lines)
- `src/lib/social/youtube/scheduler.ts` (~300 lines)
- `src/lib/social/youtube/scheduler.test.ts` (~200 lines)
- `src/lib/social/youtube/timezone-handler.ts` (~150 lines)

### API Routes

- `src/app/api/social/youtube/upload/route.ts` (~300 lines)
- `src/app/api/social/youtube/upload/[sessionId]/route.ts` (~200 lines)
- `src/app/api/social/youtube/upload/route.test.ts` (~200 lines)
- `src/app/api/social/youtube/comments/route.ts` (~400 lines)
- `src/app/api/social/youtube/comments/route.test.ts` (~250 lines)
- `src/app/api/social/youtube/analytics/route.ts` (~500 lines)
- `src/app/api/social/youtube/analytics/route.test.ts` (~300 lines)
- `src/app/api/social/youtube/playlists/route.ts` (~400 lines)
- `src/app/api/social/youtube/playlists/route.test.ts` (~250 lines)

### UI Components

- `src/components/orbit/youtube/VideoUploadForm.tsx` (~400 lines)
- `src/components/orbit/youtube/CommentManager.tsx` (~500 lines)
- `src/components/orbit/youtube/AnalyticsDashboard.tsx` (~600 lines)
- `src/components/orbit/youtube/PlaylistManager.tsx` (~400 lines)

### Documentation

- `docs/YOUTUBE_INTEGRATION.md` (~500 lines)

### E2E Tests

- `e2e/features/youtube-integration.feature` (~200 lines)
- `e2e/step-definitions/youtube-integration.steps.ts` (~400 lines)

**Total New Files:** ~25 files, ~7,000 lines of code

---

## Files to Modify

### Core Client

- `src/lib/social/clients/youtube.ts`
  - Update `YOUTUBE_SCOPES` to include `youtube.upload` (line 27-30)
  - Replace `createPost()` stub with resumable upload implementation (lines 501-510)
  - Add comment management methods (~300 lines)
  - Add playlist management methods (~250 lines)
  - Add types for comments and playlists (~100 lines)

- `src/lib/social/clients/youtube.test.ts`
  - Add tests for upload, comments, playlists (~400 lines)

### Platform Configuration

- `src/lib/social/types.ts` (line 522)
  - Update YOUTUBE capabilities: `{ canLike: true, canReply: true, canShare: false }`

### Stream Integration

- `src/lib/social/index.ts` (lines 51-54)
  - Verify YouTube factory case works (no changes needed)

- `src/lib/social/stream-aggregator.ts`
  - Verify YouTube videos display in stream (likely no changes needed)

### UI Components

- `src/components/streams/StreamPostCard.tsx`
  - Ensure YouTube videos display with thumbnail and stats
  - Add video player embed option

- `src/app/orbit/[workspaceSlug]/settings/accounts/SocialAccountsClient.tsx`
  - Verify YouTube connect button displays
  - Show notification if upload scope missing

### Documentation

- `docs/API_REFERENCE.md`
  - Add YouTube upload, comments, analytics, playlists endpoints

- `docs/FEATURES.md`
  - Update Orbit YouTube features list

- `README.md`
  - Update platform support list

---

## Success Metrics

### Functional Metrics

- **Upload Success Rate:** >95% successful uploads (excluding user cancellations)
- **Processing Detection:** 100% of uploads detect processing completion within 30 minutes
- **Comment Operations:** 100% success rate for fetch/reply/moderate
- **Analytics Queries:** <2 second response time (with caching)
- **Scheduled Publishes:** 100% publish at correct time (±5 minutes)

### Code Quality Metrics

- **Test Coverage:** 100% for all new code
- **Type Safety:** 100% TypeScript strict mode
- **Linting:** 0 ESLint errors
- **Documentation:** 100% public methods documented

### User Experience Metrics

- **Upload Time:** <30 seconds for 100MB video upload initiation
- **Comment Load Time:** <1 second to load 20 comments
- **Analytics Load Time:** <2 seconds with cache, <5 seconds without
- **Error Rate:** <1% OAuth failures, <2% upload failures

---

## Post-Implementation Tasks

### Monitoring & Observability

- [ ] Track upload success/failure rates (Sentry)
- [ ] Monitor YouTube API quota usage daily
- [ ] Alert on quota threshold (>80%)
- [ ] Track video processing times (average, p95, p99)
- [ ] Monitor analytics cache hit rate

### User Communication

- [ ] Announce YouTube full integration in changelog
- [ ] Send email to users with YouTube accounts connected
- [ ] Create help center articles:
  - "How to upload videos to YouTube from Orbit"
  - "Understanding YouTube Analytics"
  - "Managing YouTube comments"
  - "Creating and organizing playlists"
- [ ] Add in-app tooltips for new features

### Future Enhancements

- [ ] Live streaming support (YouTube Live API)
- [ ] Custom thumbnails upload
- [ ] End screen and card management
- [ ] Subtitle/caption management
- [ ] YouTube Shorts support
- [ ] Advanced scheduling (custom scheduler for rescheduling)
- [ ] Video editor integration (trim, crop, filters)

---

## Notes

### Technical Considerations

**Resumable Upload:**

- YouTube requires `X-Upload-Content-Type` and `X-Upload-Content-Length` headers
- Upload URL expires after 24 hours
- Can resume from last byte on network failure
- Maximum video size: 256 GB (unlikely to hit)
- Recommended chunk size: 256 KB - 8 MB

**Analytics API:**

- Data delayed by 24-48 hours (not real-time)
- Retention data only available for videos with 100+ views in 30 days
- Demographics require 100+ views and 1% threshold per group
- Some metrics require YouTube Partner Program enrollment

**Scheduling:**

- `publishAt` can only be set at upload time
- Cannot reschedule after upload (limitation of YouTube API)
- Timezone must be UTC in API, convert from user's timezone
- Maximum 6 months in future

**Playlists:**

- Maximum 5,000 playlists per channel
- Maximum 5,000 videos per playlist
- Position parameter for ordering (0-indexed)

### Quota Management

**Cost per operation (units):**

- Video upload: 1,600
- Video update: 50
- Comment fetch: 1
- Comment reply: 50
- Playlist create: 50
- Analytics query: 1

**Default quota:** 10,000 units/day

**Recommendations:**

1. Request quota increase to 50,000 units/day for production
2. Implement user-based rate limiting (max 3 uploads/day per user)
3. Cache analytics for 6 hours minimum
4. Batch comment operations where possible

### User Experience

**Video Upload Flow:**

1. User selects video file
2. Enter metadata (title, description, tags)
3. Select privacy and scheduling
4. Upload initiates (show progress bar)
5. Upload completes (video ID returned)
6. Processing starts (show status)
7. User can navigate away
8. Notification when processing completes (~10-30 minutes)

**Comment Management:**

- Real-time refresh not necessary (manual refresh button)
- Pagination for videos with 100+ comments
- Nested replies displayed inline
- Moderation actions require confirmation

**Analytics:**

- Date range picker (last 7/30/90 days, custom)
- Visual charts (Chart.js or Recharts)
- Export to CSV option
- Comparison mode (compare periods)

---

## Conclusion

This implementation completes the YouTube integration by adding the five missing features:

1. Video upload with resumable protocol
2. Comment management with bulk actions
3. Scheduled publishing with timezone support
4. Advanced analytics via YouTube Analytics API
5. Playlist management

The existing foundation (OAuth, client library, basic metrics) is solid and working. The new features integrate seamlessly with the existing architecture and follow the same patterns used for other platforms.

**Key Priorities:**

1. **Video upload first** (highest user demand, enables other features)
2. **Analytics second** (showcases platform value)
3. **Comment management third** (engagement tool)
4. **Playlists fourth** (organization feature)
5. **Scheduling** integrated throughout

**Estimated Total Effort:** 15-20 days (3-4 weeks)

**Risk Level:** Medium (resumable upload complexity, API quotas)

**Business Impact:** High (completes major platform integration, competitive feature parity)

---

_Plan created: 2026-01-29_
_Ready for stakeholder review and approval_

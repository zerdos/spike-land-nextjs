// Transpiler Service - code transpilation for spike.land
//
// This file is auto-generated by `node build.mjs` which bundles
// src/index.js + esbuild-wasm into a single workerd-compatible module.
//
// If running without the build step, this fallback provides basic
// regex-based type stripping (no JSX support).

let esbuildAvailable = false;
let transformFn = null;

// Try to use esbuild-wasm if available (set up by build.mjs)
try {
  const mod = await import("esbuild-wasm-module");
  if (mod) esbuildAvailable = true;
} catch {
  // esbuild not bundled - use fallback
}

function jsonResponse(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function errorResponse(message, status = 500) {
  return jsonResponse({ error: message }, status);
}

// Fallback transpiler: strips TypeScript type annotations.
// Does NOT handle JSX - use the bundled version for full support.
function fallbackTranspile(code) {
  let result = code;
  // Strip simple type annotations
  result = result
    .replace(/:\s*(string|number|boolean|any|void|never|undefined|null)\b/g, "")
    .replace(/:\s*(string|number|boolean|any|void|never|undefined|null)\[\]/g, "")
    .replace(/<(string|number|boolean|any)>/g, "");

  return {
    code: result,
    warnings: ["Using fallback transpiler - run `node build.mjs` in workers/services/transpiler/ for full esbuild-wasm support"],
  };
}

async function transpileCode(code, options = {}) {
  if (transformFn) {
    const result = await transformFn(code, {
      loader: "tsx",
      format: "esm",
      treeShaking: true,
      platform: "browser",
      minify: false,
      charset: "utf8",
      keepNames: true,
      target: "es2024",
      tsconfigRaw: {
        compilerOptions: {
          jsx: "react-jsx",
          jsxFragmentFactory: "Fragment",
          jsxImportSource: "@emotion/react",
        },
      },
      ...options,
    });
    return { code: result.code, warnings: result.warnings?.map(w => w.text) || [] };
  }
  return fallbackTranspile(code);
}

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const { pathname } = url;

    try {
      // POST /index.ts - transpile raw code from body
      if (pathname === "/index.ts" && request.method === "POST") {
        const code = await request.text();
        if (!code) return errorResponse("Empty request body", 400);
        const result = await transpileCode(code);
        return new Response(result.code, {
          headers: {
            "Content-Type": "application/javascript",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Headers": "*",
            "Cache-Control": "no-cache",
          },
        });
      }

      // GET /index.ts?codeSpace={id}&origin={origin}
      if (pathname === "/index.ts" && request.method === "GET") {
        const codeSpace = url.searchParams.get("codeSpace");
        const origin = url.searchParams.get("origin") || url.origin;
        if (!codeSpace) return errorResponse("Missing codeSpace parameter", 400);

        try {
          const codeResp = await fetch(`${origin}/api-v1/${codeSpace}/code`);
          if (!codeResp.ok) return errorResponse(`Failed to fetch code: ${codeResp.status}`, 502);
          const code = await codeResp.text();
          const result = await transpileCode(code);
          return new Response(result.code, {
            headers: {
              "Content-Type": "application/javascript",
              "Access-Control-Allow-Origin": "*",
              "Cache-Control": "no-cache",
            },
          });
        } catch (err) {
          return errorResponse(`Fetch/transpile failed: ${err.message}`, 502);
        }
      }

      // POST /transpile - transpile with options
      if (pathname === "/transpile" && request.method === "POST") {
        const contentType = request.headers.get("Content-Type") || "";
        let code, options = {};

        if (contentType.includes("application/json")) {
          const body = await request.json();
          code = body.code;
          if (body.loader) options.loader = body.loader;
          if (body.minify !== undefined) options.minify = body.minify;
          if (body.format) options.format = body.format;
          if (body.target) options.target = body.target;
        } else {
          code = await request.text();
        }

        if (!code) return errorResponse("No code provided", 400);
        const result = await transpileCode(code, options);
        return jsonResponse({ code: result.code, warnings: result.warnings });
      }

      // Health check
      if (pathname === "/health") {
        return jsonResponse({
          status: "ok",
          engine: esbuildAvailable ? "esbuild-wasm" : "fallback",
        });
      }

      return errorResponse("Not found", 404);

    } catch (err) {
      console.error("[transpiler] Error:", err);
      return errorResponse(`Transpilation failed: ${err.message}`, 500);
    }
  },
};

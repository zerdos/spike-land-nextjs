/**
 * /create App Generator MCP Tools
 *
 * Search, classify, and manage AI-generated React apps from the /create feature.
 */

import { z } from "zod";
import type { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import type { ToolRegistry } from "../tool-registry";
import { safeToolCall, textResult } from "./tool-helpers";

const SearchAppsSchema = z.object({
  query: z.string().min(1).describe("Search query to match against app title, description, or slug."),
  limit: z.number().int().min(1).max(50).optional().describe("Max results (default 10)."),
});

const GetAppSchema = z.object({
  slug: z.string().min(1).describe("Unique slug of the created app."),
});

const ClassifyIdeaSchema = z.object({
  text: z.string().min(1).max(2000).describe("App idea text to classify into a slug and category."),
});

const CheckHealthSchema = z.object({
  codespace_id: z.string().min(1).describe("Codespace ID to check health for."),
});

const ListAppsSchema = z.object({
  limit: z.number().int().min(1).max(50).optional().describe("Max results (default 10)."),
});

const GetAppStatusSchema = z.object({
  slug: z.string().min(1).describe("Unique slug of the created app."),
});

export function registerCreateTools(
  registry: ToolRegistry,
  _userId: string,
): void {
  registry.register({
    name: "create_search_apps",
    description:
      "Search published /create apps by title, description, or slug. " +
      "Results are ordered by popularity (view count).",
    category: "create",
    tier: "free",
    inputSchema: SearchAppsSchema.shape,
    handler: async ({
      query,
      limit = 10,
    }: z.infer<typeof SearchAppsSchema>): Promise<CallToolResult> =>
      safeToolCall("create_search_apps", async () => {
        const prisma = (await import("@/lib/prisma")).default;

        const apps = await prisma.createdApp.findMany({
          where: {
            status: "PUBLISHED",
            OR: [
              { title: { contains: query, mode: "insensitive" } },
              { description: { contains: query, mode: "insensitive" } },
              { slug: { contains: query, mode: "insensitive" } },
            ],
          },
          select: {
            slug: true,
            title: true,
            description: true,
            codespaceUrl: true,
            viewCount: true,
            generatedAt: true,
          },
          orderBy: { viewCount: "desc" },
          take: limit,
        });

        if (apps.length === 0) {
          return textResult(`No apps found matching "${query}".`);
        }

        let text = `**Found ${apps.length} app(s) matching "${query}":**\n\n`;
        for (const app of apps) {
          text += `- **${app.title}** (\`${app.slug}\`)\n`;
          text += `  ${app.description.slice(0, 150)}\n`;
          text += `  Views: ${app.viewCount} | URL: ${app.codespaceUrl}\n\n`;
        }

        return textResult(text);
      }),
  });

  registry.register({
    name: "create_get_app",
    description:
      "Get full details for a specific /create app by its slug, " +
      "including the prompt used to generate it.",
    category: "create",
    tier: "free",
    inputSchema: GetAppSchema.shape,
    handler: async ({
      slug,
    }: z.infer<typeof GetAppSchema>): Promise<CallToolResult> =>
      safeToolCall("create_get_app", async () => {
        const prisma = (await import("@/lib/prisma")).default;

        const app = await prisma.createdApp.findUnique({
          where: { slug },
          include: {
            generatedBy: {
              select: { id: true, name: true },
            },
          },
        });

        if (!app) {
          return textResult(`**Error: NOT_FOUND**\nNo app found with slug "${slug}".\n**Retryable:** false`);
        }

        let text = `**${app.title}**\n\n`;
        text += `**Slug:** ${app.slug}\n`;
        text += `**Status:** ${app.status}\n`;
        text += `**Description:** ${app.description}\n`;
        text += `**Codespace ID:** ${app.codespaceId}\n`;
        text += `**Codespace URL:** ${app.codespaceUrl}\n`;
        text += `**Views:** ${app.viewCount}\n`;
        text += `**Generated:** ${app.generatedAt.toISOString()}\n`;
        if (app.generatedBy) {
          text += `**Generated By:** ${app.generatedBy.name || app.generatedBy.id}\n`;
        }
        text += `**Prompt Used:** ${app.promptUsed.slice(0, 500)}\n`;
        if (app.outgoingLinks.length > 0) {
          text += `**Links:** ${app.outgoingLinks.join(", ")}\n`;
        }

        return textResult(text);
      }),
  });

  registry.register({
    name: "create_classify_idea",
    description:
      "Classify an app idea into a URL slug and category using AI. " +
      "Returns status (ok/blocked/unclear), slug, category, and reason.",
    category: "create",
    tier: "free",
    inputSchema: ClassifyIdeaSchema.shape,
    handler: async ({
      text,
    }: z.infer<typeof ClassifyIdeaSchema>): Promise<CallToolResult> =>
      safeToolCall("create_classify_idea", async () => {
        const { classifyInput } = await import("@/lib/create/slug-classifier");

        const result = await classifyInput(text);

        let output = `**Classification Result**\n\n`;
        output += `**Status:** ${result.status}\n`;
        output += `**Slug:** ${result.slug || "(none)"}\n`;
        output += `**Category:** ${result.category || "(none)"}\n`;
        if (result.reason) {
          output += `**Reason:** ${result.reason}\n`;
        }

        return textResult(output);
      }),
  });

  registry.register({
    name: "create_check_health",
    description:
      "Check if a codespace is healthy (has real, non-default content). " +
      "Returns true/false.",
    category: "create",
    tier: "free",
    inputSchema: CheckHealthSchema.shape,
    handler: async ({
      codespace_id,
    }: z.infer<typeof CheckHealthSchema>): Promise<CallToolResult> =>
      safeToolCall("create_check_health", async () => {
        const { isCodespaceHealthy } = await import("@/lib/create/codespace-health");

        const healthy = await isCodespaceHealthy(codespace_id);

        return textResult(
          `**Codespace Health Check**\n\n` +
          `**ID:** ${codespace_id}\n` +
          `**Healthy:** ${healthy}`,
        );
      }),
  });

  registry.register({
    name: "create_list_top_apps",
    description:
      "List the most popular published /create apps by view count. " +
      "Only healthy codespaces are included.",
    category: "create",
    tier: "free",
    inputSchema: ListAppsSchema.shape,
    handler: async ({
      limit = 10,
    }: z.infer<typeof ListAppsSchema>): Promise<CallToolResult> =>
      safeToolCall("create_list_top_apps", async () => {
        const prisma = (await import("@/lib/prisma")).default;
        const { filterHealthyCodespaces } = await import("@/lib/create/codespace-health");

        // Fetch more than needed to account for unhealthy ones being filtered out
        const apps = await prisma.createdApp.findMany({
          where: { status: "PUBLISHED" },
          select: {
            slug: true,
            title: true,
            description: true,
            codespaceId: true,
            codespaceUrl: true,
            viewCount: true,
          },
          orderBy: { viewCount: "desc" },
          take: limit * 2,
        });

        const healthy = await filterHealthyCodespaces(apps);
        const result = healthy.slice(0, limit);

        if (result.length === 0) {
          return textResult("No healthy published apps found.");
        }

        let text = `**Top ${result.length} App(s) by Views:**\n\n`;
        for (const app of result) {
          text += `- **${app.title}** (\`${app.slug}\`) â€” ${app.viewCount} views\n`;
          text += `  ${app.description.slice(0, 120)}\n`;
          text += `  URL: ${app.codespaceUrl}\n\n`;
        }

        return textResult(text);
      }),
  });

  registry.register({
    name: "create_list_recent_apps",
    description:
      "List the most recently generated published /create apps. " +
      "Only healthy codespaces are included.",
    category: "create",
    tier: "free",
    inputSchema: ListAppsSchema.shape,
    handler: async ({
      limit = 10,
    }: z.infer<typeof ListAppsSchema>): Promise<CallToolResult> =>
      safeToolCall("create_list_recent_apps", async () => {
        const prisma = (await import("@/lib/prisma")).default;
        const { filterHealthyCodespaces } = await import("@/lib/create/codespace-health");

        const apps = await prisma.createdApp.findMany({
          where: { status: "PUBLISHED" },
          select: {
            slug: true,
            title: true,
            description: true,
            codespaceId: true,
            codespaceUrl: true,
            viewCount: true,
            generatedAt: true,
          },
          orderBy: { generatedAt: "desc" },
          take: limit * 2,
        });

        const healthy = await filterHealthyCodespaces(apps);
        const result = healthy.slice(0, limit);

        if (result.length === 0) {
          return textResult("No healthy recent apps found.");
        }

        let text = `**${result.length} Most Recent App(s):**\n\n`;
        for (const app of result) {
          text += `- **${app.title}** (\`${app.slug}\`)\n`;
          text += `  ${app.description.slice(0, 120)}\n`;
          text += `  Generated: ${app.generatedAt!.toISOString()} | Views: ${app.viewCount}\n`;
          text += `  URL: ${app.codespaceUrl}\n\n`;
        }

        return textResult(text);
      }),
  });

  registry.register({
    name: "create_get_app_status",
    description:
      "Quick status check for a /create app. " +
      "Returns GENERATING, PUBLISHED, or FAILED with the codespace URL.",
    category: "create",
    tier: "free",
    inputSchema: GetAppStatusSchema.shape,
    handler: async ({
      slug,
    }: z.infer<typeof GetAppStatusSchema>): Promise<CallToolResult> =>
      safeToolCall("create_get_app_status", async () => {
        const prisma = (await import("@/lib/prisma")).default;

        const app = await prisma.createdApp.findUnique({
          where: { slug },
          select: {
            slug: true,
            title: true,
            status: true,
            codespaceUrl: true,
          },
        });

        if (!app) {
          return textResult(`**Error: NOT_FOUND**\nNo app found with slug "${slug}".\n**Retryable:** false`);
        }

        return textResult(
          `**App Status**\n\n` +
          `**Title:** ${app.title}\n` +
          `**Slug:** ${app.slug}\n` +
          `**Status:** ${app.status}\n` +
          `**URL:** ${app.codespaceUrl}`,
        );
      }),
  });
}

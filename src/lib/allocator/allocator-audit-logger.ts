import prisma from "@/lib/prisma";
import type {
  AllocatorAuditLog,
  AllocatorAutopilotConfig,
  AllocatorDecisionOutcome,
  AllocatorDecisionType,
  Prisma,
} from "@prisma/client";
import type { BudgetRecommendation, CampaignPerformanceAnalysis } from "./allocator-types";

export type AllocatorAuditSearchOptions = {
  workspaceId: string;
  campaignId?: string;
  executionId?: string;
  decisionType?: AllocatorDecisionType;
  decisionOutcome?: AllocatorDecisionOutcome;
  correlationId?: string;
  startDate?: Date;
  endDate?: Date;
  limit?: number;
  offset?: number;
};

export type AllocatorAuditLogCreateInput =
  & Omit<
    Prisma.AllocatorAuditLogCreateInput,
    "workspace" | "execution" | "createdAt" | "id"
  >
  & {
    workspaceId: string;
    executionId?: string;
  };

/**
 * Service for logging Allocator Autopilot decisions and execution steps.
 * Provides a comprehensive audit trail for AI budget allocation.
 */
export class AllocatorAuditLogger {
  /**
   * Log a comprehensive audit entry
   */
  async log(data: AllocatorAuditLogCreateInput): Promise<AllocatorAuditLog> {
    try {
      return await prisma.allocatorAuditLog.create({
        data,
      });
    } catch (error) {
      console.error("Failed to create allocator audit log", error);
      // Logs errors and rethrows to ensure calling services are aware of failures.
      throw error;
    }
  }

  /**
   * Log when a recommendation is generated by the AI
   */
  async logRecommendationGenerated({
    workspaceId,
    campaignId,
    recommendation,
    performance,
    config,
    aiReasoning,
    supportingData,
    confidence,
    correlationId,
    triggeredBy,
    userId,
  }: {
    workspaceId: string;
    campaignId: string;
    recommendation: BudgetRecommendation;
    performance: CampaignPerformanceAnalysis;
    config?: AllocatorAutopilotConfig; // Snapshot of config
    aiReasoning?: string;
    supportingData?: Record<string, unknown>;
    confidence?: string;
    correlationId: string;
    triggeredBy: string;
    userId?: string;
  }): Promise<AllocatorAuditLog> {
    return this.log({
      workspaceId,
      campaignId,
      decisionType: "RECOMMENDATION_GENERATED",
      decisionOutcome: "EXECUTED",

      recommendationSnapshot: recommendation as unknown as Prisma.InputJsonValue,
      performanceSnapshot: performance as unknown as Prisma.InputJsonValue,
      configSnapshot: config as unknown as Prisma.InputJsonValue,

      aiReasoning: aiReasoning || recommendation.reason,
      supportingData:
        (supportingData || { evidence: recommendation.supportingData }) as Prisma.InputJsonValue,
      confidence: confidence || recommendation.confidence,

      correlationId,
      triggeredBy,
      userId,
    });
  }

  /**
   * Log guardrail evaluation results
   */
  async logGuardrailEvaluation({
    workspaceId,
    campaignId,
    decisionType,
    outcome,
    guardrailResults,
    recommendation,
    correlationId,
    triggeredBy,
    userId,
  }: {
    workspaceId: string;
    campaignId: string;
    decisionType: AllocatorDecisionType; // e.g. RECOMMENDATION_EVALUATED or GUARDRAIL_TRIGGERED
    outcome: AllocatorDecisionOutcome; // APPROVED, REJECTED, etc.
    guardrailResults: Record<string, unknown>; // { passed: boolean, checks: [...] }
    recommendation?: BudgetRecommendation;
    correlationId: string;
    triggeredBy: string;
    userId?: string;
  }): Promise<AllocatorAuditLog> {
    return this.log({
      workspaceId,
      campaignId,
      decisionType,
      decisionOutcome: outcome,
      guardrailEvaluation: guardrailResults as Prisma.InputJsonValue,
      recommendationSnapshot: recommendation as unknown as Prisma.InputJsonValue,
      correlationId,
      triggeredBy,
      userId,
    });
  }

  /**
   * Log execution start/completion
   */
  async logExecution({
    workspaceId,
    campaignId,
    executionId,
    stage,
    outcome,
    previousState,
    newState,
    correlationId,
    triggeredBy,
    userId,
    error,
  }: {
    workspaceId: string;
    campaignId: string;
    executionId: string;
    stage: "STARTED" | "COMPLETED" | "FAILED" | "SKIPPED";
    outcome: AllocatorDecisionOutcome;
    previousState?: Record<string, unknown>;
    newState?: Record<string, unknown>;
    correlationId: string;
    triggeredBy: string;
    userId?: string;
    error?: string;
  }): Promise<AllocatorAuditLog> {
    let decisionType: AllocatorDecisionType = "EXECUTION_STARTED";
    switch (stage) {
      case "COMPLETED":
        decisionType = "EXECUTION_COMPLETED";
        break;
      case "FAILED":
        decisionType = "EXECUTION_FAILED";
        break;
      case "SKIPPED":
        decisionType = "EXECUTION_SKIPPED";
        break;
    }

    return this.log({
      workspaceId,
      campaignId,
      executionId,
      decisionType,
      decisionOutcome: outcome,
      previousState: previousState as Prisma.InputJsonValue,
      newState: newState as Prisma.InputJsonValue,
      correlationId,
      triggeredBy,
      userId,
      supportingData: error ? { error } : undefined,
    });
  }

  /**
   * Log rollback events
   */
  async logRollback({
    workspaceId,
    campaignId,
    executionId,
    originalExecutionId,
    stage,
    correlationId,
    userId,
  }: {
    workspaceId: string;
    campaignId: string;
    executionId?: string; // The rollback execution itself
    originalExecutionId: string; // What we rolled back
    stage: "INITIATED" | "COMPLETED";
    correlationId: string;
    userId: string;
  }): Promise<AllocatorAuditLog> {
    return this.log({
      workspaceId,
      campaignId,
      executionId,
      decisionType: stage === "INITIATED" ? "ROLLBACK_INITIATED" : "ROLLBACK_COMPLETED",
      decisionOutcome: stage === "INITIATED" ? "EXECUTED" : "ROLLED_BACK",
      supportingData: { originalExecutionId },
      correlationId,
      triggeredBy: "MANUAL", // Rollbacks are usually manual
      userId,
    });
  }

  /**
   * Search audit logs
   */
  async search(
    options: AllocatorAuditSearchOptions,
  ): Promise<{ logs: AllocatorAuditLog[]; total: number; }> {
    const {
      workspaceId,
      campaignId,
      executionId,
      decisionType,
      decisionOutcome,
      correlationId,
      startDate,
      endDate,
      limit = 50,
      offset = 0,
    } = options;

    const where: Prisma.AllocatorAuditLogWhereInput = {
      workspaceId,
      campaignId,
      executionId,
      decisionType,
      decisionOutcome,
      correlationId,
    };

    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) (where.createdAt as Prisma.DateTimeFilter).gte = startDate;
      if (endDate) (where.createdAt as Prisma.DateTimeFilter).lte = endDate;
    }

    const [logs, total] = await Promise.all([
      prisma.allocatorAuditLog.findMany({
        where,
        orderBy: { createdAt: "desc" },
        take: limit,
        skip: offset,
        include: {
          execution: true,
        },
      }),
      prisma.allocatorAuditLog.count({ where }),
    ]);

    return { logs, total };
  }

  /**
   * Get logs for a specific correlation ID (trace a full run)
   */
  async getByCorrelationId(
    workspaceId: string,
    correlationId: string,
  ): Promise<AllocatorAuditLog[]> {
    return prisma.allocatorAuditLog.findMany({
      where: {
        workspaceId,
        correlationId,
      },
      orderBy: { createdAt: "asc" },
    });
  }
}

export const allocatorAuditLogger = new AllocatorAuditLogger();

import type { LearnItContent } from "@/generated/prisma";
import prisma from "@/lib/prisma";

import { createParentChildRelation, createRelationsFromWikiLinks } from "./relation-service";
import { parseWikiLinks } from "./wiki-links";

export type CreateContentInput = {
  path: string[];
  slug: string;
  parentSlug: string | null;
  title: string;
  description: string;
  content: string;
  generatedById?: string;
  aiModel?: string;
};

export async function getLearnItContent(slug: string): Promise<LearnItContent | null> {
  const content = await prisma.learnItContent.findUnique({
    where: { slug },
  });

  if (content) {
    // Async increment view count
    void prisma.learnItContent.update({
      where: { id: content.id },
      data: { viewCount: { increment: 1 } },
    }).catch(console.error);
  }

  return content;
}

export async function searchLearnItContent(query: string, limit = 10) {
  return prisma.learnItContent.findMany({
    where: {
      OR: [
        { title: { contains: query, mode: "insensitive" } },
        { description: { contains: query, mode: "insensitive" } },
        // Simple path matching
        { slug: { contains: query.toLowerCase(), mode: "insensitive" } },
      ],
      status: "PUBLISHED",
    },
    take: limit,
    orderBy: { viewCount: "desc" },
    select: {
      slug: true,
      title: true,
      description: true,
      path: true,
    },
  });
}

export async function createOrUpdateContent(input: CreateContentInput) {
  const { links } = parseWikiLinks(input.content);

  // Verify user exists to avoid FK constraint violation (P2003)
  let validGeneratedById: string | undefined = undefined;
  if (input.generatedById) {
    const user = await prisma.user.findUnique({
      where: { id: input.generatedById },
      select: { id: true },
    });
    validGeneratedById = user ? input.generatedById : undefined;
  }

  const data = {
    ...input,
    generatedById: validGeneratedById,
    wikiLinks: links,
  };

  const content = await prisma.learnItContent.upsert({
    where: { slug: input.slug },
    create: {
      ...data,
      status: "PUBLISHED",
    },
    update: {
      ...data,
      status: "PUBLISHED",
      updatedAt: new Date(),
    },
  });

  // Create graph relationships asynchronously (don't block the response)
  void Promise.all([
    // Create parent-child relationship if this topic has a parent
    createParentChildRelation(content.id, input.parentSlug),
    // Create relationships from wiki links in content
    createRelationsFromWikiLinks(content.id, links),
  ]).catch((error) => {
    console.error("Failed to create relations for content:", error);
  });

  return content;
}

export async function markAsGenerating(slug: string, path: string[], userId?: string) {
  // Verify user exists to avoid FK constraint violation (P2003)
  // This can happen when handleSignIn() allows auth but fails to create the DB record
  let validUserId: string | undefined = undefined;
  if (userId) {
    const user = await prisma.user.findUnique({ where: { id: userId }, select: { id: true } });
    validUserId = user ? userId : undefined;
  }

  return prisma.learnItContent.upsert({
    where: { slug },
    create: {
      slug,
      path,
      parentSlug: path.length > 1 ? path.slice(0, -1).join("/") : null,
      title: "Generating...",
      description: "Content is being generated by AI.",
      content: "Please wait while we generate this topic for you.",
      status: "GENERATING",
      generatedById: validUserId,
    },
    update: {
      status: "GENERATING",
      generatedAt: new Date(),
    },
  });
}

export async function markAsFailed(slug: string) {
  return prisma.learnItContent.update({
    where: { slug },
    data: {
      status: "FAILED",
      content: "Generation failed. Please try again.",
    },
  });
}

export async function getRecentContent(limit = 6) {
  return prisma.learnItContent.findMany({
    where: { status: "PUBLISHED" },
    orderBy: { createdAt: "desc" },
    take: limit,
  });
}

export async function getPopularContent(limit = 6) {
  return prisma.learnItContent.findMany({
    where: { status: "PUBLISHED" },
    orderBy: { viewCount: "desc" },
    take: limit,
  });
}

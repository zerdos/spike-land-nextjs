import { synthesizeSpeechWithTimestamps } from "../../../src/lib/tts/elevenlabs-client";
import type { NarrationWord } from "../../../src/lib/tts/elevenlabs-client";
import fs from "fs";
import path from "path";
import dotenv from "dotenv";
import { createRequire } from "module";

const require = createRequire(import.meta.url);

// Load env vars from root .env.local or .env
const envPath = fs.existsSync(path.join(__dirname, "../../../.env.local"))
  ? path.join(__dirname, "../../../.env.local")
  : path.join(__dirname, "../../../.env");
dotenv.config({ path: envPath });

// Import narration text — keys match VCP_DURATIONS scene IDs
const { NARRATION_TEXT } = require("../src/lib/narration") as {
  NARRATION_TEXT: Record<string, string>;
};

const OUTPUT_DIR = path.join(__dirname, "../public/audio");
const ROOT_AUDIO_DIR = path.join(__dirname, "../../../public/audio");
const TIMESTAMPS_OUTPUT = path.join(
  __dirname,
  "../src/lib/narration-timestamps.ts",
);

interface SceneTimestampData {
  sceneId: string;
  words: NarrationWord[];
  audioDurationSeconds: number;
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function generateWithRetry(
  sceneId: string,
  text: string,
  retries = 3,
): Promise<{ audio: Buffer; words: NarrationWord[]; audioDurationSeconds: number }> {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      return await synthesizeSpeechWithTimestamps(text);
    } catch (error: unknown) {
      const message = error instanceof Error ? error.message : String(error);
      const is429 = message.includes("429");
      if (is429 && attempt < retries) {
        const delay = attempt * 5000;
        console.warn(
          `  Rate limited on ${sceneId}, retrying in ${delay / 1000}s (attempt ${attempt}/${retries})...`,
        );
        await sleep(delay);
      } else if (attempt < retries) {
        console.warn(
          `  Error on ${sceneId}: ${message}, retrying (attempt ${attempt}/${retries})...`,
        );
        await sleep(2000);
      } else {
        throw error;
      }
    }
  }
  throw new Error("Unreachable");
}

function generateTimestampsFile(scenes: SceneTimestampData[]): string {
  const lines: string[] = [
    '// Auto-generated by scripts/generate-audio.ts — do not edit manually',
    'import type { NarrationWord } from "./narration";',
    '',
    'export interface SceneTimestamps {',
    '  sceneId: string;',
    '  words: NarrationWord[];',
    '  audioDurationSeconds: number;',
    '}',
    '',
    'export const NARRATION_TIMESTAMPS: Record<string, SceneTimestamps> = {',
  ];

  for (const scene of scenes) {
    lines.push(`  ${scene.sceneId}: {`);
    lines.push(`    sceneId: "${scene.sceneId}",`);
    lines.push(
      `    audioDurationSeconds: ${scene.audioDurationSeconds.toFixed(3)},`,
    );
    lines.push(`    words: [`);
    for (const word of scene.words) {
      lines.push(
        `      { word: ${JSON.stringify(word.word)}, start: ${word.start.toFixed(3)}, end: ${word.end.toFixed(3)} },`,
      );
    }
    lines.push(`    ],`);
    lines.push(`  },`);
  }

  lines.push("};");
  lines.push("");

  return lines.join("\n");
}

async function main() {
  // Parse --scene=<sceneId> CLI flag
  const sceneArg = process.argv.find((a) => a.startsWith("--scene="));
  const targetScene = sceneArg ? sceneArg.split("=")[1] : null;

  const sceneIds = Object.keys(NARRATION_TEXT);

  if (targetScene && !sceneIds.includes(targetScene)) {
    console.error(
      `Unknown scene: ${targetScene}. Available: ${sceneIds.join(", ")}`,
    );
    process.exit(1);
  }

  const scenesToGenerate = targetScene ? [targetScene] : sceneIds;

  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }
  if (!fs.existsSync(ROOT_AUDIO_DIR)) {
    fs.mkdirSync(ROOT_AUDIO_DIR, { recursive: true });
  }

  // Load existing timestamps if doing single-scene regeneration
  let allTimestamps: SceneTimestampData[] = [];
  if (targetScene && fs.existsSync(TIMESTAMPS_OUTPUT)) {
    try {
      // eslint-disable-next-line @typescript-eslint/no-require-imports
      const existing = require(TIMESTAMPS_OUTPUT);
      allTimestamps = Object.values(
        existing.NARRATION_TIMESTAMPS,
      ) as SceneTimestampData[];
      // Remove the scene we're regenerating
      allTimestamps = allTimestamps.filter((s) => s.sceneId !== targetScene);
    } catch {
      // If we can't parse existing file, regenerate all
    }
  }

  console.log(
    `Generating audio for ${scenesToGenerate.length} scene(s)...\n`,
  );

  for (let i = 0; i < scenesToGenerate.length; i++) {
    const sceneId = scenesToGenerate[i];
    const text = NARRATION_TEXT[sceneId];

    console.log(
      `[${i + 1}/${scenesToGenerate.length}] ${sceneId} (${text.length} chars)`,
    );

    try {
      const { audio, words, audioDurationSeconds } = await generateWithRetry(
        sceneId,
        text,
      );

      const fileName = `vcp-${sceneId}.mp3`;
      const filePath = path.join(OUTPUT_DIR, fileName);
      const rootPath = path.join(ROOT_AUDIO_DIR, fileName);
      fs.writeFileSync(filePath, audio);
      fs.writeFileSync(rootPath, audio);
      console.log(
        `  Saved ${fileName} (${(audio.length / 1024).toFixed(1)} KB, ${audioDurationSeconds.toFixed(1)}s, ${words.length} words)`,
      );

      allTimestamps.push({ sceneId, words, audioDurationSeconds });

      // Rate limit: 1s delay between API calls
      if (i < scenesToGenerate.length - 1) {
        await sleep(1000);
      }
    } catch (error) {
      console.error(`  FAILED: ${sceneId}:`, error);
      process.exit(1);
    }
  }

  // Sort timestamps by scene order
  const orderedTimestamps = sceneIds
    .map((id) => allTimestamps.find((s) => s.sceneId === id))
    .filter(Boolean) as SceneTimestampData[];

  // Write timestamps file
  const tsContent = generateTimestampsFile(orderedTimestamps);
  fs.writeFileSync(TIMESTAMPS_OUTPUT, tsContent);
  console.log(`\nTimestamps written to ${TIMESTAMPS_OUTPUT}`);

  console.log("\nDone!");
}

main();

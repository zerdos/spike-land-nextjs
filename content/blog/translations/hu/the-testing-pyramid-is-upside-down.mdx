---
title: "A Tesztpiramis Fejre Áll"
slug: "the-testing-pyramid-is-upside-down"
description: "Mi lenne, ha a tesztcsomagod legrosszabb része -- a lassú, instabil E2E tesztek -- unit teszt sebességgel futhatnának? Az MCP-k lehetnek az a válasz, amire senki nem számított."
date: "2026-02-13"
author: "Zoltan Erdos"
category: "Fejlesztői Élmény"
tags: ["testing", "mcp", "unit-testing", "e2e", "architektura", "agents"]
featured: true
language: "hu"
---

*Merklik László (1975--2018) emlékére ajánlva, aki túl korán hagyott itt minket. Alig múlt negyven, amikor a rák elvitte. Az Emarsys -- amelyet később a SAP felvásárolt -- társalapítója és CPO-ja volt, és felépítette Magyarország egyik legmegbecsültebb mérnöki kultúráját. Még egy előadást is tartott "Jobb Minőség Tesztelők Nélkül" címmel, ami úgy tűnik, közvetlen elődje az ebben a cikkben lévő ötleteknek.*

*László volt az a személy, aki miatt érdekelni kezdett a kódolás. Nem csak a csinálása -- hanem hogy törődjek vele. Megtanította, hogy különleges kapcsolat van egy unit teszt és a kód között, amit tesztel: amikor mindkettő helyesen van megírva, az egyik specifikálja a másikat. A teszt megmondja, mit kell a kódnak csinálnia. A kód megmondja, mit kell a tesztnek ellenőriznie. Ugyanannak az igazságnak két nézete.*

*Olyan fejlesztő volt, aki mindenkit jobbá tett maga körül. Olyan, aki az előadások után is maradt, hogy segítsen egy juniornak megjavítani a build-jét. Olyan, aki hitt abban, hogy jól szoftvert írni a tisztelet egy formája -- csapattársaid, felhasználóid, magad iránt. Ez a cikk arról szól, hogy előretoljuk a mesterséget. Az ő dolga is ez volt.*

---

## A Konferencia

Körülbelül tizenöt évvel ezelőtt elmentem egy fejlesztői konferenciára Budapesten. A téma a Jasmine volt -- ami a böngészőben futott, mivel a Node.js maga még nem volt széles körben elfogadott. Ez még azelőtt volt, hogy a Jest felfalta volna a világot, mielőtt a tesztelés minden projekten adottság lett volna. A tesztelést még kellett érvelni.

Az előadó fiatal volt. Ideges energia. Láthatóan nemrég tért meg -- látszott a szemében. Végigvezetett minket, hogyan kapott el néhány tucat unit teszt egy regressziót, ami kiment volna a produkcióba. Megmutatta, hogyan működik a mockolás. Megmutatta, milyen gyors a visszacsatolási hurok. Szinte rezgett.

Aztán valaki a közönségből felemelte a kezét.

"És hogy teszteljük le az UI-t?" -- kérdezte az illető.

Az előadó megállt. Aztán vállat vont.

"Az UI-t? Azt teszteljék a hülyék!" -- válaszolta.

Néhány ember nevetett. A legtöbben bólintottak. Akkoriban észszerűnek tűnt. A unit tesztek lefedték az üzleti logikát. Az UI csak HTML és CSS volt. Megnézed, vagy jónak tűnik, vagy nem. Mit kell automatizálni?

Ez a válasz sokáig velem maradt. Nem azért, mert helytelen volt. Hanem mert majdnem helyes volt -- és a majdnem helyes és a tényleg helyes közötti szakadék az iparágunknak egy évtizednyi fájdalmába került.

---

## Mi Történt Ezután

Elkezdtük tesztelni az UI-t. Természetesen.

Először jött a Selenium. Aztán a Protractor. Aztán a Cypress. Aztán a Playwright. Mindegyik jobb volt az előzőnél. Mindegyik azt ígérte, hogy végre megbízhatóvá teszi a böngésző tesztelést.

És tényleg jobbak lettek. A Playwright különösen egy valóban kiváló eszköz. De az alapvető probléma soha nem múlt el: egy valós böngészőt vezérelsz, valós DOM-ot renderelsz, valós hálózati kérésekre vársz, és reméled, hogy az időzítés összejön. A teljes verem legvastagabb, legkiszámíthatatlanabb rétegén keresztül tesztelsz.

Ezek a tesztek lettek a legrosszabb része minden tesztcsomagnak, amin valaha dolgoztam.

Lassúak. Egy gyors unit teszt csomag másodpercek alatt fut. Egy átfogó E2E csomag perceken -- néha tíz perceken -- át fut. CI-n, párhuzamosítással és újrapróbákkal, olyan pipeline időket nézünk, amik miatt a fejlesztők kontextust váltanak valami másra, míg várnak.

Instabilak. Nem azért, mert az eszközök rosszak, hanem mert a böngészők összetett állapotgépek. Egy teszt, ami lokálisan átmegy, megbukik CI-n, mert az animáció 50ms-sel tovább tartott. Egy teszt, ami tegnap rendben futott, ma megbukik, mert egy harmadik feles szkript lassabban töltődött. Hozzáadod a `waitForSelector`-t. Hozzáadod a `waitForTimeout`-ot. Hozzáadod az újrapróbálási logikát. Már nem az alkalmazásodat teszteled -- hanem a káosszal való szinkronizálási képességedet.

Törékenyek. Változtatsz egy CSS osztályt? A tesztek eltörnek. Áthelyezel egy gombot a bal oldalsávból a felső navba? A tesztek eltörnek. Refaktorálsz egy komponenst, ami azonosan viselkedik, de másként renderel? A tesztek eltörnek. A tesztek az implementációhoz vannak kapcsolva -- pontosan úgy, ahogy a junior fejlesztőknek mondjuk, hogy ne írjanak unit teszteket.

Ez a tesztpiramis. Unit tesztek az alapnál: gyorsak, olcsók, sok. Integrációs tesztek középen: közepes sebesség, közepes költség, közepes szám. E2E tesztek a tetején: lassúak, drágák, kevés.

Mindenki tudja, hogy a piramis teteje fájdalmas. Elfogadtuk az üzletelés költségeként. Szükséged van *néhány* E2E tesztre, mert ez az egyetlen mód a teljes felhasználói folyamat ellenőrzésére. Az API tesztek nem elégek -- végpontokat tesztelnek, nem az üzleti logikai folyamatokat, amik összefűzik ezeket a végpontokat valami olyanná, amit egy felhasználó tényleg csinál.

Vagy így gondoltuk.

---

## A Felismerés

Íme a dolog az E2E tesztekről, amiről senki nem beszél elég világosan: a legtöbbjük nem ténylegesen a böngészőt teszteli. Az üzleti logikát tesztelik a böngészőn *keresztül*.

Gondolj bele, mit is ellenőriz tényleg egy tipikus E2E teszt. "A felhasználó bejelentkezik, a beállításokhoz navigál, megváltoztatja az emailjét, megerősíti a változtatást, látja a frissített emailt a profil oldalon." Mit is tesztelsz valójában itt? Azt teszteled, hogy az email-változtatási folyamat működik. A bejelentkezés, a navigáció, az űrlapbeküldés, a megerősítés, az állapot frissítés -- ez mind üzleti logika. A böngésző csak a kézbesítési mechanizmus.

Ez nem új megfigyelés. Alistair Cockburn hexagonális architektúrája (2005) amellett érvelt, hogy az alkalmazásokat egyformán vezérelhetőknek kell lenniük felhasználók, programok és teszt szkriptek által. Martin Fowler a mintát "szubkután tesztelésnek" nevezte -- tesztelés közvetlenül az UI alatt. Robert C. Martin Clean Architecture-je ragaszkodott hozzá, hogy az üzleti szabályoknak tesztelhetőknek kell lenniük bármilyen UI nélkül. A felismerés mindig ott volt. Ami hiányzott, az egy szabványosított felület volt, ami gyakorlativá tette legétekben.

Az MCP -- Model Context Protocol -- az a felület. Ez egy szabvány az alkalmazásod képességeinek strukturált eszközökként való kiajánlására. Szöveg be, szöveg ki. Egy ágens kérést küld, ami leírja, mit akar csinálni, az MCP szervered végrehajtja a műveletet és visszaadja az eredményt. Nincs böngésző. Nincs DOM. Nincs CSS szelektor. Nincs időzítési probléma. Ha a felhasználói történeteidet MCP eszközökként írod meg, tesztelhető szerződést hoztál létre az üzleti logikádhoz.

Hadd mutassam meg, mire gondolok.

Tegyük fel, van egy felhasználói történeted: "Egy felhasználó frissítheti az email címét." Az E2E világban a teszt valahogy így néz ki:

```typescript
// Cypress E2E teszt
describe('Email frissitesi folyamat', () => {
  it('lehetove kell tennie a felhasznalonak az email valtoztatast', () => {
    cy.login('test@example.com', 'password123');
    cy.visit('/settings');
    cy.get('[data-testid="email-input"]').clear().type('new@example.com');
    cy.get('[data-testid="save-button"]').click();
    cy.get('[data-testid="confirm-dialog"]').should('be.visible');
    cy.get('[data-testid="confirm-button"]').click();
    cy.get('[data-testid="success-toast"]').should('contain', 'Email updated');
    cy.visit('/profile');
    cy.get('[data-testid="user-email"]').should('contain', 'new@example.com');
  });
});
```

Ez a teszt 5-15 másodpercig fut. CSS szelektoroktól, DOM struktúrától, animációs időzítéstől és hálózati késleltetéstől függ. Megváltoztatod a megerősítő dialógust modalra? A teszt eltörik. Áthelyezed a sikeres üzenetet toast-ról inline alertre? A teszt eltörik.

Most íme ugyanaz az üzleti logika MCP eszközként kiajánlva:

```typescript
// MCP eszkoz definicio
const updateEmailTool = {
  name: 'update_user_email',
  description: 'Update the authenticated user\'s email address',
  inputSchema: {
    type: 'object',
    properties: {
      newEmail: { type: 'string', format: 'email' },
      confirmChange: { type: 'boolean' },
    },
    required: ['newEmail', 'confirmChange'],
  },
  handler: async ({ newEmail, confirmChange }, context) => {
    const user = await context.getAuthenticatedUser();
    if (!user) return { error: 'Not authenticated' };

    if (!confirmChange) {
      return {
        status: 'confirmation_required',
        message: `Confirm email change from ${user.email} to ${newEmail}?`,
      };
    }

    await context.userService.updateEmail(user.id, newEmail);
    return {
      status: 'success',
      message: `Email updated to ${newEmail}`,
      updatedEmail: newEmail,
    };
  },
};
```

És a unit teszt:

```typescript
// Unit teszt az MCP eszkozhoz
describe('update_user_email', () => {
  it('frissiti az emailt megerosites eseten', async () => {
    const context = createMockContext({
      user: { id: '1', email: 'old@example.com' },
    });

    const result = await updateEmailTool.handler(
      { newEmail: 'new@example.com', confirmChange: true },
      context,
    );

    expect(result.status).toBe('success');
    expect(result.updatedEmail).toBe('new@example.com');
    expect(context.userService.updateEmail).toHaveBeenCalledWith(
      '1',
      'new@example.com',
    );
  });

  it('megerositest kovetellen frissites elott', async () => {
    const context = createMockContext({
      user: { id: '1', email: 'old@example.com' },
    });

    const result = await updateEmailTool.handler(
      { newEmail: 'new@example.com', confirmChange: false },
      context,
    );

    expect(result.status).toBe('confirmation_required');
    expect(context.userService.updateEmail).not.toHaveBeenCalled();
  });

  it('elutasitja a nem hitelesitett kereseket', async () => {
    const context = createMockContext({ user: null });

    const result = await updateEmailTool.handler(
      { newEmail: 'new@example.com', confirmChange: true },
      context,
    );

    expect(result.error).toBe('Not authenticated');
  });
});
```

Ez a teszt ezredmásodpercek alatt fut. Nem függ semmilyen DOM struktúrától. Nem érdekli, hogyan néz ki az UI. Pontosan ugyanazt az üzleti logikát teszteli -- az email frissítési folyamatot megerősítéssel -- de unit teszt sebességgel, unit teszt megbízhatósággal.

Nem veszítettél lefedettséget. Elveszítetted a böngészőt.

---

## Az Architektúra Érv

Ez nem csak egy tesztelési trükk. Ez egy architektúrális váltás.

Amikor a felhasználói történeteidet MCP eszközökként ajánlod ki, láncot hozol létre:

**Felhasználói történetek -> MCP eszközök -> Unit-tesztelhető üzleti logika**

Ugyanaz a specifikáció három célt szolgál egyidejűleg:

1. **Felhasználói dokumentáció.** Az MCP eszköz leírások *maguk* a funkció dokumentációd. "Az autentikált felhasználó email címének frissítése" -- ez a specifikáció, sima nyelven, a kódban élve.

2. **Ágens felület.** Bármely AI ágens, ami MCP-n keresztül csatlakozik, most már végre tudja hajtani a felhasználói történeteidet. Az appod ágens-kész, nem azért, mert rácsavartál egy AI funkciót, hanem mert az üzleti logikád elérhető egy strukturált szöveges felületen.

3. **Teszt szerződés.** A bemeneti séma definiálja, mit fogad el az eszköz. A handler definiálja az elvárt viselkedést. A válasz definiálja az elvárt kimenetet. Ez szerződés. Úgy tesztelheted, mint bármely függvényt -- mert függvény *is*.

Hasonló tesztelhetőséget kaphatsz egy egyszerű szolgáltatás rétegből is -- egy jól strukturált `updateUserEmail()` függvény éppen úgy tesztelhető, mint egy MCP handler. De egy szolgáltatás függvény egy urat szolgál: az alkalmazásodat. Egy MCP eszköz hármat szolgál. Ugyanaz a működés a teszt szerződést, az ágens felületedet és a funkció dokumentációd. Egyszer írod meg; három módon terem meg. Ez nem tesztelési trükk. Ez architektúrális erőszorzó.

Ez az a kulcsfontosságú felismerés, aminek a meglátásához évek kellettek: az E2E tesztek fájdalmasságának oka nem az, hogy a böngésző automatizálás nehéz (bár az). Az oka az, hogy rákényszerültünk a böngészőn keresztül menni, mert nem volt más mód teljes felhasználói folyamatok gyakorlására. A böngésző volt az egyetlen felület, ami összekötötte az összes darabot.

Az MCP-k adnak egy második felületet. Egy szöveg-alapút önleíró sémákkal, amiket gépek felfedezhetnek, meghívhatnak és ellenőrizhetnek. Egyet, ami összeköti ugyanazokat a darabokat, de a renderelési réteg, az időzítési problémák és a CSS szelektorok nélkül.

---

## A Harmadik Játékos

László megtanította nekem a dualitást: egy unit teszt és a kódja, ha helyesen vannak megírva, specifikálják egymást. Két játékos, egy igazság.

De azt gondolom, van egy harmadik játékos: a név.

Gondolj a korábbi MCP eszközre: `update_user_email`. Az a név nem csak címke. Korlátozás. Megmondja, mit kell az eszköznek csinálnia és mit nem szabad. Nem küld értesítéseket. Nem frissíti a jelszót. Frissíti a felhasználó emailjét.

A jó elnevezés mindig számított. Egy jól elnevezett függvény korlátozza, mit ír egy fejlesztő. De egy MCP eszköz név korlátozza, amit egy *gép* felfedezhet, meghívhat és tesztelhet. Egy AI ágens, ami az MCP szerveredet böngészi, nem olvassa a forráskódot -- eszköz neveket, leírásokat és sémákat olvas. Ha az `update_user_email` helyesen van elnevezve, egy ágens tudja, mire hívja, anélkül, hogy az implementációt olvasná. A név felfedezhető szerződéssé válik.

Teszt. Kód. Név. Három játékos, egy igazság. A név, a bemeneti séma és a handler háromszöget alkot, ahol minden csúcs korlátozza a másik kettőt. Az első kettővel évtizedekig rendelkeztünk. Az MCP a harmadikat formalizálta valami olyanra, amiről gépek gondolkodni tudnak -- és kiderült, amikor a névnek elég struktúrát adsz ahhoz, hogy gép által olvasható legyen, gép által tesztelhetővé is válik.

---

## Gyakorlati Lépések

Ha éppen egy instabil E2E csomagot bámulsz, íme, hogyan kezdd.

**1. Lépés: Találd meg a legfájdalmasabb E2E tesztjeidet.** Tudod, melyek azok. Amiket háromszor újrafuttatsz, mire átmennek. Amikben `// TODO: ki kell deriteni, miert instabil` kommentek vannak. Amik 30 másodpercig tartanak egyenként.

**2. Lépés: Kérdezd meg, milyen üzleti logikát ellenőriznek valójában.** Hagyd el a kattintásokat, a várakozásokat és a szelektorokat. Mit is ellenőriz ténylegesen a teszt? "A felhasználó lemondhatja az előfizetését." "Az admin kitilthat egy felhasználót." "A fizetési folyamat kezeli az elutasított kártyákat." Ez az üzleti logika.

**3. Lépés: Ajánld ki azt a logikát MCP eszközökként.** Írj MCP eszközt minden üzleti folyamathoz. Definiáld a bemeneti sémát, implementáld a handlert a meglévő szolgáltatásaid felhasználásával, adj vissza strukturált eredményeket. Nem írsz újra semmit -- becsomagolod a meglévő üzleti logikádat egy strukturált felületbe.

**4. Lépés: Írj unit teszteket az MCP eszközökhöz.** Mockold a függőségeket. Teszteld a sikeres útvonalat. Teszteld a hibaeseteket. Teszteld a szélsőséges eseteket. Ezek a tesztek ezredmásodpercek alatt futnak és soha nem lesznek instabilak.

**5. Lépés: Nézd, ahogy az E2E csomagod zsugorodik.** Még mindig szükséged lesz néhány E2E tesztre -- vizuális regressziókhoz, böngésző-specifikus viselkedéshez, integrációs kötésekhez, amik csak valós környezetben jelennek meg (CORS, auth middleware, hidráció). De a számuk dramatikusan csökken. Amik megmaradnak, egyszerűbbek és stabilabbak lesznek, mert nem hordozzák az üzleti logika ellenőrzés súlyát.

Nem helyettesíted az E2E teszteket. Kiveszed belőlük az üzleti logikát. Ami megmarad, az a vizuális füsttesztek vékony rétege -- ami az volt, aminek az E2E teszteknek eleve lenniük kellett volna.

---

## A CI Osztalék

Miután az üzleti logikád MCP eszközökben él, TypeScript-en keresztül szorosan csatolva a frontendedhez, valami figyelemre méltó történik a CI pipeline-oddal.

Futtasd ezt:

```bash
yarn vitest run --changed main
```

A Vitest tudja, mely fájlok változtak a `main` óta. Tudja, mely tesztek importálják azokat a fájlokat. Csak azokat a teszteket futtatja. Az `update_user_email` változtatása az email teszteket futtatja, nem a teljes csomagot. Ez másodperceket vesz igénybe, nem perceket.

De az igazi trükk az, ami ezután jön.

A CI-dnek vannak lefedettségi naplói. Van git előzménye. Tudja, mely MCP eszközök változtak, mely unit tesztek fedik le őket, és mely E2E szcenáriók gyakorolják azokat a folyamatokat. Egy AI reviewer ágens olvashatja ezt a gráfot és döntést hozhat: mely E2E teszteknek kell tényleg futniuk?

Frissítetted a leírást egy teszt fixture fájlban? Nincs szükség E2E tesztekre. Változtattad az email validációs logikát egy MCP eszközben? Futtasd az email-hez kapcsolódó E2E szcenáriókat, hagyd ki a többit. Refaktoráltál egy megosztott segédfüggvényt? Az ágens végigköveti a függőségi gráfot és pontosan az érintett teszteket futtatja -- sem többet, sem kevesebbet.

Ez növekményes review, amit ugyanaz a kapcsolás hajt, ami a unit tesztjeidet gyorssá tette. Az MCP eszköz nevek elég szemantikai kontextust adnak az ágensnek ahhoz, hogy a robbanási sugárról gondolkodjon. Az `update_user_email` változott? Az ágens tudja, hogy az email E2E teszteket kell futtatni. A `list_user_notifications` nem változott? Hagyd ki azokat.

A megtakarítás halmozódik. Egy nagy kódbázison egy tipikus PR az üzleti logika töredékét érinti. A teljes E2E csomag futtatása minden PR-hez olyan, mint az egész ház újraépítése, mert kicseréltél egy kilincset. MCP-strukturált üzleti logikával és AI reviewerrel a CI-d csak azt futtatja, ami számít.

Kevesebb számítás. Gyorsabb visszajelzés. Kevesebb instabil kudarc olyan tesztektől, amiknek semmi közük a változtatásodhoz. A piramis nem csak átalakul -- okos lesz.

---

## A Piramis, Újragondolva

A tesztpiramis mindig kompromisszum volt. Az E2E teszteket nem azért tettük a tetejére, mert azt akartuk, hogy lassúak és kevesek legyenek, hanem mert ez volt a korlátozás. A teljes felhasználói folyamat ellenőrzése böngészőt igényelt. A böngészők lassúak. Ezért a teljes felhasználói folyamat tesztek lassúak. Ezért írj kevesebbet belőlük.

Az MCP-k megtörik ezt a korlátozást.

Ha az üzleti logikád elérhető egy szöveges felületen keresztül, a teljes felhasználói folyamat ellenőrzése nem igényel böngészőt. Függvényhívást igényel. A függvényhívások gyorsak. Ezért a teljes felhasználói folyamat tesztek gyorsak. Ezért írj annyit, amennyit akarsz.

A piramis nem fordul fejre. Átalakul. A fájdalmas felső réteg -- az E2E réteg -- vékonnyá válik. Az üzleti logika, ami duzzasztotta, lemozdul a unit teszt rétegre. Nem azért, mert találtál egy okos módot a böngésző mockolására, hanem mert megszüntetted a böngésző szükségességét.

A megmaradt E2E tesztek azt csinálják, amit mindig is csinálniuk kellett volna: ellenőrzik, hogy az oldal renderel, hogy az integrációs kötések tartanak, hogy a vizuális dizájn helyes. "Azt teszteljék a hülyék" -- kivéve most a "hülyék" a Playwright, ami néhány célzott ellenőrzést futtat, nem száz lassú üzleti logika szimulációt.

---

## Teljes Kör

Még mindig gondolok arra a konferenciára néha. A fiatal előadó, aki rezeg az izgatottságtól a unit tesztek miatt. A közönségben a személy, aki az UI tesztelésről kérdez. Az elutasító válasz.

"Az UI-t? Azt teszteljék a hülyék!" -- mondta.

Nem tévedett. Korai volt.

A valós válasz az UI tesztelési kérdésre soha nem "automatizáld a böngészőt" volt. A valós válasz ez volt: tedd az üzleti logikát elérhetővé böngésző nélkül. Csak nem volt meg hozzá a felület.

Most van.

László imádta volna ezt. Nem maga a technológiát -- soha nem volt az a típus, akit felizgat egy protokoll vagy egy specifikáció. Azt szerette volna, amit jelent a mesterségnek. Kevesebb idő instabil tesztek elleni harcra. Több idő valóban számító dolgok építésére. Több idő a junior fejlesztő segítésére az előadások után.

Így néz ki a mesterség előretolása. Nem villogó új eszközök. Csendesebb visszacsatolási hurkok. Kevesebb súrlódás a szándék és az ellenőrzés között. A fajta unalmas haladás, ami mindent mást lehetővé tesz.

Minden alkalommal rá gondolok, amikor törlök egy instabil tesztet. Azt hiszem, helyeselne.

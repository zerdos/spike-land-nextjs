---
title: "The Testing Pyramid Is Upside Down"
slug: "testing-shadows-on-the-cave-wall"
description: "Plato's prisoners watched shadows and called them real. For thirty years, we watched browser tests and called them verification. What happens when you turn around?"
date: "2026-02-13"
author: "Zoltan Erdos"
category: "Developer Experience"
tags: ["testing", "mcp", "philosophy", "plato", "epistemology"]
featured: false
listed: false
---

## The Cave

In Book VII of *The Republic*, Plato describes prisoners chained inside a cave, facing a blank wall. Behind them burns a fire. Between the fire and the prisoners, people carry objects whose shadows are cast onto the wall. The prisoners have never seen anything else. They name the shadows. They study their patterns. They build entire systems of knowledge around flickering projections -- and they call this knowledge *truth*.

The allegory is about epistemology: the study of how we know what we know. Plato's point was not that the shadows are useless. They do correlate with the real objects. A shadow of a horse looks like a horse. The problem is that the correlation is unreliable. Shadows stretch. They overlap. They vanish when the fire flickers. You can spend your whole life studying shadows and still not know the shape of the thing that casts them.

I have been thinking about this allegory for months. Because I think it describes, with uncomfortable precision, what we have been doing with browser-based end-to-end tests for the past thirty years.

---

## Shadows on the Wall

We did start testing UI. Of course we did. Selenium. Protractor. Cypress. Playwright. Each generation better than the last. Each one promising to finally make browser testing reliable.

And here is where Plato becomes uncomfortably relevant.

A browser test watches the DOM -- the Document Object Model -- which is itself a *projection* of your application state onto a rendering surface. When you write `cy.get('[data-testid="success-toast"]').should('contain', 'Email updated')`, you are not examining the thing itself. You are examining the shadow it casts on the cave wall. You are reading the projection and hoping it tells you something true about the form behind it.

Sometimes it does. Shadows do correlate with real objects. But the correlation is unreliable, for exactly the reasons Plato warned about. The fire flickers: an animation takes 50ms longer on CI. The shadow stretches: a CSS change moves an element without changing behavior. Other shadows overlap: a third-party script loads and shifts the layout. You are not testing your business logic. You are testing the stability of firelight.

This is the testing pyramid we all know. Unit tests at the base -- fast, cheap, many. E2E tests at the top -- slow, expensive, few. Everyone agrees the top is painful. We accepted it as necessary.

But *why* did we accept it? Because we confused the shadow with the form. We answered the wrong question for three decades. Daniel Kahneman calls this the substitution heuristic: when faced with a hard question, we unconsciously substitute an easier one and answer that instead. The hard question was "how do we verify business logic flows?" The easy substitution was "how do we automate a browser?" We answered the second question brilliantly. We never noticed it was the wrong one.

---

## Turning Around

In Plato's allegory, one prisoner is freed. He turns around. He sees the fire for the first time. His eyes burn. The real objects look less familiar than the shadows did. He has to learn to see all over again.

MCP -- Model Context Protocol -- is the moment of turning around. It is a standard for exposing your application's capabilities as structured tools. Text in, text out. No browser. No DOM. No shadows.

Here is what this looks like in practice. A typical E2E test for an email update flow:

```typescript
// Cypress E2E test -- watching shadows
describe('Email update flow', () => {
  it('should allow user to change their email', () => {
    cy.login('test@example.com', 'password123');
    cy.visit('/settings');
    cy.get('[data-testid="email-input"]').clear().type('new@example.com');
    cy.get('[data-testid="save-button"]').click();
    cy.get('[data-testid="confirm-dialog"]').should('be.visible');
    cy.get('[data-testid="confirm-button"]').click();
    cy.get('[data-testid="success-toast"]').should('contain', 'Email updated');
    cy.visit('/profile');
    cy.get('[data-testid="user-email"]').should('contain', 'new@example.com');
  });
});
```

Every line of this test examines a shadow. The `data-testid` selectors, the `.should('be.visible')`, the toast message -- these are all projections on the cave wall. The actual business logic -- "authenticated user can change their email with confirmation" -- is buried beneath layers of rendering.

Now, the same business logic as an MCP tool and unit test -- facing the fire directly:

```typescript
// MCP tool -- the form itself
const updateEmailTool = {
  name: 'update_user_email',
  description: 'Update the authenticated user\'s email address',
  inputSchema: {
    type: 'object',
    properties: {
      newEmail: { type: 'string', format: 'email' },
      confirmChange: { type: 'boolean' },
    },
    required: ['newEmail', 'confirmChange'],
  },
  handler: async ({ newEmail, confirmChange }, context) => {
    const user = await context.getAuthenticatedUser();
    if (!user) return { error: 'Not authenticated' };
    if (!confirmChange) {
      return {
        status: 'confirmation_required',
        message: `Confirm change from ${user.email} to ${newEmail}?`,
      };
    }
    await context.userService.updateEmail(user.id, newEmail);
    return { status: 'success', updatedEmail: newEmail };
  },
};

// Unit test -- examining forms, not shadows
describe('update_user_email', () => {
  it('should update email when confirmed', async () => {
    const context = createMockContext({
      user: { id: '1', email: 'old@example.com' },
    });
    const result = await updateEmailTool.handler(
      { newEmail: 'new@example.com', confirmChange: true },
      context,
    );
    expect(result.status).toBe('success');
    expect(result.updatedEmail).toBe('new@example.com');
  });

  it('should reject unauthenticated requests', async () => {
    const context = createMockContext({ user: null });
    const result = await updateEmailTool.handler(
      { newEmail: 'new@example.com', confirmChange: true },
      context,
    );
    expect(result.error).toBe('Not authenticated');
  });
});
```

This test runs in milliseconds. It does not depend on DOM structure, animation timing, or the stability of firelight. It examines the form directly. You have not lost any coverage. You have lost the cave.

---

## The Empty Space

Peter Brook, the theater director, wrote that all you need for theater is an empty space and someone to walk across it while someone else watches. Strip away the costumes, the lighting, the sets -- drama is two presences in dialogue.

There is something similar in testing. A unit test and the code it tests, when both are written properly, specify each other. Two players, one truth. That is the empty space of software verification: nothing but the dialogue between specification and implementation.

But I think there is a third player: the name.

Consider `update_user_email`. That name is not decoration. It is a constraint. It tells you what the tool must do and what it must not do. An AI agent browsing your MCP server does not read your source code -- it reads tool names, descriptions, and schemas. The name becomes a discoverable contract. A machine-readable commitment.

Test. Code. Name. Three players, one truth. The name, the input schema, and the handler form a triangle where each vertex constrains the other two. This is what Noam Chomsky would recognize as deep structure versus surface structure. The business logic is the deep structure -- the meaning. The DOM is the surface structure -- one particular rendering of that meaning. For thirty years, we tested the surface and hoped it told us about the depths. MCP lets us test the depths directly.

---

## The Pragmatist's Verdict

William James, the father of American pragmatism, defined truth simply: truth is what works. Not what feels true. Not what looks true. What reliably, repeatedly, demonstrably works.

Browser tests *feel* true. They click real buttons. They see real pages. They simulate real users. But they do not *reliably* work. They flake. They break when CSS changes. They time out when networks are slow. They answer the question "did this particular rendering of our logic happen to produce the right pixels at the right time?" -- which is not the question we needed answered.

MCP tests are reliably true in the pragmatic sense. They verify that `update_user_email` with confirmed input produces a success response and calls `updateEmail`. Every time. In milliseconds. Without flaking. They answer the question we actually cared about: does the business logic work?

The pyramid does not flip upside down. It reshapes. The E2E layer gets thin -- a handful of visual smoke tests verifying that the cave wall still exists and the shadows still appear. The business logic that bloated it moves down to the unit test layer. Not because you found a clever way to mock the browser, but because you removed the need for the browser entirely.

What remains at the top is what should have been there all along: tests that verify the rendering layer *as* a rendering layer. Does the page load? Does the button appear? Does the layout hold? Those are legitimate questions about the cave wall, asked knowingly, without mistaking shadows for forms.

---

## Full Circle

The real answer to the UI testing question was never "automate the browser more." The real answer was Socratic: *examine what you think you know*. We thought we were testing business logic. We were testing shadows. The examined test suite -- like the examined life -- is the only one worth maintaining.

Less time fighting the flickering of firelight. More time in the empty space where test and code face each other directly. That is what it looks like to leave the cave. Not flashy new tools. Quieter feedback loops. Less friction between intent and verification. The boring kind of progress that makes everything else possible.

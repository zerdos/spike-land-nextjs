---
title: "The Testing Pyramid Is Upside Down"
slug: "the-empty-space-between-test-and-code"
description: "Peter Brook said all you need for theater is an empty space, an actor, and someone watching. For thirty years, we tested software in full costume on a proscenium stage. MCP strips it to the empty space â€” and reveals the performance was always there."
date: "2026-02-13"
author: "Zoltan Erdos"
category: "Developer Experience"
tags: ["testing", "mcp", "theater", "empty-space", "rehearsal"]
featured: false
listed: false
---

## The Empty Space

Peter Brook opens *The Empty Space* with one of the most radical propositions in the history of theater: "I can take any empty space and call it a bare stage. A man walks across this empty space whilst someone else is watching him, and this is all that is needed for an act of theatre to be engaged."

No costumes. No lighting rig. No proscenium arch. No orchestra pit. Just a performer, an observer, and the space between them. Brook was not describing poverty. He was describing liberation. Everything the commercial theater had accumulated over centuries -- the gilded boxes, the velvet curtains, the elaborate set changes -- these were not theater. They were decoration that had gradually been mistaken for the thing itself.

Our industry made the same mistake, at industrial scale, for the next decade.

---

## Opening Night Every Night

We did start testing UI. Selenium. Protractor. Cypress. Playwright. Each generation better than the last. Each one promising to finally make browser testing reliable.

Here is the problem, and it is a problem any theater director would recognize immediately: we built a testing practice that works like opening night. Every single test run fires up a full browser -- the complete proscenium stage with costumes, lighting, set design, orchestra, and a live audience. The business logic performs under full production conditions. Every CSS selector is a cue mark on the stage floor. Every `waitForSelector` is a stage manager whispering "hold... hold... now." Every retry is a panicked understudy rushing into position because someone missed their entrance.

Opening night is where everything can go wrong, and does. The lead actor stumbles on a costume change. A lighting cue fires late. A prop is missing from the table. The audience coughs at the wrong moment. None of these failures mean the *play* is broken. The text is sound. The characters are motivated. The dramatic structure holds. What failed is the machinery of presentation.

E2E tests fail the same way. A test that passes locally fails on CI because an animation took 50ms longer. A test that ran fine yesterday fails today because a third-party script loaded slower. You add `waitForTimeout`. You add retry logic. You are not testing your application anymore -- you are testing your ability to execute a flawless opening night, every night, on every machine, in every environment.

This is the testing pyramid. Unit tests at the base: fast, cheap, many -- like table reads where actors sit and speak the lines. E2E tests at the painful top: slow, expensive, few -- like full dress rehearsals with orchestra and audience. Everyone accepted the top as the cost of doing business.

But great directors know something that our industry forgot: the real work does not happen on opening night. It happens in rehearsal.

---

## The Rehearsal Room

Stanislavski revolutionized acting by insisting on one thing: the actor must find the *subtext* beneath the dialogue. What the character says is the text. What the character means -- their motivation, their objective, the thing they want but cannot name -- is the subtext. A line like "I am fine" can mean a hundred different things depending on the subtext. The truth of the performance lives not in the words spoken but in the intention beneath them.

The UI is text. Business logic is subtext.

When a user clicks "Save" on a settings page, the text is: a button was clicked, a toast appeared, the page refreshed. The subtext is: an authenticated user confirmed an email change, the system validated the new address, updated the record, and returned a success state. Browser tests verify the text -- did the toast appear? Did the button respond? MCP tests verify the subtext -- did the business logic execute correctly?

Rehearsal is where actors work on subtext. The room is bare. No costumes, no lights, no set. Just bodies in space, working the scene over and over, finding the truth of it. A director like Brook would strip away everything that interfered with that search. If an actor was hiding behind a prop, take the prop away. If a costume was doing the character work, remove the costume. Force the actor to find the truth in the empty space.

MCP -- Model Context Protocol -- is the rehearsal room. It exposes your application's capabilities as structured tools. Text in, text out. No browser. No DOM. No CSS selectors. No timing issues. The business logic performs in the empty space, with nothing to hide behind.

Here is what opening night looks like:

```typescript
// Cypress E2E test -- opening night, full costume
describe('Email update flow', () => {
  it('should allow user to change their email', () => {
    cy.login('test@example.com', 'password123');
    cy.visit('/settings');
    cy.get('[data-testid="email-input"]').clear().type('new@example.com');
    cy.get('[data-testid="save-button"]').click();
    cy.get('[data-testid="confirm-dialog"]').should('be.visible');
    cy.get('[data-testid="confirm-button"]').click();
    cy.get('[data-testid="success-toast"]').should('contain', 'Email updated');
    cy.visit('/profile');
    cy.get('[data-testid="user-email"]').should('contain', 'new@example.com');
  });
});
```

Every `cy.get` is a cue mark. Every `.should('be.visible')` is a lighting check. Change the blocking -- move the confirm dialog from a modal to an inline panel -- and the entire production collapses. The test is coupled to the staging, not to the play.

Now here is rehearsal -- the same scene, stripped to the empty space:

```typescript
// MCP tool -- the subtext
const updateEmailTool = {
  name: 'update_user_email',
  description: 'Update the authenticated user\'s email address',
  inputSchema: {
    type: 'object',
    properties: {
      newEmail: { type: 'string', format: 'email' },
      confirmChange: { type: 'boolean' },
    },
    required: ['newEmail', 'confirmChange'],
  },
  handler: async ({ newEmail, confirmChange }, context) => {
    const user = await context.getAuthenticatedUser();
    if (!user) return { error: 'Not authenticated' };

    if (!confirmChange) {
      return {
        status: 'confirmation_required',
        message: `Confirm change from ${user.email} to ${newEmail}?`,
      };
    }

    await context.userService.updateEmail(user.id, newEmail);
    return {
      status: 'success',
      message: `Email updated to ${newEmail}`,
      updatedEmail: newEmail,
    };
  },
};

// Unit test -- working the scene in rehearsal
describe('update_user_email', () => {
  it('should update email when confirmed', async () => {
    const context = createMockContext({
      user: { id: '1', email: 'old@example.com' },
    });

    const result = await updateEmailTool.handler(
      { newEmail: 'new@example.com', confirmChange: true },
      context,
    );

    expect(result.status).toBe('success');
    expect(result.updatedEmail).toBe('new@example.com');
    expect(context.userService.updateEmail).toHaveBeenCalledWith(
      '1', 'new@example.com',
    );
  });

  it('should require confirmation before updating', async () => {
    const context = createMockContext({
      user: { id: '1', email: 'old@example.com' },
    });

    const result = await updateEmailTool.handler(
      { newEmail: 'new@example.com', confirmChange: false },
      context,
    );

    expect(result.status).toBe('confirmation_required');
    expect(context.userService.updateEmail).not.toHaveBeenCalled();
  });
});
```

This test runs in milliseconds. It does not depend on costume changes, lighting cues, or prop placement. It tests the subtext directly -- authentication, confirmation, state transition. The performance is truthful because there is nothing to hide behind.

You have not lost any coverage. You have lost the proscenium.

---

## Three Players, One Truth

A unit test and its code, when both are written properly, specify each other. Two actors working a scene. One delivers the line, the other responds. When the scene is right, each performance constrains the other. Two players, one truth.

But I think there is a third player: the name.

Consider `update_user_email`. In theater, this is the *given circumstance* -- the fact of the scene that cannot be negotiated. Stanislavski insisted that actors begin every scene by establishing the given circumstances: Who am I? Where am I? What do I want? The tool name establishes the given circumstance of the code. It does not send notifications. It does not reset the password. It updates the user's email. The name constrains the performance before a single line is written.

And in the age of MCP, the name does something Stanislavski could not have anticipated: it becomes machine-discoverable. An AI agent browsing your MCP server reads tool names, descriptions, and schemas. It does not read your source code. If `update_user_email` is named truthfully, the agent knows what scene it is entering without reading the script. The name becomes a contract that constrains both human understanding and machine invocation.

Test. Code. Name. Three players, one truth. The name establishes the given circumstance. The handler performs the action. The test verifies the performance. Each constrains the other two. Remove any one and the scene falls apart. This was always the deep structure of well-written software -- MCP formalized it into something machines can reason about.

---

## The Pyramid, Reconsidered

The testing pyramid was a compromise forced by the architecture of the stage. We put E2E tests at the top not because we wanted them slow and few, but because the browser was the only venue that could host the full performance. It is as if a director could only evaluate a play by mounting a full production every time -- orchestra, costumes, audience, the works -- because there was no rehearsal room.

MCP builds the rehearsal room. Business logic moves down to the unit test layer. Not through clever stagecraft, but because the need for the proscenium is removed entirely. The business logic performs in the empty space, and the empty space is enough.

What remains at the E2E level is what belongs there: visual smoke tests, integration wiring, browser-specific behavior. The tech rehearsal. Does the lighting work? Does the set change happen smoothly? Does the sound system carry? These are real questions about the production, asked knowingly, without confusing them with the truth of the play itself.

Brook wrote about "The Deadly Theatre" -- theater that is dead because it confuses elaborate production with living performance. Our E2E suites were the deadly theater of software testing. Elaborate, expensive, impressive-looking, and dead -- because the truth of the performance was buried under machinery.

The empty space is not impoverished. It is liberated.

---

## Full Circle

The real answer to the UI testing question was never "build a bigger stage." It was never "hire a better stage crew." The real answer was the one Brook gave in 1968: strip everything away until only the essential act remains. A function executes. A test watches. The space between them is empty -- and that emptiness is where the truth lives.

Less time fighting flaky opening nights. More time in the rehearsal room where the real work happens. That is what pushing the craft forward looks like. Not a grander proscenium. A barer stage. Less friction between intent and verification. The boring kind of progress that makes everything else possible.

---
title: "The Testing Pyramid Is Upside Down"
slug: "the-best-evidence-rule-for-software"
description: "The law demands the original document, not a witness describing what it said. For thirty years, we let browser tests give hearsay testimony about our business logic. Evidence law explains why MCP changes the rules of admissibility."
date: "2026-02-13"
author: "Zoltan Erdos"
category: "Developer Experience"
tags: ["testing", "mcp", "jurisprudence", "evidence-law", "burden-of-proof", "best-evidence-rule"]
featured: false
listed: false
---

## The Best Evidence Rule

Oliver Wendell Holmes Jr. wrote that "the life of the law has not been logic; it has been experience." Testing practice, like law, evolved through experience -- decades of trial and error, not deduction from first principles. And just as Holmes argued that legal doctrines must be re-examined when the conditions that produced them change, so must testing doctrines. The conditions have changed.

In Anglo-American evidence law, there is a doctrine older than the republic itself: the Best Evidence Rule. Federal Rule of Evidence 1002 states it plainly -- to prove the content of a writing, you must produce the original. Not a summary. Not a witness who claims to have read it. The original document itself. The rule exists because every intermediary between the factfinder and the evidence introduces distortion. A witness may misremember. A copy may contain transcription errors. The further you get from the source, the less you can trust what you are looking at.

I spent thirty years watching our industry violate this rule every day. Not in court. In CI pipelines.

A browser-based end-to-end test is a witness testifying about the contents of a document it once read. "I saw a login form. I typed credentials into it. Eventually, I observed a dashboard." The factfinder -- the developer waiting on CI -- has no direct access to the business logic. They are relying entirely on the testimony of an unreliable witness: a headless browser navigating a rendering layer that introduces its own distortions at every step. This is hearsay evidence dressed in automation.

---

## Hearsay Testimony

We did start testing UI. Of course we did. Selenium. Protractor. Cypress. Playwright. Each generation a more sophisticated witness. Each one still testifying about what it observed rather than producing the original.

Consider what a browser test actually does. It launches a rendering engine -- a complex state machine with its own internal logic, timing dependencies, and environmental sensitivities. It navigates to a URL. It waits for the DOM to settle. It locates elements by CSS selectors. It clicks, types, waits, and observes. Then it reports what it saw. At every step, the witness interposes itself between the factfinder and the fact.

This is classic hearsay. Federal Rule of Evidence 801(c) defines hearsay as an out-of-court statement offered to prove the truth of the matter asserted. A browser test is an out-of-process observation offered to prove that business logic is correct. The browser did not *execute* the business logic in any legally meaningful sense. It observed the *effects* of that logic as rendered through HTML, CSS, JavaScript event loops, network requests, and a compositor painting pixels to a virtual screen. Each layer is another degree of separation from the original.

And the testimony is unreliable for all the reasons courts have always been suspicious of hearsay. The witness has perception problems: an animation takes 50ms longer on CI than locally. The witness has memory problems: the DOM state at the moment of assertion may not reflect the state at the moment the operation completed. The witness has narration problems: a toast saying "Email updated" could appear because the email was actually updated, or because a frontend handler fired optimistically before the backend rejected the request.

This is the testing pyramid. Unit tests at the base -- direct evidence, fast and reliable. E2E tests at the top -- hearsay evidence, slow and flaky. Everyone agreed the top was painful. We accepted it because, like a court lacking the original document, we admitted the secondary evidence as the best available.

---

## Producing the Original

MCP -- Model Context Protocol -- is the original document walking into the courtroom. It is a standard for exposing your application's capabilities as structured tools. Text in, text out. No browser intermediary. No rendering witness. When you write your user stories as MCP tools, you produce the original business logic for direct examination.

Here is what the distinction looks like. A Cypress test -- hearsay testimony:

```typescript
// Cypress E2E test -- witness testimony about the document
describe('Email update flow', () => {
  it('should allow user to change their email', () => {
    cy.login('test@example.com', 'password123');
    cy.visit('/settings');
    cy.get('[data-testid="email-input"]').clear().type('new@example.com');
    cy.get('[data-testid="save-button"]').click();
    cy.get('[data-testid="confirm-dialog"]').should('be.visible');
    cy.get('[data-testid="confirm-button"]').click();
    cy.get('[data-testid="success-toast"]').should('contain', 'Email updated');
    cy.visit('/profile');
    cy.get('[data-testid="user-email"]').should('contain', 'new@example.com');
  });
});
```

Every line is testimony from a witness. "I saw a button labeled save. I clicked it. I then observed a dialog." The factfinder has no way to cross-examine this witness about what actually happened in the service layer. Was the email persisted to the database? Did the confirmation step enforce its constraint? The witness cannot say. It only saw what the rendering layer chose to show.

Now, the same business logic as an MCP tool -- the original document, produced for direct examination:

```typescript
// MCP tool -- the original document
const updateEmailTool = {
  name: 'update_user_email',
  description: 'Update the authenticated user\'s email address',
  inputSchema: {
    type: 'object',
    properties: {
      newEmail: { type: 'string', format: 'email' },
      confirmChange: { type: 'boolean' },
    },
    required: ['newEmail', 'confirmChange'],
  },
  handler: async ({ newEmail, confirmChange }, context) => {
    const user = await context.getAuthenticatedUser();
    if (!user) return { error: 'Not authenticated' };
    if (!confirmChange) {
      return {
        status: 'confirmation_required',
        message: `Confirm change from ${user.email} to ${newEmail}?`,
      };
    }
    await context.userService.updateEmail(user.id, newEmail);
    return { status: 'success', updatedEmail: newEmail };
  },
};

// Unit test -- direct examination of the original
describe('update_user_email', () => {
  it('should update email when confirmed', async () => {
    const context = createMockContext({
      user: { id: '1', email: 'old@example.com' },
    });
    const result = await updateEmailTool.handler(
      { newEmail: 'new@example.com', confirmChange: true },
      context,
    );
    expect(result.status).toBe('success');
    expect(result.updatedEmail).toBe('new@example.com');
    expect(context.userService.updateEmail).toHaveBeenCalledWith(
      '1', 'new@example.com',
    );
  });

  it('should reject unauthenticated requests', async () => {
    const context = createMockContext({ user: null });
    const result = await updateEmailTool.handler(
      { newEmail: 'new@example.com', confirmChange: true },
      context,
    );
    expect(result.error).toBe('Not authenticated');
  });
});
```

This test runs in milliseconds. It produces the original for direct inspection. The factfinder -- the developer, the CI system -- examines the business logic without intermediary testimony. You have not lost any coverage. You have dismissed an unreliable witness.

---

## The Burden of Proof

There is a second legal principle at work here, and it explains why E2E tests feel so heavy.

In civil litigation, each party carries a defined burden. The plaintiff proves their claim. The defendant proves their defense. No party is required to prove everything at once. The system works because the burden is *allocated* -- distributed across parties according to what each is best positioned to establish.

A browser test carries an absurd, undivided burden. It must simultaneously prove that the business logic is correct AND that the browser rendered the result correctly AND that the CSS selectors resolved to the right elements AND that the timing held AND that no third-party script interfered. This is like asking a single witness to simultaneously establish the terms of the contract, authenticate the signatures, prove the ink is genuine, and testify about the defendant's state of mind. No witness can carry that load reliably.

MCP allocates the burden properly. The unit test proves one thing: business logic correctness. The E2E test, unburdened of business logic, proves one thing: the rendering layer renders. Each test carries only the burden it is competent to discharge. This is not merely more efficient. It is more *just* -- in the precise legal sense that justice requires each question to be answered by the evidence best suited to answer it.

---

## Void for Vagueness

A third doctrine completes the picture. The void-for-vagueness principle, rooted in the Due Process Clause of the Fourteenth Amendment, holds that a law is unconstitutional if it fails to give ordinary people fair notice of what conduct it prohibits. A statute that says "do not behave improperly in public spaces" is void because nobody can know, in advance, what it forbids.

CSS selectors in E2E tests are vague statutes. `[data-testid="save-button"]` -- what does this prohibit? What does it require? The selector could match any element on any page. It carries no intrinsic meaning about the business operation it supposedly verifies. Move the button to a different component, change the `data-testid` value, wrap it in a new layout -- the "law" breaks, and the developer who made the change had no fair notice that their refactoring would violate it.

MCP tool schemas are precise statutes. The `inputSchema` defines exactly what inputs are valid. The handler defines exactly what behavior follows. The response type defines exactly what outcomes are possible. A developer reading the schema knows, with constitutional certainty, what the tool accepts, what it does, and what it returns. There is no vagueness. There is no selector that might match anything or nothing depending on the rendering context. The contract is self-contained and self-documenting.

---

## Three Players, One Truth

A unit test and its code, when written properly, specify each other. Two players, one truth. That is the adversarial system at its finest -- two parties, rigorously opposed, converging on a verdict neither could reach alone.

But I think there is a third player: the name.

Consider `update_user_email`. That name is not just a label. It is a statute. It defines the scope of the tool's authority and the limits of its jurisdiction. It does not send notifications. It does not update the password. It updates the user's email. An AI agent browsing your MCP server reads tool names, descriptions, and schemas -- the way a lawyer reads the statute book. If the name is drafted precisely, the agent knows what to invoke without reading the implementation.

Test. Code. Name. Three players, one truth. The name defines the jurisdiction. The handler exercises authority within that jurisdiction. The test audits whether the exercise of authority was lawful. A triangle of mutual constraint where each vertex holds the other two accountable. We had two vertices for decades. MCP formalized the third into something machines can discover and reason about -- a machine-readable statute that binds the conduct of the code the way a well-drafted law binds the conduct of citizens.

---

## Reshaping the Pyramid

The testing pyramid was always a procedural compromise. We put E2E tests at the top not because we wanted them to be slow and few, but because hearsay was the only evidence available. The browser was the only witness who had seen the full user flow. Without the original document, you have to take the testimony you can get.

MCP breaks that evidentiary constraint. If your business logic is accessible through a structured text interface, you can produce the original document. The original is fast. It is reliable. It does not misremember, confuse, or embellish. Write as many examinations as you need.

The pyramid does not flip. It reshapes. The E2E layer thins to what it should have always been: a narrow set of visual and integration checks -- the rendering layer testifying about its own domain, which is the one thing it is competent to speak to. Does the page load? Does the layout hold? Does the button appear where the design says it should? Those are questions the browser *can* answer reliably, because they are within the scope of its personal knowledge.

The business logic that used to bloat the E2E layer moves down to the unit test layer. Not because you found a clever way to impeach the browser witness, but because you produced the original document and the hearsay became unnecessary.

---

## Full Circle

MCP is not a new kind of witness. It is a way to stop relying on witnesses altogether and hand the original document to the factfinder.

Less time impeaching unreliable witnesses. More time examining the evidence directly. Not flashy new tools. Quieter proceedings. Less friction between the evidence and the verdict. The boring kind of progress that makes everything else possible.

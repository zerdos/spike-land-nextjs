name: CI/CD Pipeline

permissions:
  contents: read
  pull-requests: write # For PR comments

# Cancel in-progress runs for the same PR/branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

on:
  push:
    branches:
      - "main"
    paths-ignore:
      - "**.md"
      - "docs/**"
      - "CLAUDE.md"
  pull_request:
    branches:
      - "main"
    paths-ignore:
      - "**.md"
      - "docs/**"

# Deployment Strategy:
# - Preview deployments: Created for PRs via Vercel Git integration
# - Staging (next.spike.land): Auto-deployed from main after tests pass
# - Production (spike.land): Manual deployment via workflow_dispatch (deploy.yml)

# NOTE: This project uses Yarn 4 with node-modules linker.
# Setup is managed by .github/actions/setup composite action which caches:
# - node_modules (keyed on yarn.lock + .yarnrc.yml)
# - .yarn/cache (fallback for cold installs)
# - Prisma client (keyed on schema.prisma)
# - Shared package dist (keyed on source)
jobs:
  # ============================================================================
  # TIER 1: All these jobs run in PARALLEL immediately (no dependencies)
  # ============================================================================
  quality-checks:
    name: Quality Checks (Lint + Security)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - uses: ./.github/actions/setup
        with:
          generate-prisma: "true"
          build-shared: "true"

      - name: Cache TypeScript build info
        uses: actions/cache@v5
        with:
          path: tsconfig.tsbuildinfo
          key: ${{ runner.os }}-tsbuildinfo-${{ hashFiles('**/tsconfig.json', 'src/**/*.ts', 'src/**/*.tsx') }}
          restore-keys: |
            ${{ runner.os }}-tsbuildinfo-

      - name: Generate docs manifests (needed by tsc)
        run: yarn docs:generate

      - name: Run linter
        run: yarn lint

      - name: Tsc check
        run: yarn tsc --noEmit

      - name: Run security audit
        run: yarn npm audit --all --severity moderate

  unit-tests:
    name: unit-tests-${{ matrix.shard }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        shard: [1, 2, 3, 4]
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - uses: ./.github/actions/setup
        with:
          generate-prisma: "true"

      - name: Fetch main branch for comparison
        if: github.ref != 'refs/heads/main'
        run: git fetch origin main:main

      - name: Run tests (shard ${{ matrix.shard }}/4)
        run: |
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            # On main branch: run all tests with coverage generation (thresholds disabled for shards)
            # Coverage thresholds cannot be enforced per-shard since each shard only covers part of the codebase
            # Thresholds are checked via Codecov which merges all shards
            yarn vitest run --coverage --coverage.thresholds.lines=0 --coverage.thresholds.functions=0 --coverage.thresholds.branches=0 --coverage.thresholds.statements=0 --shard=${{ matrix.shard }}/4 --reporter=github-actions
          else
            # On PR/feature branch: run only changed tests (no coverage threshold enforcement)
            yarn test:run --changed main --shard=${{ matrix.shard }}/4 --reporter=github-actions
          fi
        env:
          # Provide dummy DATABASE_URL for Prisma 7 client engine initialization
          DATABASE_URL: postgresql://dummy:dummy@localhost:5432/dummy?schema=public

      - name: Upload coverage reports
        uses: codecov/codecov-action@v5
        # Only upload if coverage was generated (skipped when --changed finds no tests)
        if: always() && hashFiles('./coverage/lcov.info') != ''
        with:
          files: ./coverage/lcov.info
          flags: unittests
          name: codecov-shard-${{ matrix.shard }}
          fail_ci_if_error: false
          token: ${{ secrets.CODECOV_TOKEN }}

  # Package tests run the tests for workspace packages (code, backend, transpiler, renderer)
  package-tests:
    name: Package Tests
    runs-on: ubuntu-latest
    # NO DEPENDENCIES - runs in parallel with other Tier 1 jobs

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - uses: ./.github/actions/setup

      - name: Run package tests
        run: yarn test:packages
        env:
          DATABASE_URL: postgresql://dummy:dummy@localhost:5432/dummy?schema=public

  # Build runs in PARALLEL with quality-checks and unit-tests (no needs)
  build:
    name: Build Application
    runs-on: ubuntu-latest
    # NO DEPENDENCIES - runs immediately in parallel with tests and lint!

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - uses: ./.github/actions/setup
        with:
          generate-prisma: "true"
          build-shared: "true"

      - name: Restore Next.js build cache
        uses: actions/cache/restore@v5
        with:
          path: .next/cache
          key: ${{ runner.os }}-nextjs-v2-${{ hashFiles('**/yarn.lock') }}-${{ hashFiles('**/*.ts', '**/*.tsx') }}
          restore-keys: |
            ${{ runner.os }}-nextjs-v2-${{ hashFiles('**/yarn.lock') }}-
            ${{ runner.os }}-nextjs-v2-

      - name: Build application
        run: yarn build
        env:
          NODE_OPTIONS: "--max-old-space-size=8192 --require ./scripts/debug-uncaught.cjs"
          # Provide dummy DATABASE_URL for Prisma 7 client engine initialization
          # Actual database connection only happens at runtime with real credentials
          DATABASE_URL: postgresql://dummy:dummy@localhost:5432/dummy?schema=public
          # Skip TypeScript during build - it runs in parallel via quality-checks job
          # Note: Next.js 16 no longer runs ESLint during build by default
          SKIP_TS_BUILD_CHECK: "true"
          # Sentry auth token for source map uploads (main branch only)
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}

      - name: Save Next.js build cache
        if: success()
        uses: actions/cache/save@v5
        with:
          path: .next/cache
          key: ${{ runner.os }}-nextjs-v2-${{ hashFiles('**/yarn.lock') }}-${{ hashFiles('**/*.ts', '**/*.tsx') }}

      - name: Verify build output
        run: |
          echo "=== Checking .next directory ==="
          ls -la .next/ || echo ".next directory not found!"
          echo "=== Checking for BUILD_ID ==="
          cat .next/BUILD_ID || echo "BUILD_ID not found!"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: nextjs-build
          path: .next
          retention-days: 1
          include-hidden-files: true

  # ============================================================================
  # TIER 2: Deploy to Staging - auto-deploys main branch after all tests pass
  # ============================================================================

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [quality-checks, unit-tests, package-tests, build]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - uses: ./.github/actions/setup

      - name: Install Vercel CLI
        run: npm install -g vercel@latest

      - name: Pull Vercel Environment Info
        run: vercel pull --yes --environment=preview --token=${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Build with Vercel
        run: vercel build --token=${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Deploy to Staging
        id: deploy
        run: |
          DEPLOYMENT_URL=$(vercel deploy --prebuilt --token=${{ secrets.VERCEL_TOKEN }})
          echo "url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          # Alias to next.spike.land
          vercel alias "$DEPLOYMENT_URL" next.spike.land --token=${{ secrets.VERCEL_TOKEN }} || echo "Alias failed, continuing..."
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Health Check
        run: |
          echo "Waiting for deployment to be ready..."
          sleep 30

          echo "Checking health at: $DEPLOY_URL"

          for i in {1..5}; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$DEPLOY_URL" || echo "000")
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "Health check passed!"
              exit 0
            fi
            echo "Attempt $i: Got HTTP $HTTP_STATUS, retrying..."
            sleep 10
          done

          echo "Health check failed after 5 attempts"
          exit 1
        env:
          DEPLOY_URL: ${{ steps.deploy.outputs.url }}

      - name: Deployment Summary
        run: |
          echo "## Staging Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **URL:** $DEPLOY_URL" >> $GITHUB_STEP_SUMMARY
          echo "- **Alias:** https://next.spike.land" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** $COMMIT_SHA" >> $GITHUB_STEP_SUMMARY
        env:
          DEPLOY_URL: ${{ steps.deploy.outputs.url }}
          COMMIT_SHA: ${{ github.sha }}

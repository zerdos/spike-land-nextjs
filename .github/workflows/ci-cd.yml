name: CI/CD Pipeline

permissions:
  contents: read
  pull-requests: write # For PR comments

# Cancel in-progress runs for the same PR/branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

on:
  push:
    branches:
      - "main"
    paths-ignore:
      - "**.md"
      - "docs/**"
      - "CLAUDE.md"
  pull_request:
    branches:
      - "main"
    paths-ignore:
      - "**.md"
      - "docs/**"

# Deployment Strategy:
# - Preview deployments: Created for PRs via Vercel Git integration
# - Staging (next.spike.land): Auto-deployed from main after tests pass
# - Production (spike.land): Manual deployment via workflow_dispatch (deploy.yml)

# NOTE: This project uses Yarn 4 with node-modules linker.
# Setup is managed by .github/actions/setup composite action which caches:
# - node_modules (keyed on yarn.lock + .yarnrc.yml)
# - .yarn/cache (fallback for cold installs)
# - Prisma client (keyed on schema.prisma)
# - Shared package dist (keyed on source)
# - Playwright browsers (keyed on version)

jobs:
  # ============================================================================
  # TIER 1: All these jobs run in PARALLEL immediately (no dependencies)
  # ============================================================================
  quality-checks:
    name: Quality Checks (Lint + Security)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - uses: ./.github/actions/setup
        with:
          generate-prisma: "true"
          build-shared: "true"

      - name: Cache TypeScript build info
        uses: actions/cache@v5
        with:
          path: tsconfig.tsbuildinfo
          key: ${{ runner.os }}-tsbuildinfo-${{ hashFiles('**/tsconfig.json', 'src/**/*.ts', 'src/**/*.tsx') }}
          restore-keys: |
            ${{ runner.os }}-tsbuildinfo-

      - name: Run linter
        run: yarn lint

      - name: Tsc check
        run: yarn tsc --noEmit

      - name: Check for undocumented skipped tests
        run: yarn check:skips

      - name: Run security audit
        run: yarn npm audit --all --severity moderate

  unit-tests:
    name: unit-tests-${{ matrix.shard }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        shard: [1, 2, 3, 4]
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - uses: ./.github/actions/setup
        with:
          generate-prisma: "true"

      - name: Fetch main branch for comparison
        if: github.ref != 'refs/heads/main'
        run: git fetch origin main:main

      - name: Run tests (shard ${{ matrix.shard }}/4)
        run: |
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            # On main branch: run all tests with coverage generation (thresholds disabled for shards)
            # Coverage thresholds cannot be enforced per-shard since each shard only covers part of the codebase
            # Thresholds are checked via Codecov which merges all shards
            yarn vitest run --coverage --coverage.thresholds.lines=0 --coverage.thresholds.functions=0 --coverage.thresholds.branches=0 --coverage.thresholds.statements=0 --shard=${{ matrix.shard }}/4 --reporter=github-actions
          else
            # On PR/feature branch: run only changed tests (no coverage threshold enforcement)
            yarn test:run --changed main --shard=${{ matrix.shard }}/4 --reporter=github-actions
          fi
        env:
          # Provide dummy DATABASE_URL for Prisma 7 client engine initialization
          DATABASE_URL: postgresql://dummy:dummy@localhost:5432/dummy?schema=public

      - name: Upload coverage reports
        uses: codecov/codecov-action@v5
        # Only upload if coverage was generated (skipped when --changed finds no tests)
        if: always() && hashFiles('./coverage/lcov.info') != ''
        with:
          files: ./coverage/lcov.info
          flags: unittests
          name: codecov-shard-${{ matrix.shard }}
          fail_ci_if_error: false
          token: ${{ secrets.CODECOV_TOKEN }}

  # Package tests run the tests for workspace packages (code, backend, transpiler, renderer)
  package-tests:
    name: Package Tests
    runs-on: ubuntu-latest
    # NO DEPENDENCIES - runs in parallel with other Tier 1 jobs

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - uses: ./.github/actions/setup

      - name: Run package tests
        run: yarn test:packages
        env:
          DATABASE_URL: postgresql://dummy:dummy@localhost:5432/dummy?schema=public

  # Build runs in PARALLEL with quality-checks and unit-tests (no needs)
  build:
    name: Build Application
    runs-on: ubuntu-latest
    # NO DEPENDENCIES - runs immediately in parallel with tests and lint!

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - uses: ./.github/actions/setup
        with:
          generate-prisma: "true"
          build-shared: "true"

      - name: Restore Next.js build cache
        uses: actions/cache/restore@v5
        with:
          path: .next/cache
          key: ${{ runner.os }}-nextjs-v2-${{ hashFiles('**/yarn.lock') }}-${{ hashFiles('**/*.ts', '**/*.tsx') }}
          restore-keys: |
            ${{ runner.os }}-nextjs-v2-${{ hashFiles('**/yarn.lock') }}-
            ${{ runner.os }}-nextjs-v2-

      - name: Build application
        run: yarn build
        env:
          NODE_OPTIONS: "--max-old-space-size=8192"
          # Provide dummy DATABASE_URL for Prisma 7 client engine initialization
          # Actual database connection only happens at runtime with real credentials
          DATABASE_URL: postgresql://dummy:dummy@localhost:5432/dummy?schema=public
          # Skip TypeScript during build - it runs in parallel via quality-checks job
          # Note: Next.js 16 no longer runs ESLint during build by default
          SKIP_TS_BUILD_CHECK: "true"

      - name: Save Next.js build cache
        if: success()
        uses: actions/cache/save@v5
        with:
          path: .next/cache
          key: ${{ runner.os }}-nextjs-v2-${{ hashFiles('**/yarn.lock') }}-${{ hashFiles('**/*.ts', '**/*.tsx') }}

      - name: Verify build output
        run: |
          echo "=== Checking .next directory ==="
          ls -la .next/ || echo ".next directory not found!"
          echo "=== Checking for BUILD_ID ==="
          cat .next/BUILD_ID || echo "BUILD_ID not found!"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: nextjs-build
          path: .next
          retention-days: 1
          include-hidden-files: true

  # ============================================================================
  # TIER 2: E2E Database Seed - prepares test database before sharded E2E tests
  # ============================================================================

  e2e-seed:
    name: Seed E2E Database
    runs-on: ubuntu-latest
    # NO DEPENDENCIES - runs in parallel with other Tier 1 jobs

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - uses: ./.github/actions/setup
        with:
          generate-prisma: "true"

      - name: Wake up E2E database
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL_E2E }}
          NEON_API_KEY: ${{ secrets.NEON_API_KEY }}
          NEON_PROJECT_ID: ${{ secrets.NEON_PROJECT_ID }}
        run: |
          # Neon auto-suspends inactive branches after ~5 minutes
          # Cold starts can take 30-60 seconds, so we need extended retry logic
          # Note: Neon API requires matching project ID - if E2E uses a different project,
          # the API call will 404 and we fall back to connection-based wake-up

          API_WAKE_SUCCESS=false

          # Try Neon API wake-up if credentials are available
          if [ -n "$NEON_API_KEY" ] && [ -n "$NEON_PROJECT_ID" ]; then
            # Extract endpoint ID from DATABASE_URL (format: ep-xxx-yyy-zzz)
            ENDPOINT_ID=$(echo "$DATABASE_URL" | grep -oE 'ep-[a-z]+-[a-z]+-[a-z0-9]+' | head -1)

            if [ -n "$ENDPOINT_ID" ]; then
              echo "Attempting to start Neon endpoint via API: $ENDPOINT_ID"

              # Start the endpoint via Neon API
              HTTP_STATUS=$(curl -s -o /tmp/neon_response.json -w "%{http_code}" \
                -X POST "https://console.neon.tech/api/v2/projects/$NEON_PROJECT_ID/endpoints/$ENDPOINT_ID/start" \
                -H "Authorization: Bearer $NEON_API_KEY" \
                -H "Content-Type: application/json")

              if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "202" ]; then
                echo "Neon API accepted start request (status: $HTTP_STATUS)"
                API_WAKE_SUCCESS=true
                # Give the endpoint time to start (Neon cold starts can take 30-60s)
                echo "Waiting 30s for endpoint to start..."
                sleep 30
              else
                echo "Neon API returned status $HTTP_STATUS (endpoint may be in different project)"
                cat /tmp/neon_response.json 2>/dev/null || true
                echo "Falling back to connection-based wake-up..."
              fi
            fi
          fi

          # Connection-based wake-up with extended retry loop
          # If API succeeded, we need fewer retries. If not, we need more time.
          if [ "$API_WAKE_SUCCESS" = "true" ]; then
            MAX_ATTEMPTS=6
            SLEEP_TIME=10
          else
            MAX_ATTEMPTS=12
            SLEEP_TIME=10
            echo "Using extended retry loop (cold start may take 60-120s)..."
          fi

          echo "Verifying database connection..."
          for i in $(seq 1 $MAX_ATTEMPTS); do
            if npx prisma db execute --stdin <<< "SELECT 1" 2>/dev/null; then
              echo "Database is ready!"
              exit 0
            fi
            echo "Attempt $i/$MAX_ATTEMPTS: Database still waking up, waiting ${SLEEP_TIME}s..."
            sleep $SLEEP_TIME
          done

          echo "Database failed to respond after $MAX_ATTEMPTS attempts"
          exit 1

      - name: Apply Prisma migrations to E2E database
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL_E2E }}
        run: |
          # Try to apply migrations, but continue if database isn't baselined
          # The E2E database may have been set up before Prisma migrations were used
          yarn prisma migrate deploy || {
            echo "Migration deploy failed (P3005 = database not baselined). Proceeding with db push instead..."
            yarn prisma db push --accept-data-loss
          }

      - name: Seed E2E test database
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL_E2E }}
          E2E_DATABASE_CONFIRMED: true
        run: yarn db:seed-e2e

  # ============================================================================
  # TIER 2: E2E Tests - runs against localhost (after database seed)
  # ============================================================================

  # E2E tests run against localhost using Turbopack dev server.
  # This speeds up CI by not waiting for the production build.
  # Turbopack provides fast incremental compilation for dev mode.
  # Tests are sharded across 16 runners for faster execution.
  # Includes @requires-db tests - all shards connect to test database.
  e2e:
    name: E2E Tests [${{ matrix.shard }}/16]
    runs-on: ubuntu-latest
    needs: [e2e-seed] # Only wait for database seeding, not build
    timeout-minutes: 45
    strategy:
      matrix:
        shard: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - uses: ./.github/actions/setup
        with:
          generate-prisma: "true"
          build-shared: "true"
          install-playwright: "true"

      - name: Run E2E tests (shard ${{ matrix.shard }}/16)
        env:
          BASE_URL: http://localhost:3000
          E2E_BYPASS_SECRET: ${{ secrets.E2E_BYPASS_SECRET }}
          DATABASE_URL: ${{ secrets.DATABASE_URL_E2E }}
          AUTH_SECRET: ${{ secrets.AUTH_SECRET }}
          NEXTAUTH_URL: http://localhost:3000
          SKIP_ENV_VALIDATION: "true"
          SHARD_INDEX: ${{ matrix.shard }}
          SHARD_TOTAL: 16
          # Upstash Redis for queue operations
          KV_REST_API_URL: ${{ secrets.KV_REST_API_URL }}
          KV_REST_API_TOKEN: ${{ secrets.KV_REST_API_TOKEN }}
        run: yarn start:server:and:test:turbo
      - name: Upload E2E test reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-reports-shard-${{ matrix.shard }}
          path: e2e/reports
          retention-days: 7

  # ============================================================================
  # TIER 3: E2E Database Cleanup - cleans up test database after all shards complete
  # ============================================================================

  e2e-cleanup:
    name: Cleanup E2E Database
    runs-on: ubuntu-latest
    needs: [e2e]
    if: always() # Run cleanup even if tests fail
    env:
      DATABASE_URL: ${{ secrets.DATABASE_URL_E2E }}
      E2E_DATABASE_CONFIRMED: true

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - uses: ./.github/actions/setup
        with:
          generate-prisma: "true"

      - name: Cleanup E2E test database
        run: yarn db:cleanup-e2e

  # ============================================================================
  # TIER 4: Deploy to Staging - auto-deploys main branch after all tests pass
  # ============================================================================

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [quality-checks, unit-tests, package-tests, build, e2e]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - uses: ./.github/actions/setup

      - name: Install Vercel CLI
        run: npm install -g vercel@latest

      - name: Pull Vercel Environment Info
        run: vercel pull --yes --environment=preview --token=${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Build with Vercel
        run: vercel build --token=${{ secrets.VERCEL_TOKEN }}
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Deploy to Staging
        id: deploy
        run: |
          DEPLOYMENT_URL=$(vercel deploy --prebuilt --token=${{ secrets.VERCEL_TOKEN }})
          echo "url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          # Alias to next.spike.land
          vercel alias "$DEPLOYMENT_URL" next.spike.land --token=${{ secrets.VERCEL_TOKEN }} || echo "Alias failed, continuing..."
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Health Check
        run: |
          echo "Waiting for deployment to be ready..."
          sleep 30

          echo "Checking health at: $DEPLOY_URL"

          for i in {1..5}; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$DEPLOY_URL" || echo "000")
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "Health check passed!"
              exit 0
            fi
            echo "Attempt $i: Got HTTP $HTTP_STATUS, retrying..."
            sleep 10
          done

          echo "Health check failed after 5 attempts"
          exit 1
        env:
          DEPLOY_URL: ${{ steps.deploy.outputs.url }}

      - name: Deployment Summary
        run: |
          echo "## Staging Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **URL:** $DEPLOY_URL" >> $GITHUB_STEP_SUMMARY
          echo "- **Alias:** https://next.spike.land" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** $COMMIT_SHA" >> $GITHUB_STEP_SUMMARY
        env:
          DEPLOY_URL: ${{ steps.deploy.outputs.url }}
          COMMIT_SHA: ${{ github.sha }}
